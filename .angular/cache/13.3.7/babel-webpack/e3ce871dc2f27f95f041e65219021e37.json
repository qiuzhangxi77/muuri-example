{"ast":null,"code":"/**\n* Muuri v0.9.5\n* https://muuri.dev/\n* Copyright (c) 2015-present, Haltu Oy\n* Released under the MIT license\n* https://github.com/haltu/muuri/blob/master/LICENSE.md\n* @license MIT\n*\n* Muuri Packer\n* Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri Ticker / Muuri Emitter / Muuri Dragger\n* Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri AutoScroller\n* Copyright (c) 2019-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*/\nvar GRID_INSTANCES = {};\nvar ITEM_ELEMENT_MAP = typeof Map === 'function' ? new Map() : null;\nvar ACTION_SWAP = 'swap';\nvar ACTION_MOVE = 'move';\nvar EVENT_SYNCHRONIZE = 'synchronize';\nvar EVENT_LAYOUT_START = 'layoutStart';\nvar EVENT_LAYOUT_END = 'layoutEnd';\nvar EVENT_LAYOUT_ABORT = 'layoutAbort';\nvar EVENT_ADD = 'add';\nvar EVENT_REMOVE = 'remove';\nvar EVENT_SHOW_START = 'showStart';\nvar EVENT_SHOW_END = 'showEnd';\nvar EVENT_HIDE_START = 'hideStart';\nvar EVENT_HIDE_END = 'hideEnd';\nvar EVENT_FILTER = 'filter';\nvar EVENT_SORT = 'sort';\nvar EVENT_MOVE = 'move';\nvar EVENT_SEND = 'send';\nvar EVENT_BEFORE_SEND = 'beforeSend';\nvar EVENT_RECEIVE = 'receive';\nvar EVENT_BEFORE_RECEIVE = 'beforeReceive';\nvar EVENT_DRAG_INIT = 'dragInit';\nvar EVENT_DRAG_START = 'dragStart';\nvar EVENT_DRAG_MOVE = 'dragMove';\nvar EVENT_DRAG_SCROLL = 'dragScroll';\nvar EVENT_DRAG_END = 'dragEnd';\nvar EVENT_DRAG_RELEASE_START = 'dragReleaseStart';\nvar EVENT_DRAG_RELEASE_END = 'dragReleaseEnd';\nvar EVENT_DESTROY = 'destroy';\nvar HAS_TOUCH_EVENTS = ('ontouchstart' in window);\nvar HAS_POINTER_EVENTS = !!window.PointerEvent;\nvar HAS_MS_POINTER_EVENTS = !!window.navigator.msPointerEnabled;\nvar MAX_SAFE_FLOAT32_INTEGER = 16777216;\n/**\n * Event emitter constructor.\n *\n * @class\n */\n\nfunction Emitter() {\n  this._events = {};\n  this._queue = [];\n  this._counter = 0;\n  this._clearOnEmit = false;\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\n\n\nEmitter.prototype.on = function (event, listener) {\n  if (!this._events || !event || !listener) return this; // Get listeners queue and create it if it does not exist.\n\n  var listeners = this._events[event];\n  if (!listeners) listeners = this._events[event] = []; // Add the listener to the queue.\n\n  listeners.push(listener);\n  return this;\n};\n/**\n * Unbind all event listeners that match the provided listener function.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\n\n\nEmitter.prototype.off = function (event, listener) {\n  if (!this._events || !event || !listener) return this; // Get listeners and return immediately if none is found.\n\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) return this; // Remove all matching listeners.\n\n  var index;\n\n  while ((index = listeners.indexOf(listener)) !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  return this;\n};\n/**\n * Unbind all listeners of the provided event.\n *\n * @public\n * @param {String} event\n * @returns {Emitter}\n */\n\n\nEmitter.prototype.clear = function (event) {\n  if (!this._events || !event) return this;\n  var listeners = this._events[event];\n\n  if (listeners) {\n    listeners.length = 0;\n    delete this._events[event];\n  }\n\n  return this;\n};\n/**\n * Emit all listeners in a specified event with the provided arguments.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\n\n\nEmitter.prototype.emit = function (event) {\n  if (!this._events || !event) {\n    this._clearOnEmit = false;\n    return this;\n  } // Get event listeners and quit early if there's no listeners.\n\n\n  var listeners = this._events[event];\n\n  if (!listeners || !listeners.length) {\n    this._clearOnEmit = false;\n    return this;\n  }\n\n  var queue = this._queue;\n  var startIndex = queue.length;\n  var argsLength = arguments.length - 1;\n  var args; // If we have more than 3 arguments let's put the arguments in an array and\n  // apply it to the listeners.\n\n  if (argsLength > 3) {\n    args = [];\n    args.push.apply(args, arguments);\n    args.shift();\n  } // Add the current listeners to the callback queue before we process them.\n  // This is necessary to guarantee that all of the listeners are called in\n  // correct order even if new event listeners are removed/added during\n  // processing and/or events are emitted during processing.\n\n\n  queue.push.apply(queue, listeners); // Reset the event's listeners if need be.\n\n  if (this._clearOnEmit) {\n    listeners.length = 0;\n    this._clearOnEmit = false;\n  } // Increment queue counter. This is needed for the scenarios where emit is\n  // triggered while the queue is already processing. We need to keep track of\n  // how many \"queue processors\" there are active so that we can safely reset\n  // the queue in the end when the last queue processor is finished.\n\n\n  ++this._counter; // Process the queue (the specific part of it for this emit).\n\n  var i = startIndex;\n  var endIndex = queue.length;\n\n  for (; i < endIndex; i++) {\n    // prettier-ignore\n    argsLength === 0 ? queue[i]() : argsLength === 1 ? queue[i](arguments[1]) : argsLength === 2 ? queue[i](arguments[1], arguments[2]) : argsLength === 3 ? queue[i](arguments[1], arguments[2], arguments[3]) : queue[i].apply(null, args); // Stop processing if the emitter is destroyed.\n\n    if (!this._events) return this;\n  } // Decrement queue process counter.\n\n\n  --this._counter; // Reset the queue if there are no more queue processes running.\n\n  if (!this._counter) queue.length = 0;\n  return this;\n};\n/**\n * Emit all listeners in a specified event with the provided arguments and\n * remove the event's listeners just before calling the them. This method allows\n * the emitter to serve as a queue where all listeners are called only once.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\n\n\nEmitter.prototype.burst = function () {\n  if (!this._events) return this;\n  this._clearOnEmit = true;\n  this.emit.apply(this, arguments);\n  return this;\n};\n/**\n * Check how many listeners there are for a specific event.\n *\n * @public\n * @param {String} event\n * @returns {Boolean}\n */\n\n\nEmitter.prototype.countListeners = function (event) {\n  if (!this._events) return 0;\n  var listeners = this._events[event];\n  return listeners ? listeners.length : 0;\n};\n/**\n * Destroy emitter instance. Basically just removes all bound listeners.\n *\n * @public\n * @returns {Emitter}\n */\n\n\nEmitter.prototype.destroy = function () {\n  if (!this._events) return this;\n  this._queue.length = this._counter = 0;\n  this._events = null;\n  return this;\n};\n\nvar pointerout = HAS_POINTER_EVENTS ? 'pointerout' : HAS_MS_POINTER_EVENTS ? 'MSPointerOut' : '';\nvar waitDuration = 100;\n/**\n * If you happen to use Edge or IE on a touch capable device there is a\n * a specific case where pointercancel and pointerend events are never emitted,\n * even though one them should always be emitted when you release your finger\n * from the screen. The bug appears specifically when Muuri shifts the dragged\n * element's position in the DOM after pointerdown event, IE and Edge don't like\n * that behaviour and quite often forget to emit the pointerend/pointercancel\n * event. But, they do emit pointerout event so we utilize that here.\n * Specifically, if there has been no pointermove event within 100 milliseconds\n * since the last pointerout event we force cancel the drag operation. This hack\n * works surprisingly well 99% of the time. There is that 1% chance there still\n * that dragged items get stuck but it is what it is.\n *\n * @class\n * @param {Dragger} dragger\n */\n\nfunction EdgeHack(dragger) {\n  if (!pointerout) return;\n  this._dragger = dragger;\n  this._timeout = null;\n  this._outEvent = null;\n  this._isActive = false;\n  this._addBehaviour = this._addBehaviour.bind(this);\n  this._removeBehaviour = this._removeBehaviour.bind(this);\n  this._onTimeout = this._onTimeout.bind(this);\n  this._resetData = this._resetData.bind(this);\n  this._onStart = this._onStart.bind(this);\n  this._onOut = this._onOut.bind(this);\n\n  this._dragger.on('start', this._onStart);\n}\n/**\n * @private\n */\n\n\nEdgeHack.prototype._addBehaviour = function () {\n  if (this._isActive) return;\n  this._isActive = true;\n\n  this._dragger.on('move', this._resetData);\n\n  this._dragger.on('cancel', this._removeBehaviour);\n\n  this._dragger.on('end', this._removeBehaviour);\n\n  window.addEventListener(pointerout, this._onOut);\n};\n/**\n * @private\n */\n\n\nEdgeHack.prototype._removeBehaviour = function () {\n  if (!this._isActive) return;\n\n  this._dragger.off('move', this._resetData);\n\n  this._dragger.off('cancel', this._removeBehaviour);\n\n  this._dragger.off('end', this._removeBehaviour);\n\n  window.removeEventListener(pointerout, this._onOut);\n\n  this._resetData();\n\n  this._isActive = false;\n};\n/**\n * @private\n */\n\n\nEdgeHack.prototype._resetData = function () {\n  window.clearTimeout(this._timeout);\n  this._timeout = null;\n  this._outEvent = null;\n};\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nEdgeHack.prototype._onStart = function (e) {\n  if (e.pointerType === 'mouse') return;\n\n  this._addBehaviour();\n};\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nEdgeHack.prototype._onOut = function (e) {\n  if (!this._dragger._getTrackedTouch(e)) return;\n\n  this._resetData();\n\n  this._outEvent = e;\n  this._timeout = window.setTimeout(this._onTimeout, waitDuration);\n};\n/**\n * @private\n */\n\n\nEdgeHack.prototype._onTimeout = function () {\n  var e = this._outEvent;\n\n  this._resetData();\n\n  if (this._dragger.isActive()) this._dragger._onCancel(e);\n};\n/**\n * @public\n */\n\n\nEdgeHack.prototype.destroy = function () {\n  if (!pointerout) return;\n\n  this._dragger.off('start', this._onStart);\n\n  this._removeBehaviour();\n}; // Playing it safe here, test all potential prefixes capitalized and lowercase.\n\n\nvar vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o', 'Webkit', 'Moz', 'MS', 'O'];\nvar cache$2 = {};\n/**\n * Get prefixed CSS property name when given a non-prefixed CSS property name.\n * Returns null if the property is not supported at all.\n *\n * @param {CSSStyleDeclaration} style\n * @param {String} prop\n * @returns {String}\n */\n\nfunction getPrefixedPropName(style, prop) {\n  var prefixedProp = cache$2[prop] || '';\n  if (prefixedProp) return prefixedProp;\n  var camelProp = prop[0].toUpperCase() + prop.slice(1);\n  var i = 0;\n\n  while (i < vendorPrefixes.length) {\n    prefixedProp = vendorPrefixes[i] ? vendorPrefixes[i] + camelProp : prop;\n\n    if (prefixedProp in style) {\n      cache$2[prop] = prefixedProp;\n      return prefixedProp;\n    }\n\n    ++i;\n  }\n\n  return '';\n}\n/**\n * Check if passive events are supported.\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n *\n * @returns {Boolean}\n */\n\n\nfunction hasPassiveEvents() {\n  var isPassiveEventsSupported = false;\n\n  try {\n    var passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      }\n    });\n    window.addEventListener('testPassive', null, passiveOpts);\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n\n  return isPassiveEventsSupported;\n}\n\nvar ua = window.navigator.userAgent.toLowerCase();\nvar isEdge = ua.indexOf('edge') > -1;\nvar isIE = ua.indexOf('trident') > -1;\nvar isFirefox = ua.indexOf('firefox') > -1;\nvar isAndroid = ua.indexOf('android') > -1;\nvar listenerOptions = hasPassiveEvents() ? {\n  passive: true\n} : false;\nvar taProp = 'touchAction';\nvar taPropPrefixed = getPrefixedPropName(document.documentElement.style, taProp);\nvar taDefaultValue = 'auto';\n/**\n * Creates a new Dragger instance for an element.\n *\n * @public\n * @class\n * @param {HTMLElement} element\n * @param {Object} [cssProps]\n */\n\nfunction Dragger(element, cssProps) {\n  this._element = element;\n  this._emitter = new Emitter();\n  this._isDestroyed = false;\n  this._cssProps = {};\n  this._touchAction = '';\n  this._isActive = false;\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n  this._onStart = this._onStart.bind(this);\n  this._onMove = this._onMove.bind(this);\n  this._onCancel = this._onCancel.bind(this);\n  this._onEnd = this._onEnd.bind(this); // Can't believe had to build a freaking class for a hack!\n\n  this._edgeHack = null;\n\n  if ((isEdge || isIE) && (HAS_POINTER_EVENTS || HAS_MS_POINTER_EVENTS)) {\n    this._edgeHack = new EdgeHack(this);\n  } // Apply initial CSS props.\n\n\n  this.setCssProps(cssProps); // If touch action was not provided with initial CSS props let's assume it's\n  // auto.\n\n  if (!this._touchAction) {\n    this.setTouchAction(taDefaultValue);\n  } // Prevent native link/image dragging for the item and it's children.\n\n\n  element.addEventListener('dragstart', Dragger._preventDefault, false); // Listen to start event.\n\n  element.addEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n}\n/**\n * Protected properties\n * ********************\n */\n\n\nDragger._pointerEvents = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup'\n};\nDragger._msPointerEvents = {\n  start: 'MSPointerDown',\n  move: 'MSPointerMove',\n  cancel: 'MSPointerCancel',\n  end: 'MSPointerUp'\n};\nDragger._touchEvents = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend'\n};\nDragger._mouseEvents = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup'\n};\n\nDragger._inputEvents = function () {\n  if (HAS_TOUCH_EVENTS) return Dragger._touchEvents;\n  if (HAS_POINTER_EVENTS) return Dragger._pointerEvents;\n  if (HAS_MS_POINTER_EVENTS) return Dragger._msPointerEvents;\n  return Dragger._mouseEvents;\n}();\n\nDragger._emitter = new Emitter();\nDragger._emitterEvents = {\n  start: 'start',\n  move: 'move',\n  end: 'end',\n  cancel: 'cancel'\n};\nDragger._activeInstances = [];\n/**\n * Protected static methods\n * ************************\n */\n\nDragger._preventDefault = function (e) {\n  if (e.preventDefault && e.cancelable !== false) e.preventDefault();\n};\n\nDragger._activateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n\n  if (index > -1) return;\n\n  Dragger._activeInstances.push(instance);\n\n  Dragger._emitter.on(Dragger._emitterEvents.move, instance._onMove);\n\n  Dragger._emitter.on(Dragger._emitterEvents.cancel, instance._onCancel);\n\n  Dragger._emitter.on(Dragger._emitterEvents.end, instance._onEnd);\n\n  if (Dragger._activeInstances.length === 1) {\n    Dragger._bindListeners();\n  }\n};\n\nDragger._deactivateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n\n  if (index === -1) return;\n\n  Dragger._activeInstances.splice(index, 1);\n\n  Dragger._emitter.off(Dragger._emitterEvents.move, instance._onMove);\n\n  Dragger._emitter.off(Dragger._emitterEvents.cancel, instance._onCancel);\n\n  Dragger._emitter.off(Dragger._emitterEvents.end, instance._onEnd);\n\n  if (!Dragger._activeInstances.length) {\n    Dragger._unbindListeners();\n  }\n};\n\nDragger._bindListeners = function () {\n  window.addEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.addEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n\n  if (Dragger._inputEvents.cancel) {\n    window.addEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\n\nDragger._unbindListeners = function () {\n  window.removeEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.removeEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n\n  if (Dragger._inputEvents.cancel) {\n    window.removeEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\n\nDragger._getEventPointerId = function (event) {\n  // If we have pointer id available let's use it.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId;\n  } // For touch events let's get the first changed touch's identifier.\n\n\n  if (event.changedTouches) {\n    return event.changedTouches[0] ? event.changedTouches[0].identifier : null;\n  } // For mouse/other events let's provide a static id.\n\n\n  return 1;\n};\n\nDragger._getTouchById = function (event, id) {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId === id ? event : null;\n  } // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n\n\n  if (event.changedTouches) {\n    for (var i = 0; i < event.changedTouches.length; i++) {\n      if (event.changedTouches[i].identifier === id) {\n        return event.changedTouches[i];\n      }\n    }\n\n    return null;\n  } // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n\n\n  return event;\n};\n\nDragger._onMove = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.move, e);\n};\n\nDragger._onCancel = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.cancel, e);\n};\n\nDragger._onEnd = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.end, e);\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Reset current drag operation (if any).\n *\n * @private\n */\n\n\nDragger.prototype._reset = function () {\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n  this._isActive = false;\n\n  Dragger._deactivateInstance(this);\n};\n/**\n * Create a custom dragger event from a raw event.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {Object}\n */\n\n\nDragger.prototype._createEvent = function (type, e) {\n  var touch = this._getTrackedTouch(e);\n\n  return {\n    // Hammer.js compatibility interface.\n    type: type,\n    srcEvent: e,\n    distance: this.getDistance(),\n    deltaX: this.getDeltaX(),\n    deltaY: this.getDeltaY(),\n    deltaTime: type === Dragger._emitterEvents.start ? 0 : this.getDeltaTime(),\n    isFirst: type === Dragger._emitterEvents.start,\n    isFinal: type === Dragger._emitterEvents.end || type === Dragger._emitterEvents.cancel,\n    pointerType: e.pointerType || (e.touches ? 'touch' : 'mouse'),\n    // Partial Touch API interface.\n    identifier: this._pointerId,\n    screenX: touch.screenX,\n    screenY: touch.screenY,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    target: touch.target\n  };\n};\n/**\n * Emit a raw event as dragger event internally.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nDragger.prototype._emit = function (type, e) {\n  this._emitter.emit(type, this._createEvent(type, e));\n};\n/**\n * If the provided event is a PointerEvent this method will return it if it has\n * the same pointerId as the instance. If the provided event is a TouchEvent\n * this method will try to look for a Touch instance in the changedTouches that\n * has an identifier matching this instance's pointerId. If the provided event\n * is a MouseEvent (or just any other event than PointerEvent or TouchEvent)\n * it will be returned immediately.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {?(Touch|PointerEvent|MouseEvent)}\n */\n\n\nDragger.prototype._getTrackedTouch = function (e) {\n  if (this._pointerId === null) return null;\n  return Dragger._getTouchById(e, this._pointerId);\n};\n/**\n * Handler for start event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nDragger.prototype._onStart = function (e) {\n  if (this._isDestroyed) return; // If pointer id is already assigned let's return early.\n\n  if (this._pointerId !== null) return; // Get (and set) pointer id.\n\n  this._pointerId = Dragger._getEventPointerId(e);\n  if (this._pointerId === null) return; // Setup initial data and emit start event.\n\n  var touch = this._getTrackedTouch(e);\n\n  this._startX = this._currentX = touch.clientX;\n  this._startY = this._currentY = touch.clientY;\n  this._startTime = Date.now();\n  this._isActive = true;\n\n  this._emit(Dragger._emitterEvents.start, e); // If the drag procedure was not reset within the start procedure let's\n  // activate the instance (start listening to move/cancel/end events).\n\n\n  if (this._isActive) {\n    Dragger._activateInstance(this);\n  }\n};\n/**\n * Handler for move event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nDragger.prototype._onMove = function (e) {\n  var touch = this._getTrackedTouch(e);\n\n  if (!touch) return;\n  this._currentX = touch.clientX;\n  this._currentY = touch.clientY;\n\n  this._emit(Dragger._emitterEvents.move, e);\n};\n/**\n * Handler for cancel event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nDragger.prototype._onCancel = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n\n  this._emit(Dragger._emitterEvents.cancel, e);\n\n  this._reset();\n};\n/**\n * Handler for end event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\n\n\nDragger.prototype._onEnd = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n\n  this._emit(Dragger._emitterEvents.end, e);\n\n  this._reset();\n};\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Check if the element is being dragged at the moment.\n *\n * @public\n * @returns {Boolean}\n */\n\n\nDragger.prototype.isActive = function () {\n  return this._isActive;\n};\n/**\n * Set element's touch-action CSS property.\n *\n * @public\n * @param {String} value\n */\n\n\nDragger.prototype.setTouchAction = function (value) {\n  // Store unmodified touch action value (we trust user input here).\n  this._touchAction = value; // Set touch-action style.\n\n  if (taPropPrefixed) {\n    this._cssProps[taPropPrefixed] = '';\n    this._element.style[taPropPrefixed] = value;\n  } // If we have an unsupported touch-action value let's add a special listener\n  // that prevents default action on touch start event. A dirty hack, but best\n  // we can do for now. The other options would be to somehow polyfill the\n  // unsupported touch action behavior with custom heuristics which sounds like\n  // a can of worms. We do a special exception here for Firefox Android which's\n  // touch-action does not work properly if the dragged element is moved in the\n  // the DOM tree on touchstart.\n\n\n  if (HAS_TOUCH_EVENTS) {\n    this._element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n\n    if (this._element.style[taPropPrefixed] !== value || isFirefox && isAndroid) {\n      this._element.addEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    }\n  }\n};\n/**\n * Update element's CSS properties. Accepts an object with camel cased style\n * props with value pairs as it's first argument.\n *\n * @public\n * @param {Object} [newProps]\n */\n\n\nDragger.prototype.setCssProps = function (newProps) {\n  if (!newProps) return;\n  var currentProps = this._cssProps;\n  var element = this._element;\n  var prop;\n  var prefixedProp; // Reset current props.\n\n  for (prop in currentProps) {\n    element.style[prop] = currentProps[prop];\n    delete currentProps[prop];\n  } // Set new props.\n\n\n  for (prop in newProps) {\n    // Make sure we have a value for the prop.\n    if (!newProps[prop]) continue; // Special handling for touch-action.\n\n    if (prop === taProp) {\n      this.setTouchAction(newProps[prop]);\n      continue;\n    } // Get prefixed prop and skip if it does not exist.\n\n\n    prefixedProp = getPrefixedPropName(element.style, prop);\n    if (!prefixedProp) continue; // Store the prop and add the style.\n\n    currentProps[prefixedProp] = '';\n    element.style[prefixedProp] = newProps[prop];\n  }\n};\n/**\n * How much the pointer has moved on x-axis from start position, in pixels.\n * Positive value indicates movement from left to right.\n *\n * @public\n * @returns {Number}\n */\n\n\nDragger.prototype.getDeltaX = function () {\n  return this._currentX - this._startX;\n};\n/**\n * How much the pointer has moved on y-axis from start position, in pixels.\n * Positive value indicates movement from top to bottom.\n *\n * @public\n * @returns {Number}\n */\n\n\nDragger.prototype.getDeltaY = function () {\n  return this._currentY - this._startY;\n};\n/**\n * How far (in pixels) has pointer moved from start position.\n *\n * @public\n * @returns {Number}\n */\n\n\nDragger.prototype.getDistance = function () {\n  var x = this.getDeltaX();\n  var y = this.getDeltaY();\n  return Math.sqrt(x * x + y * y);\n};\n/**\n * How long has pointer been dragged.\n *\n * @public\n * @returns {Number}\n */\n\n\nDragger.prototype.getDeltaTime = function () {\n  return this._startTime ? Date.now() - this._startTime : 0;\n};\n/**\n * Bind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\n\n\nDragger.prototype.on = function (eventName, listener) {\n  this._emitter.on(eventName, listener);\n};\n/**\n * Unbind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\n\n\nDragger.prototype.off = function (eventName, listener) {\n  this._emitter.off(eventName, listener);\n};\n/**\n * Destroy the instance and unbind all drag event listeners.\n *\n * @public\n */\n\n\nDragger.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var element = this._element;\n  if (this._edgeHack) this._edgeHack.destroy(); // Reset data and deactivate the instance.\n\n  this._reset(); // Destroy emitter.\n\n\n  this._emitter.destroy(); // Unbind event handlers.\n\n\n  element.removeEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n  element.removeEventListener('dragstart', Dragger._preventDefault, false);\n  element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true); // Reset styles.\n\n  for (var prop in this._cssProps) {\n    element.style[prop] = this._cssProps[prop];\n    delete this._cssProps[prop];\n  } // Reset data.\n\n\n  this._element = null; // Mark as destroyed.\n\n  this._isDestroyed = true;\n};\n\nvar dt = 1000 / 60;\n\nvar raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  return this.setTimeout(function () {\n    callback(Date.now());\n  }, dt);\n}).bind(window);\n/**\n * A ticker system for handling DOM reads and writes in an efficient way.\n *\n * @class\n */\n\n\nfunction Ticker(numLanes) {\n  this._nextStep = null;\n  this._lanes = [];\n  this._stepQueue = [];\n  this._stepCallbacks = {};\n  this._step = this._step.bind(this);\n\n  for (var i = 0; i < numLanes; i++) {\n    this._lanes.push(new TickerLane());\n  }\n}\n\nTicker.prototype._step = function (time) {\n  var lanes = this._lanes;\n  var stepQueue = this._stepQueue;\n  var stepCallbacks = this._stepCallbacks;\n  var i, j, id, laneQueue, laneCallbacks, laneIndices;\n  this._nextStep = null;\n\n  for (i = 0; i < lanes.length; i++) {\n    laneQueue = lanes[i].queue;\n    laneCallbacks = lanes[i].callbacks;\n    laneIndices = lanes[i].indices;\n\n    for (j = 0; j < laneQueue.length; j++) {\n      id = laneQueue[j];\n      if (!id) continue;\n      stepQueue.push(id);\n      stepCallbacks[id] = laneCallbacks[id];\n      delete laneCallbacks[id];\n      delete laneIndices[id];\n    }\n\n    laneQueue.length = 0;\n  }\n\n  for (i = 0; i < stepQueue.length; i++) {\n    id = stepQueue[i];\n    if (stepCallbacks[id]) stepCallbacks[id](time);\n    delete stepCallbacks[id];\n  }\n\n  stepQueue.length = 0;\n};\n\nTicker.prototype.add = function (laneIndex, id, callback) {\n  this._lanes[laneIndex].add(id, callback);\n\n  if (!this._nextStep) this._nextStep = raf(this._step);\n};\n\nTicker.prototype.remove = function (laneIndex, id) {\n  this._lanes[laneIndex].remove(id);\n};\n/**\n * A lane for ticker.\n *\n * @class\n */\n\n\nfunction TickerLane() {\n  this.queue = [];\n  this.indices = {};\n  this.callbacks = {};\n}\n\nTickerLane.prototype.add = function (id, callback) {\n  var index = this.indices[id];\n  if (index !== undefined) this.queue[index] = undefined;\n  this.queue.push(id);\n  this.callbacks[id] = callback;\n  this.indices[id] = this.queue.length - 1;\n};\n\nTickerLane.prototype.remove = function (id) {\n  var index = this.indices[id];\n  if (index === undefined) return;\n  this.queue[index] = undefined;\n  delete this.callbacks[id];\n  delete this.indices[id];\n};\n\nvar LAYOUT_READ = 'layoutRead';\nvar LAYOUT_WRITE = 'layoutWrite';\nvar VISIBILITY_READ = 'visibilityRead';\nvar VISIBILITY_WRITE = 'visibilityWrite';\nvar DRAG_START_READ = 'dragStartRead';\nvar DRAG_START_WRITE = 'dragStartWrite';\nvar DRAG_MOVE_READ = 'dragMoveRead';\nvar DRAG_MOVE_WRITE = 'dragMoveWrite';\nvar DRAG_SCROLL_READ = 'dragScrollRead';\nvar DRAG_SCROLL_WRITE = 'dragScrollWrite';\nvar DRAG_SORT_READ = 'dragSortRead';\nvar PLACEHOLDER_LAYOUT_READ = 'placeholderLayoutRead';\nvar PLACEHOLDER_LAYOUT_WRITE = 'placeholderLayoutWrite';\nvar PLACEHOLDER_RESIZE_WRITE = 'placeholderResizeWrite';\nvar AUTO_SCROLL_READ = 'autoScrollRead';\nvar AUTO_SCROLL_WRITE = 'autoScrollWrite';\nvar DEBOUNCE_READ = 'debounceRead';\nvar LANE_READ = 0;\nvar LANE_READ_TAIL = 1;\nvar LANE_WRITE = 2;\nvar ticker = new Ticker(3);\n\nfunction addLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, LAYOUT_WRITE + itemId, write);\n}\n\nfunction cancelLayoutTick(itemId) {\n  ticker.remove(LANE_READ, LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, LAYOUT_WRITE + itemId);\n}\n\nfunction addVisibilityTick(itemId, read, write) {\n  ticker.add(LANE_READ, VISIBILITY_READ + itemId, read);\n  ticker.add(LANE_WRITE, VISIBILITY_WRITE + itemId, write);\n}\n\nfunction cancelVisibilityTick(itemId) {\n  ticker.remove(LANE_READ, VISIBILITY_READ + itemId);\n  ticker.remove(LANE_WRITE, VISIBILITY_WRITE + itemId);\n}\n\nfunction addDragStartTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_START_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_START_WRITE + itemId, write);\n}\n\nfunction cancelDragStartTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_START_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_START_WRITE + itemId);\n}\n\nfunction addDragMoveTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_MOVE_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_MOVE_WRITE + itemId, write);\n}\n\nfunction cancelDragMoveTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_MOVE_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_MOVE_WRITE + itemId);\n}\n\nfunction addDragScrollTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_SCROLL_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_SCROLL_WRITE + itemId, write);\n}\n\nfunction cancelDragScrollTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_SCROLL_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_SCROLL_WRITE + itemId);\n}\n\nfunction addDragSortTick(itemId, read) {\n  ticker.add(LANE_READ_TAIL, DRAG_SORT_READ + itemId, read);\n}\n\nfunction cancelDragSortTick(itemId) {\n  ticker.remove(LANE_READ_TAIL, DRAG_SORT_READ + itemId);\n}\n\nfunction addPlaceholderLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId, write);\n}\n\nfunction cancelPlaceholderLayoutTick(itemId) {\n  ticker.remove(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId);\n}\n\nfunction addPlaceholderResizeTick(itemId, write) {\n  ticker.add(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId, write);\n}\n\nfunction cancelPlaceholderResizeTick(itemId) {\n  ticker.remove(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId);\n}\n\nfunction addAutoScrollTick(read, write) {\n  ticker.add(LANE_READ, AUTO_SCROLL_READ, read);\n  ticker.add(LANE_WRITE, AUTO_SCROLL_WRITE, write);\n}\n\nfunction cancelAutoScrollTick() {\n  ticker.remove(LANE_READ, AUTO_SCROLL_READ);\n  ticker.remove(LANE_WRITE, AUTO_SCROLL_WRITE);\n}\n\nfunction addDebounceTick(debounceId, read) {\n  ticker.add(LANE_READ, DEBOUNCE_READ + debounceId, read);\n}\n\nfunction cancelDebounceTick(debounceId) {\n  ticker.remove(LANE_READ, DEBOUNCE_READ + debounceId);\n}\n\nvar AXIS_X = 1;\nvar AXIS_Y = 2;\nvar FORWARD = 4;\nvar BACKWARD = 8;\nvar LEFT = AXIS_X | BACKWARD;\nvar RIGHT = AXIS_X | FORWARD;\nvar UP = AXIS_Y | BACKWARD;\nvar DOWN = AXIS_Y | FORWARD;\nvar functionType = 'function';\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @returns {Boolean}\n */\n\nfunction isFunction(val) {\n  return typeof val === functionType;\n}\n\nvar cache$1 = typeof WeakMap === 'function' ? new WeakMap() : null;\n/**\n * Returns the computed value of an element's style property as a string.\n *\n * @param {HTMLElement} element\n * @param {String} style\n * @returns {String}\n */\n\nfunction getStyle(element, style) {\n  var styles = cache$1 && cache$1.get(element);\n\n  if (!styles) {\n    styles = window.getComputedStyle(element, null);\n    if (cache$1) cache$1.set(element, styles);\n  }\n\n  return styles.getPropertyValue(style);\n}\n/**\n * Returns the computed value of an element's style property transformed into\n * a float value.\n *\n * @param {HTMLElement} el\n * @param {String} style\n * @returns {Number}\n */\n\n\nfunction getStyleAsFloat(el, style) {\n  return parseFloat(getStyle(el, style)) || 0;\n}\n\nvar DOC_ELEM = document.documentElement;\nvar BODY = document.body;\nvar THRESHOLD_DATA = {\n  value: 0,\n  offset: 0\n};\n/**\n * @param {HTMLElement|Window} element\n * @returns {HTMLElement|Window}\n */\n\nfunction getScrollElement(element) {\n  if (element === window || element === DOC_ELEM || element === BODY) {\n    return window;\n  } else {\n    return element;\n  }\n}\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\n\n\nfunction getScrollLeft(element) {\n  return element === window ? element.pageXOffset : element.scrollLeft;\n}\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\n\n\nfunction getScrollTop(element) {\n  return element === window ? element.pageYOffset : element.scrollTop;\n}\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\n\n\nfunction getScrollLeftMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollWidth - DOC_ELEM.clientWidth;\n  } else {\n    return element.scrollWidth - element.clientWidth;\n  }\n}\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\n\n\nfunction getScrollTopMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollHeight - DOC_ELEM.clientHeight;\n  } else {\n    return element.scrollHeight - element.clientHeight;\n  }\n}\n/**\n * Get window's or element's client rectangle data relative to the element's\n * content dimensions (includes inner size + padding, excludes scrollbars,\n * borders and margins).\n *\n * @param {HTMLElement|Window} element\n * @returns {Rectangle}\n */\n\n\nfunction getContentRect(element, result) {\n  result = result || {};\n\n  if (element === window) {\n    result.width = DOC_ELEM.clientWidth;\n    result.height = DOC_ELEM.clientHeight;\n    result.left = 0;\n    result.right = result.width;\n    result.top = 0;\n    result.bottom = result.height;\n  } else {\n    var bcr = element.getBoundingClientRect();\n    var borderLeft = element.clientLeft || getStyleAsFloat(element, 'border-left-width');\n    var borderTop = element.clientTop || getStyleAsFloat(element, 'border-top-width');\n    result.width = element.clientWidth;\n    result.height = element.clientHeight;\n    result.left = bcr.left + borderLeft;\n    result.right = result.left + result.width;\n    result.top = bcr.top + borderTop;\n    result.bottom = result.top + result.height;\n  }\n\n  return result;\n}\n/**\n * @param {Item} item\n * @returns {Object}\n */\n\n\nfunction getItemAutoScrollSettings(item) {\n  return item._drag._getGrid()._settings.dragAutoScroll;\n}\n/**\n * @param {Item} item\n */\n\n\nfunction prepareItemScrollSync(item) {\n  if (!item._drag) return;\n\n  item._drag._prepareScroll();\n}\n/**\n * @param {Item} item\n */\n\n\nfunction applyItemScrollSync(item) {\n  if (!item._drag || !item._isActive) return;\n  var drag = item._drag;\n  drag._scrollDiffX = drag._scrollDiffY = 0;\n\n  item._setTranslate(drag._left, drag._top);\n}\n/**\n * Compute threshold value and edge offset.\n *\n * @param {Number} threshold\n * @param {Number} safeZone\n * @param {Number} itemSize\n * @param {Number} targetSize\n * @returns {Object}\n */\n\n\nfunction computeThreshold(threshold, safeZone, itemSize, targetSize) {\n  THRESHOLD_DATA.value = Math.min(targetSize / 2, threshold);\n  THRESHOLD_DATA.offset = Math.max(0, itemSize + THRESHOLD_DATA.value * 2 + targetSize * safeZone - targetSize) / 2;\n  return THRESHOLD_DATA;\n}\n\nfunction ScrollRequest() {\n  this.reset();\n}\n\nScrollRequest.prototype.reset = function () {\n  if (this.isActive) this.onStop();\n  this.item = null;\n  this.element = null;\n  this.isActive = false;\n  this.isEnding = false;\n  this.direction = null;\n  this.value = null;\n  this.maxValue = 0;\n  this.threshold = 0;\n  this.distance = 0;\n  this.speed = 0;\n  this.duration = 0;\n  this.action = null;\n};\n\nScrollRequest.prototype.hasReachedEnd = function () {\n  return FORWARD & this.direction ? this.value >= this.maxValue : this.value <= 0;\n};\n\nScrollRequest.prototype.computeCurrentScrollValue = function () {\n  if (this.value === null) {\n    return AXIS_X & this.direction ? getScrollLeft(this.element) : getScrollTop(this.element);\n  }\n\n  return Math.max(0, Math.min(this.value, this.maxValue));\n};\n\nScrollRequest.prototype.computeNextScrollValue = function (deltaTime) {\n  var delta = this.speed * (deltaTime / 1000);\n  var nextValue = FORWARD & this.direction ? this.value + delta : this.value - delta;\n  return Math.max(0, Math.min(nextValue, this.maxValue));\n};\n\nScrollRequest.prototype.computeSpeed = function () {\n  var data = {\n    direction: null,\n    threshold: 0,\n    distance: 0,\n    value: 0,\n    maxValue: 0,\n    deltaTime: 0,\n    duration: 0,\n    isEnding: false\n  };\n  return function (deltaTime) {\n    var item = this.item;\n    var speed = getItemAutoScrollSettings(item).speed;\n\n    if (isFunction(speed)) {\n      data.direction = this.direction;\n      data.threshold = this.threshold;\n      data.distance = this.distance;\n      data.value = this.value;\n      data.maxValue = this.maxValue;\n      data.duration = this.duration;\n      data.speed = this.speed;\n      data.deltaTime = deltaTime;\n      data.isEnding = this.isEnding;\n      return speed(item, this.element, data);\n    } else {\n      return speed;\n    }\n  };\n}();\n\nScrollRequest.prototype.tick = function (deltaTime) {\n  if (!this.isActive) {\n    this.isActive = true;\n    this.onStart();\n  }\n\n  this.value = this.computeCurrentScrollValue();\n  this.speed = this.computeSpeed(deltaTime);\n  this.value = this.computeNextScrollValue(deltaTime);\n  this.duration += deltaTime;\n  return this.value;\n};\n\nScrollRequest.prototype.onStart = function () {\n  var item = this.item;\n  var onStart = getItemAutoScrollSettings(item).onStart;\n  if (isFunction(onStart)) onStart(item, this.element, this.direction);\n};\n\nScrollRequest.prototype.onStop = function () {\n  var item = this.item;\n  var onStop = getItemAutoScrollSettings(item).onStop;\n  if (isFunction(onStop)) onStop(item, this.element, this.direction); // Manually nudge sort to happen. There's a good chance that the item is still\n  // after the scroll stops which means that the next sort will be triggered\n  // only after the item is moved or it's parent scrolled.\n\n  if (item._drag) item._drag.sort();\n};\n\nfunction ScrollAction() {\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n}\n\nScrollAction.prototype.reset = function () {\n  if (this.requestX) this.requestX.action = null;\n  if (this.requestY) this.requestY.action = null;\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n};\n\nScrollAction.prototype.addRequest = function (request) {\n  if (AXIS_X & request.direction) {\n    this.removeRequest(this.requestX);\n    this.requestX = request;\n  } else {\n    this.removeRequest(this.requestY);\n    this.requestY = request;\n  }\n\n  request.action = this;\n};\n\nScrollAction.prototype.removeRequest = function (request) {\n  if (!request) return;\n\n  if (this.requestX === request) {\n    this.requestX = null;\n    request.action = null;\n  } else if (this.requestY === request) {\n    this.requestY = null;\n    request.action = null;\n  }\n};\n\nScrollAction.prototype.computeScrollValues = function () {\n  this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n  this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n};\n\nScrollAction.prototype.scroll = function () {\n  var element = this.element;\n  if (!element) return;\n\n  if (element.scrollTo) {\n    element.scrollTo(this.scrollLeft, this.scrollTop);\n  } else {\n    element.scrollLeft = this.scrollLeft;\n    element.scrollTop = this.scrollTop;\n  }\n};\n\nfunction Pool(createItem, releaseItem) {\n  this.pool = [];\n  this.createItem = createItem;\n  this.releaseItem = releaseItem;\n}\n\nPool.prototype.pick = function () {\n  return this.pool.pop() || this.createItem();\n};\n\nPool.prototype.release = function (item) {\n  this.releaseItem(item);\n  if (this.pool.indexOf(item) !== -1) return;\n  this.pool.push(item);\n};\n\nPool.prototype.reset = function () {\n  this.pool.length = 0;\n};\n/**\n * Check if two rectangles are overlapping.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\n\n\nfunction isOverlapping(a, b) {\n  return !(a.left + a.width <= b.left || b.left + b.width <= a.left || a.top + a.height <= b.top || b.top + b.height <= a.top);\n}\n/**\n * Calculate intersection area between two rectangle.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\n\n\nfunction getIntersectionArea(a, b) {\n  if (!isOverlapping(a, b)) return 0;\n  var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n  var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n  return width * height;\n}\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\n\n\nfunction getIntersectionScore(a, b) {\n  var area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  var maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return area / maxArea * 100;\n}\n\nvar RECT_1 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nvar RECT_2 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\n\nfunction AutoScroller() {\n  this._isDestroyed = false;\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  this._items = [];\n  this._actions = [];\n  this._requests = {};\n  this._requests[AXIS_X] = {};\n  this._requests[AXIS_Y] = {};\n  this._requestOverlapCheck = {};\n  this._dragPositions = {};\n  this._dragDirections = {};\n  this._overlapCheckInterval = 150;\n  this._requestPool = new Pool(function () {\n    return new ScrollRequest();\n  }, function (request) {\n    request.reset();\n  });\n  this._actionPool = new Pool(function () {\n    return new ScrollAction();\n  }, function (action) {\n    action.reset();\n  });\n  this._readTick = this._readTick.bind(this);\n  this._writeTick = this._writeTick.bind(this);\n}\n\nAutoScroller.AXIS_X = AXIS_X;\nAutoScroller.AXIS_Y = AXIS_Y;\nAutoScroller.FORWARD = FORWARD;\nAutoScroller.BACKWARD = BACKWARD;\nAutoScroller.LEFT = LEFT;\nAutoScroller.RIGHT = RIGHT;\nAutoScroller.UP = UP;\nAutoScroller.DOWN = DOWN;\n\nAutoScroller.smoothSpeed = function (maxSpeed, acceleration, deceleration) {\n  return function (item, element, data) {\n    var targetSpeed = 0;\n\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        var factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = maxSpeed / data.threshold * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    var currentSpeed = data.speed;\n    var nextSpeed = targetSpeed;\n\n    if (currentSpeed === targetSpeed) {\n      return nextSpeed;\n    }\n\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n};\n\nAutoScroller.pointerHandle = function (pointerSize) {\n  var rect = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  };\n  var size = pointerSize || 1;\n  return function (item, x, y, w, h, pX, pY) {\n    rect.left = pX - size * 0.5;\n    rect.top = pY - size * 0.5;\n    rect.width = size;\n    rect.height = size;\n    return rect;\n  };\n};\n\nAutoScroller.prototype._readTick = function (time) {\n  if (this._isDestroyed) return;\n\n  if (time && this._tickTime) {\n    this._tickDeltaTime = time - this._tickTime;\n    this._tickTime = time;\n\n    this._updateRequests();\n\n    this._updateActions();\n  } else {\n    this._tickTime = time;\n    this._tickDeltaTime = 0;\n  }\n};\n\nAutoScroller.prototype._writeTick = function () {\n  if (this._isDestroyed) return;\n\n  this._applyActions();\n\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\n\nAutoScroller.prototype._startTicking = function () {\n  this._isTicking = true;\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\n\nAutoScroller.prototype._stopTicking = function () {\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  cancelAutoScrollTick();\n};\n\nAutoScroller.prototype._getItemHandleRect = function (item, handle, rect) {\n  var itemDrag = item._drag;\n\n  if (handle) {\n    var ev = itemDrag._dragMoveEvent || itemDrag._dragStartEvent;\n    var data = handle(item, itemDrag._clientX, itemDrag._clientY, item._width, item._height, ev.clientX, ev.clientY);\n    rect.left = data.left;\n    rect.top = data.top;\n    rect.width = data.width;\n    rect.height = data.height;\n  } else {\n    rect.left = itemDrag._clientX;\n    rect.top = itemDrag._clientY;\n    rect.width = item._width;\n    rect.height = item._height;\n  }\n\n  rect.right = rect.left + rect.width;\n  rect.bottom = rect.top + rect.height;\n  return rect;\n};\n\nAutoScroller.prototype._requestItemScroll = function (item, axis, element, direction, threshold, distance, maxValue) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n\n  if (request) {\n    if (request.element !== element || request.direction !== direction) {\n      request.reset();\n    }\n  } else {\n    request = this._requestPool.pick();\n  }\n\n  request.item = item;\n  request.element = element;\n  request.direction = direction;\n  request.threshold = threshold;\n  request.distance = distance;\n  request.maxValue = maxValue;\n  reqMap[item._id] = request;\n};\n\nAutoScroller.prototype._cancelItemScroll = function (item, axis) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n  if (!request) return;\n  if (request.action) request.action.removeRequest(request);\n\n  this._requestPool.release(request);\n\n  delete reqMap[item._id];\n};\n\nAutoScroller.prototype._checkItemOverlap = function (item, checkX, checkY) {\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n\n  if (!targets || !targets.length) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n\n  var dragDirections = this._dragDirections[item._id];\n  var dragDirectionX = dragDirections[0];\n  var dragDirectionY = dragDirections[1];\n\n  if (!dragDirectionX && !dragDirectionY) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n\n  var testRect = RECT_2;\n  var target = null;\n  var testElement = null;\n  var testAxisX = true;\n  var testAxisY = true;\n  var testScore = 0;\n  var testPriority = 0;\n  var testThreshold = null;\n  var testDirection = null;\n  var testDistance = 0;\n  var testMaxScrollX = 0;\n  var testMaxScrollY = 0;\n  var xElement = null;\n  var xPriority = -Infinity;\n  var xThreshold = 0;\n  var xScore = 0;\n  var xDirection = null;\n  var xDistance = 0;\n  var xMaxScroll = 0;\n  var yElement = null;\n  var yPriority = -Infinity;\n  var yThreshold = 0;\n  var yScore = 0;\n  var yDirection = null;\n  var yDistance = 0;\n  var yMaxScroll = 0;\n\n  for (var i = 0; i < targets.length; i++) {\n    target = targets[i];\n    testAxisX = checkX && dragDirectionX && target.axis !== AXIS_Y;\n    testAxisY = checkY && dragDirectionY && target.axis !== AXIS_X;\n    testPriority = target.priority || 0; // Ignore this item if it's x-axis and y-axis priority is lower than\n    // the currently matching item's.\n\n    if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n      continue;\n    }\n\n    testElement = getScrollElement(target.element || target);\n    testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n    testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1; // Ignore this item if there is no possibility to scroll.\n\n    if (!testMaxScrollX && !testMaxScrollY) continue;\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect); // Ignore this item if it's not overlapping at all with the dragged item.\n\n    if (testScore <= 0) continue; // Test x-axis.\n\n    if (testAxisX && testPriority >= xPriority && testMaxScrollX > 0 && (testPriority > xPriority || testScore > xScore)) {\n      testDirection = null;\n      testThreshold = computeThreshold(typeof target.threshold === 'number' ? target.threshold : threshold, safeZone, itemRect.width, testRect.width);\n\n      if (dragDirectionX === RIGHT) {\n        testDistance = testRect.right + testThreshold.offset - itemRect.right;\n\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) < testMaxScrollX) {\n          testDirection = RIGHT;\n        }\n      } else if (dragDirectionX === LEFT) {\n        testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) > 0) {\n          testDirection = LEFT;\n        }\n      }\n\n      if (testDirection !== null) {\n        xElement = testElement;\n        xPriority = testPriority;\n        xThreshold = testThreshold.value;\n        xScore = testScore;\n        xDirection = testDirection;\n        xDistance = testDistance;\n        xMaxScroll = testMaxScrollX;\n      }\n    } // Test y-axis.\n\n\n    if (testAxisY && testPriority >= yPriority && testMaxScrollY > 0 && (testPriority > yPriority || testScore > yScore)) {\n      testDirection = null;\n      testThreshold = computeThreshold(typeof target.threshold === 'number' ? target.threshold : threshold, safeZone, itemRect.height, testRect.height);\n\n      if (dragDirectionY === DOWN) {\n        testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) < testMaxScrollY) {\n          testDirection = DOWN;\n        }\n      } else if (dragDirectionY === UP) {\n        testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) > 0) {\n          testDirection = UP;\n        }\n      }\n\n      if (testDirection !== null) {\n        yElement = testElement;\n        yPriority = testPriority;\n        yThreshold = testThreshold.value;\n        yScore = testScore;\n        yDirection = testDirection;\n        yDistance = testDistance;\n        yMaxScroll = testMaxScrollY;\n      }\n    }\n  } // Request or cancel x-axis scroll.\n\n\n  if (checkX) {\n    if (xElement) {\n      this._requestItemScroll(item, AXIS_X, xElement, xDirection, xThreshold, xDistance, xMaxScroll);\n    } else {\n      this._cancelItemScroll(item, AXIS_X);\n    }\n  } // Request or cancel y-axis scroll.\n\n\n  if (checkY) {\n    if (yElement) {\n      this._requestItemScroll(item, AXIS_Y, yElement, yDirection, yThreshold, yDistance, yMaxScroll);\n    } else {\n      this._cancelItemScroll(item, AXIS_Y);\n    }\n  }\n};\n\nAutoScroller.prototype._updateScrollRequest = function (scrollRequest) {\n  var item = scrollRequest.item;\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var targetCount = targets && targets.length || 0;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n\n  var testRect = RECT_2;\n  var target = null;\n  var testElement = null;\n  var testIsAxisX = false;\n  var testScore = null;\n  var testThreshold = null;\n  var testDistance = null;\n  var testScroll = null;\n  var testMaxScroll = null;\n  var hasReachedEnd = null;\n\n  for (var i = 0; i < targetCount; i++) {\n    target = targets[i]; // Make sure we have a matching element.\n\n    testElement = getScrollElement(target.element || target);\n    if (testElement !== scrollRequest.element) continue; // Make sure we have a matching axis.\n\n    testIsAxisX = !!(AXIS_X & scrollRequest.direction);\n\n    if (testIsAxisX) {\n      if (target.axis === AXIS_Y) continue;\n    } else {\n      if (target.axis === AXIS_X) continue;\n    } // Stop scrolling if there is no room to scroll anymore.\n\n\n    testMaxScroll = testIsAxisX ? getScrollLeftMax(testElement) : getScrollTopMax(testElement);\n\n    if (testMaxScroll <= 0) {\n      break;\n    }\n\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect); // Stop scrolling if dragged item is not overlapping with the scroll\n    // element anymore.\n\n    if (testScore <= 0) {\n      break;\n    } // Compute threshold and edge offset.\n\n\n    testThreshold = computeThreshold(typeof target.threshold === 'number' ? target.threshold : threshold, safeZone, testIsAxisX ? itemRect.width : itemRect.height, testIsAxisX ? testRect.width : testRect.height); // Compute distance (based on current direction).\n\n    if (scrollRequest.direction === LEFT) {\n      testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n    } else if (scrollRequest.direction === RIGHT) {\n      testDistance = testRect.right + testThreshold.offset - itemRect.right;\n    } else if (scrollRequest.direction === UP) {\n      testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n    } else {\n      testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n    } // Stop scrolling if threshold is not exceeded.\n\n\n    if (testDistance > testThreshold.value) {\n      break;\n    } // Stop scrolling if we have reached the end of the scroll value.\n\n\n    testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n    hasReachedEnd = FORWARD & scrollRequest.direction ? testScroll >= testMaxScroll : testScroll <= 0;\n\n    if (hasReachedEnd) {\n      break;\n    } // Scrolling can continue, let's update the values.\n\n\n    scrollRequest.maxValue = testMaxScroll;\n    scrollRequest.threshold = testThreshold.value;\n    scrollRequest.distance = testDistance;\n    scrollRequest.isEnding = false;\n    return true;\n  } // Before we end the request, let's see if we need to stop the scrolling\n  // smoothly or immediately.\n\n\n  if (settings.smoothStop === true && scrollRequest.speed > 0) {\n    if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n    scrollRequest.isEnding = hasReachedEnd ? false : true;\n  } else {\n    scrollRequest.isEnding = false;\n  }\n\n  return scrollRequest.isEnding;\n};\n\nAutoScroller.prototype._updateRequests = function () {\n  var items = this._items;\n  var requestsX = this._requests[AXIS_X];\n  var requestsY = this._requests[AXIS_Y];\n  var item, reqX, reqY, checkTime, needsCheck, checkX, checkY;\n\n  for (var i = 0; i < items.length; i++) {\n    item = items[i];\n    checkTime = this._requestOverlapCheck[item._id];\n    needsCheck = checkTime > 0 && this._tickTime - checkTime > this._overlapCheckInterval;\n    checkX = true;\n    reqX = requestsX[item._id];\n\n    if (reqX && reqX.isActive) {\n      checkX = !this._updateScrollRequest(reqX);\n\n      if (checkX) {\n        needsCheck = true;\n\n        this._cancelItemScroll(item, AXIS_X);\n      }\n    }\n\n    checkY = true;\n    reqY = requestsY[item._id];\n\n    if (reqY && reqY.isActive) {\n      checkY = !this._updateScrollRequest(reqY);\n\n      if (checkY) {\n        needsCheck = true;\n\n        this._cancelItemScroll(item, AXIS_Y);\n      }\n    }\n\n    if (needsCheck) {\n      this._requestOverlapCheck[item._id] = 0;\n\n      this._checkItemOverlap(item, checkX, checkY);\n    }\n  }\n};\n\nAutoScroller.prototype._requestAction = function (request, axis) {\n  var actions = this._actions;\n  var isAxisX = axis === AXIS_X;\n  var action = null;\n\n  for (var i = 0; i < actions.length; i++) {\n    action = actions[i]; // If the action's request does not match the request's -> skip.\n\n    if (request.element !== action.element) {\n      action = null;\n      continue;\n    } // If the request and action share the same element, but the request slot\n    // for the requested axis is already reserved let's ignore and cancel this\n    // request.\n\n\n    if (isAxisX ? action.requestX : action.requestY) {\n      this._cancelItemScroll(request.item, axis);\n\n      return;\n    } // Seems like we have found our action, let's break the loop.\n\n\n    break;\n  }\n\n  if (!action) action = this._actionPool.pick();\n  action.element = request.element;\n  action.addRequest(request);\n  request.tick(this._tickDeltaTime);\n  actions.push(action);\n};\n\nAutoScroller.prototype._updateActions = function () {\n  var items = this._items;\n  var requests = this._requests;\n  var actions = this._actions;\n  var itemId;\n  var reqX;\n  var reqY;\n  var i; // Generate actions.\n\n  for (i = 0; i < items.length; i++) {\n    itemId = items[i]._id;\n    reqX = requests[AXIS_X][itemId];\n    reqY = requests[AXIS_Y][itemId];\n    if (reqX) this._requestAction(reqX, AXIS_X);\n    if (reqY) this._requestAction(reqY, AXIS_Y);\n  } // Compute actions' scroll values.\n\n\n  for (i = 0; i < actions.length; i++) {\n    actions[i].computeScrollValues();\n  }\n};\n\nAutoScroller.prototype._applyActions = function () {\n  var actions = this._actions;\n  var items = this._items;\n  var i; // No actions -> no scrolling.\n\n  if (!actions.length) return; // Scroll all the required elements.\n\n  for (i = 0; i < actions.length; i++) {\n    actions[i].scroll();\n\n    this._actionPool.release(actions[i]);\n  } // Reset actions.\n\n\n  actions.length = 0; // Sync the item position immediately after all the auto-scrolling business is\n  // finished. Without this procedure the items will jitter during auto-scroll\n  // (in some cases at least) since the drag scroll handler is async (bound to\n  // raf tick). Note that this procedure should not emit any dragScroll events,\n  // because otherwise they would be emitted twice for the same event.\n\n  for (i = 0; i < items.length; i++) prepareItemScrollSync(items[i]);\n\n  for (i = 0; i < items.length; i++) applyItemScrollSync(items[i]);\n};\n\nAutoScroller.prototype._updateDragDirection = function (item) {\n  var dragPositions = this._dragPositions[item._id];\n  var dragDirections = this._dragDirections[item._id];\n  var x1 = item._drag._left;\n  var y1 = item._drag._top;\n\n  if (dragPositions.length) {\n    var x2 = dragPositions[0];\n    var y2 = dragPositions[1];\n    dragDirections[0] = x1 > x2 ? RIGHT : x1 < x2 ? LEFT : dragDirections[0] || 0;\n    dragDirections[1] = y1 > y2 ? DOWN : y1 < y2 ? UP : dragDirections[1] || 0;\n  }\n\n  dragPositions[0] = x1;\n  dragPositions[1] = y1;\n};\n\nAutoScroller.prototype.addItem = function (item) {\n  if (this._isDestroyed) return;\n\n  var index = this._items.indexOf(item);\n\n  if (index === -1) {\n    this._items.push(item);\n\n    this._requestOverlapCheck[item._id] = this._tickTime;\n    this._dragDirections[item._id] = [0, 0];\n    this._dragPositions[item._id] = [];\n    if (!this._isTicking) this._startTicking();\n  }\n};\n\nAutoScroller.prototype.updateItem = function (item) {\n  if (this._isDestroyed) return; // Make sure the item still exists in the auto-scroller.\n\n  if (!this._dragDirections[item._id]) return;\n\n  this._updateDragDirection(item);\n\n  if (!this._requestOverlapCheck[item._id]) {\n    this._requestOverlapCheck[item._id] = this._tickTime;\n  }\n};\n\nAutoScroller.prototype.removeItem = function (item) {\n  if (this._isDestroyed) return;\n\n  var index = this._items.indexOf(item);\n\n  if (index === -1) return;\n  var itemId = item._id;\n  var reqX = this._requests[AXIS_X][itemId];\n\n  if (reqX) {\n    this._cancelItemScroll(item, AXIS_X);\n\n    delete this._requests[AXIS_X][itemId];\n  }\n\n  var reqY = this._requests[AXIS_Y][itemId];\n\n  if (reqY) {\n    this._cancelItemScroll(item, AXIS_Y);\n\n    delete this._requests[AXIS_Y][itemId];\n  }\n\n  delete this._requestOverlapCheck[itemId];\n  delete this._dragPositions[itemId];\n  delete this._dragDirections[itemId];\n\n  this._items.splice(index, 1);\n\n  if (this._isTicking && !this._items.length) {\n    this._stopTicking();\n  }\n};\n\nAutoScroller.prototype.isItemScrollingX = function (item) {\n  var reqX = this._requests[AXIS_X][item._id];\n  return !!(reqX && reqX.isActive);\n};\n\nAutoScroller.prototype.isItemScrollingY = function (item) {\n  var reqY = this._requests[AXIS_Y][item._id];\n  return !!(reqY && reqY.isActive);\n};\n\nAutoScroller.prototype.isItemScrolling = function (item) {\n  return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n};\n\nAutoScroller.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var items = this._items.slice(0);\n\n  for (var i = 0; i < items.length; i++) {\n    this.removeItem(items[i]);\n  }\n\n  this._actions.length = 0;\n\n  this._requestPool.reset();\n\n  this._actionPool.reset();\n\n  this._isDestroyed = true;\n};\n\nvar ElProto = window.Element.prototype;\n\nvar matchesFn = ElProto.matches || ElProto.matchesSelector || ElProto.webkitMatchesSelector || ElProto.mozMatchesSelector || ElProto.msMatchesSelector || ElProto.oMatchesSelector || function () {\n  return false;\n};\n/**\n * Check if element matches a CSS selector.\n *\n * @param {Element} el\n * @param {String} selector\n * @returns {Boolean}\n */\n\n\nfunction elementMatches(el, selector) {\n  return matchesFn.call(el, selector);\n}\n/**\n * Add class to an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\n\n\nfunction addClass(element, className) {\n  if (!className) return;\n\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!elementMatches(element, '.' + className)) {\n      element.className += ' ' + className;\n    }\n  }\n}\n\nvar tempArray = [];\nvar numberType = 'number';\n/**\n * Insert an item or an array of items to array to a specified index. Mutates\n * the array. The index can be negative in which case the items will be added\n * to the end of the array.\n *\n * @param {Array} array\n * @param {*} items\n * @param {Number} [index=-1]\n */\n\nfunction arrayInsert(array, items, index) {\n  var startIndex = typeof index === numberType ? index : -1;\n  if (startIndex < 0) startIndex = array.length - startIndex + 1;\n  array.splice.apply(array, tempArray.concat(startIndex, 0, items));\n  tempArray.length = 0;\n}\n/**\n * Normalize array index. Basically this function makes sure that the provided\n * array index is within the bounds of the provided array and also transforms\n * negative index to the matching positive index. The third (optional) argument\n * allows you to define offset for array's length in case you are adding items\n * to the array or removing items from the array.\n *\n * @param {Array} array\n * @param {Number} index\n * @param {Number} [sizeOffset]\n */\n\n\nfunction normalizeArrayIndex(array, index, sizeOffset) {\n  var maxIndex = Math.max(0, array.length - 1 + (sizeOffset || 0));\n  return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\n}\n/**\n * Move array item to another index.\n *\n * @param {Array} array\n * @param {Number} fromIndex\n *   - Index (positive or negative) of the item that will be moved.\n * @param {Number} toIndex\n *   - Index (positive or negative) where the item should be moved to.\n */\n\n\nfunction arrayMove(array, fromIndex, toIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return; // Normalize the indices.\n\n  var from = normalizeArrayIndex(array, fromIndex);\n  var to = normalizeArrayIndex(array, toIndex); // Add target item to the new position.\n\n  if (from !== to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n  }\n}\n/**\n * Swap array items.\n *\n * @param {Array} array\n * @param {Number} index\n *   - Index (positive or negative) of the item that will be swapped.\n * @param {Number} withIndex\n *   - Index (positive or negative) of the other item that will be swapped.\n */\n\n\nfunction arraySwap(array, index, withIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return; // Normalize the indices.\n\n  var indexA = normalizeArrayIndex(array, index);\n  var indexB = normalizeArrayIndex(array, withIndex);\n  var temp; // Swap the items.\n\n  if (indexA !== indexB) {\n    temp = array[indexA];\n    array[indexA] = array[indexB];\n    array[indexB] = temp;\n  }\n}\n\nvar transformProp = getPrefixedPropName(document.documentElement.style, 'transform') || 'transform';\nvar styleNameRegEx = /([A-Z])/g;\nvar prefixRegex = /^(webkit-|moz-|ms-|o-)/;\nvar msPrefixRegex = /^(-m-s-)/;\n/**\n * Transforms a camel case style property to kebab case style property. Handles\n * vendor prefixed properties elegantly as well, e.g. \"WebkitTransform\" and\n * \"webkitTransform\" are both transformed into \"-webkit-transform\".\n *\n * @param {String} property\n * @returns {String}\n */\n\nfunction getStyleName(property) {\n  // Initial slicing, turns \"fooBarProp\" into \"foo-bar-prop\".\n  var styleName = property.replace(styleNameRegEx, '-$1').toLowerCase(); // Handle properties that start with \"webkit\", \"moz\", \"ms\" or \"o\" prefix (we\n  // need to add an extra '-' to the beginnig).\n\n  styleName = styleName.replace(prefixRegex, '-$1'); // Handle properties that start with \"MS\" prefix (we need to transform the\n  // \"-m-s-\" into \"-ms-\").\n\n  styleName = styleName.replace(msPrefixRegex, '-ms-');\n  return styleName;\n}\n\nvar transformStyle = getStyleName(transformProp);\nvar transformNone$1 = 'none';\nvar displayInline = 'inline';\nvar displayNone = 'none';\nvar displayStyle = 'display';\n/**\n * Returns true if element is transformed, false if not. In practice the\n * element's display value must be anything else than \"none\" or \"inline\" as\n * well as have a valid transform value applied in order to be counted as a\n * transformed element.\n *\n * Borrowed from Mezr (v0.6.1):\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\n\nfunction isTransformed(element) {\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone$1) return false;\n  var display = getStyle(element, displayStyle);\n  if (display === displayInline || display === displayNone) return false;\n  return true;\n}\n/**\n * Returns an absolute positioned element's containing block, which is\n * considered to be the closest ancestor element that the target element's\n * positioning is relative to. Disclaimer: this only works as intended for\n * absolute positioned elements.\n *\n * @param {HTMLElement} element\n * @returns {(Document|Element)}\n */\n\n\nfunction getContainingBlock(element) {\n  // As long as the containing block is an element, static and not\n  // transformed, try to get the element's parent element and fallback to\n  // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n  var doc = document;\n  var res = element || doc;\n\n  while (res && res !== doc && getStyle(res, 'position') === 'static' && !isTransformed(res)) {\n    res = res.parentElement || doc;\n  }\n\n  return res;\n}\n\nvar offsetA = {};\nvar offsetB = {};\nvar offsetDiff = {};\n/**\n * Returns the element's document offset, which in practice means the vertical\n * and horizontal distance between the element's northwest corner and the\n * document's northwest corner. Note that this function always returns the same\n * object so be sure to read the data from it instead using it as a reference.\n *\n * @param {(Document|Element|Window)} element\n * @param {Object} [offsetData]\n *   - Optional data object where the offset data will be inserted to. If not\n *     provided a new object will be created for the return data.\n * @returns {Object}\n */\n\nfunction getOffset(element, offsetData) {\n  var offset = offsetData || {};\n  var rect; // Set up return data.\n\n  offset.left = 0;\n  offset.top = 0; // Document's offsets are always 0.\n\n  if (element === document) return offset; // Add viewport scroll left/top to the respective offsets.\n\n  offset.left = window.pageXOffset || 0;\n  offset.top = window.pageYOffset || 0; // Window's offsets are the viewport scroll left/top values.\n\n  if (element.self === window.self) return offset; // Add element's client rects to the offsets.\n\n  rect = element.getBoundingClientRect();\n  offset.left += rect.left;\n  offset.top += rect.top; // Exclude element's borders from the offset.\n\n  offset.left += getStyleAsFloat(element, 'border-left-width');\n  offset.top += getStyleAsFloat(element, 'border-top-width');\n  return offset;\n}\n/**\n * Calculate the offset difference two elements.\n *\n * @param {HTMLElement} elemA\n * @param {HTMLElement} elemB\n * @param {Boolean} [compareContainingBlocks=false]\n *   - When this is set to true the containing blocks of the provided elements\n *     will be used for calculating the difference. Otherwise the provided\n *     elements will be compared directly.\n * @returns {Object}\n */\n\n\nfunction getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n  offsetDiff.left = 0;\n  offsetDiff.top = 0; // If elements are same let's return early.\n\n  if (elemA === elemB) return offsetDiff; // Compare containing blocks if necessary.\n\n  if (compareContainingBlocks) {\n    elemA = getContainingBlock(elemA);\n    elemB = getContainingBlock(elemB); // If containing blocks are identical, let's return early.\n\n    if (elemA === elemB) return offsetDiff;\n  } // Finally, let's calculate the offset diff.\n\n\n  getOffset(elemA, offsetA);\n  getOffset(elemB, offsetB);\n  offsetDiff.left = offsetB.left - offsetA.left;\n  offsetDiff.top = offsetB.top - offsetA.top;\n  return offsetDiff;\n}\n/**\n * Check if overflow style value is scrollable.\n *\n * @param {String} value\n * @returns {Boolean}\n */\n\n\nfunction isScrollableOverflow(value) {\n  return value === 'auto' || value === 'scroll' || value === 'overlay';\n}\n/**\n * Check if an element is scrollable.\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\n\n\nfunction isScrollable(element) {\n  return isScrollableOverflow(getStyle(element, 'overflow')) || isScrollableOverflow(getStyle(element, 'overflow-x')) || isScrollableOverflow(getStyle(element, 'overflow-y'));\n}\n/**\n * Collect element's ancestors that are potentially scrollable elements. The\n * provided element is also also included in the check, meaning that if it is\n * scrollable it is added to the result array.\n *\n * @param {HTMLElement} element\n * @param {Array} [result]\n * @returns {Array}\n */\n\n\nfunction getScrollableAncestors(element, result) {\n  result = result || []; // Find scroll parents.\n\n  while (element && element !== document) {\n    // If element is inside ShadowDOM let's get it's host node from the real\n    // DOM and continue looping.\n    if (element.getRootNode && element instanceof DocumentFragment) {\n      element = element.getRootNode().host;\n      continue;\n    } // If element is scrollable let's add it to the scrollable list.\n\n\n    if (isScrollable(element)) {\n      result.push(element);\n    }\n\n    element = element.parentNode;\n  } // Always add window to the results.\n\n\n  result.push(window);\n  return result;\n}\n\nvar translateValue = {};\nvar transformNone = 'none';\nvar rxMat3d = /^matrix3d/;\nvar rxMatTx = /([^,]*,){4}/;\nvar rxMat3dTx = /([^,]*,){12}/;\nvar rxNextItem = /[^,]*,/;\n/**\n * Returns the element's computed translateX and translateY values as a floats.\n * The returned object is always the same object and updated every time this\n * function is called.\n *\n * @param {HTMLElement} element\n * @returns {Object}\n */\n\nfunction getTranslate(element) {\n  translateValue.x = 0;\n  translateValue.y = 0;\n  var transform = getStyle(element, transformStyle);\n\n  if (!transform || transform === transformNone) {\n    return translateValue;\n  } // Transform style can be in either matrix3d(...) or matrix(...).\n\n\n  var isMat3d = rxMat3d.test(transform);\n  var tX = transform.replace(isMat3d ? rxMat3dTx : rxMatTx, '');\n  var tY = tX.replace(rxNextItem, '');\n  translateValue.x = parseFloat(tX) || 0;\n  translateValue.y = parseFloat(tY) || 0;\n  return translateValue;\n}\n/**\n * Remove class from an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\n\n\nfunction removeClass(element, className) {\n  if (!className) return;\n\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    if (elementMatches(element, '.' + className)) {\n      element.className = (' ' + element.className + ' ').replace(' ' + className + ' ', ' ').trim();\n    }\n  }\n}\n\nvar IS_IOS = /^(iPad|iPhone|iPod)/.test(window.navigator.platform) || /^Mac/.test(window.navigator.platform) && window.navigator.maxTouchPoints > 1;\nvar START_PREDICATE_INACTIVE = 0;\nvar START_PREDICATE_PENDING = 1;\nvar START_PREDICATE_RESOLVED = 2;\nvar SCROLL_LISTENER_OPTIONS = hasPassiveEvents() ? {\n  passive: true\n} : false;\n/**\n * Bind touch interaction to an item.\n *\n * @class\n * @param {Item} item\n */\n\nfunction ItemDrag(item) {\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  this._item = item;\n  this._gridId = grid._id;\n  this._isDestroyed = false;\n  this._isMigrating = false; // Start predicate data.\n\n  this._startPredicate = isFunction(settings.dragStartPredicate) ? settings.dragStartPredicate : ItemDrag.defaultStartPredicate;\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n  this._startPredicateResult = undefined; // Data for drag sort predicate heuristics.\n\n  this._isSortNeeded = false;\n  this._sortTimer = undefined;\n  this._blockedSortIndex = null;\n  this._sortX1 = 0;\n  this._sortX2 = 0;\n  this._sortY1 = 0;\n  this._sortY2 = 0; // Setup item's initial drag data.\n\n  this._reset(); // Bind the methods that needs binding.\n\n\n  this._preStartCheck = this._preStartCheck.bind(this);\n  this._preEndCheck = this._preEndCheck.bind(this);\n  this._onScroll = this._onScroll.bind(this);\n  this._prepareStart = this._prepareStart.bind(this);\n  this._applyStart = this._applyStart.bind(this);\n  this._prepareMove = this._prepareMove.bind(this);\n  this._applyMove = this._applyMove.bind(this);\n  this._prepareScroll = this._prepareScroll.bind(this);\n  this._applyScroll = this._applyScroll.bind(this);\n  this._handleSort = this._handleSort.bind(this);\n  this._handleSortDelayed = this._handleSortDelayed.bind(this); // Get drag handle element.\n\n  this._handle = settings.dragHandle && element.querySelector(settings.dragHandle) || element; // Init dragger.\n\n  this._dragger = new Dragger(this._handle, settings.dragCssProps);\n\n  this._dragger.on('start', this._preStartCheck);\n\n  this._dragger.on('move', this._preStartCheck);\n\n  this._dragger.on('cancel', this._preEndCheck);\n\n  this._dragger.on('end', this._preEndCheck);\n}\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @type {AutoScroller}\n */\n\n\nItemDrag.autoScroller = new AutoScroller();\n/**\n * Public static methods\n * *********************\n */\n\n/**\n * Default drag start predicate handler that handles anchor elements\n * gracefully. The return value of this function defines if the drag is\n * started, rejected or pending. When true is returned the dragging is started\n * and when false is returned the dragging is rejected. If nothing is returned\n * the predicate will be called again on the next drag movement.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} event\n * @param {Object} [options]\n *   - An optional options object which can be used to pass the predicate\n *     it's options manually. By default the predicate retrieves the options\n *     from the grid's settings.\n * @returns {(Boolean|undefined)}\n */\n\nItemDrag.defaultStartPredicate = function (item, event, options) {\n  var drag = item._drag; // Make sure left button is pressed on mouse.\n\n  if (event.isFirst && event.srcEvent.button) {\n    return false;\n  } // If the start event is trusted, non-cancelable and it's default action has\n  // not been prevented it is in most cases a sign that the gesture would be\n  // cancelled anyways right after it has started (e.g. starting drag while\n  // the page is scrolling).\n\n\n  if (!IS_IOS && event.isFirst && event.srcEvent.isTrusted === true && event.srcEvent.defaultPrevented === false && event.srcEvent.cancelable === false) {\n    return false;\n  } // Final event logic. At this stage return value does not matter anymore,\n  // the predicate is either resolved or it's not and there's nothing to do\n  // about it. Here we just reset data and if the item element is a link\n  // we follow it (if there has only been slight movement).\n\n\n  if (event.isFinal) {\n    drag._finishStartPredicate(event);\n\n    return;\n  } // Setup predicate data from options if not already set.\n\n\n  var predicate = drag._startPredicateData;\n\n  if (!predicate) {\n    var config = options || drag._getGrid()._settings.dragStartPredicate || {};\n    drag._startPredicateData = predicate = {\n      distance: Math.max(config.distance, 0) || 0,\n      delay: Math.max(config.delay, 0) || 0\n    };\n  } // If delay is defined let's keep track of the latest event and initiate\n  // delay if it has not been done yet.\n\n\n  if (predicate.delay) {\n    predicate.event = event;\n\n    if (!predicate.delayTimer) {\n      predicate.delayTimer = window.setTimeout(function () {\n        predicate.delay = 0;\n\n        if (drag._resolveStartPredicate(predicate.event)) {\n          drag._forceResolveStartPredicate(predicate.event);\n\n          drag._resetStartPredicate();\n        }\n      }, predicate.delay);\n    }\n  }\n\n  return drag._resolveStartPredicate(event);\n};\n/**\n * Default drag sort predicate.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} [options]\n * @param {Number} [options.threshold=50]\n * @param {String} [options.action='move']\n * @returns {?Object}\n *   - Returns `null` if no valid index was found. Otherwise returns drag sort\n *     command.\n */\n\n\nItemDrag.defaultSortPredicate = function () {\n  var itemRect = {};\n  var targetRect = {};\n  var returnData = {};\n  var gridsArray = [];\n  var minThreshold = 1;\n  var maxThreshold = 100;\n\n  function getTargetGrid(item, rootGrid, threshold) {\n    var target = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var bestScore = -1;\n    var gridScore;\n    var grids;\n    var grid;\n    var container;\n    var containerRect;\n    var left;\n    var top;\n    var right;\n    var bottom;\n    var i; // Get potential target grids.\n\n    if (dragSort === true) {\n      gridsArray[0] = rootGrid;\n      grids = gridsArray;\n    } else if (isFunction(dragSort)) {\n      grids = dragSort.call(rootGrid, item);\n    } // Return immediately if there are no grids.\n\n\n    if (!grids || !Array.isArray(grids) || !grids.length) {\n      return target;\n    } // Loop through the grids and get the best match.\n\n\n    for (i = 0; i < grids.length; i++) {\n      grid = grids[i]; // Filter out all destroyed grids.\n\n      if (grid._isDestroyed) continue; // Compute the grid's client rect an clamp the initial boundaries to\n      // viewport dimensions.\n\n      grid._updateBoundingRect();\n\n      left = Math.max(0, grid._left);\n      top = Math.max(0, grid._top);\n      right = Math.min(window.innerWidth, grid._right);\n      bottom = Math.min(window.innerHeight, grid._bottom); // The grid might be inside one or more elements that clip it's visibility\n      // (e.g overflow scroll/hidden) so we want to find out the visible portion\n      // of the grid in the viewport and use that in our calculations.\n\n      container = grid._element.parentNode;\n\n      while (container && container !== document && container !== document.documentElement && container !== document.body) {\n        if (container.getRootNode && container instanceof DocumentFragment) {\n          container = container.getRootNode().host;\n          continue;\n        }\n\n        if (getStyle(container, 'overflow') !== 'visible') {\n          containerRect = container.getBoundingClientRect();\n          left = Math.max(left, containerRect.left);\n          top = Math.max(top, containerRect.top);\n          right = Math.min(right, containerRect.right);\n          bottom = Math.min(bottom, containerRect.bottom);\n        }\n\n        if (getStyle(container, 'position') === 'fixed') {\n          break;\n        }\n\n        container = container.parentNode;\n      } // No need to go further if target rect does not have visible area.\n\n\n      if (left >= right || top >= bottom) continue; // Check how much dragged element overlaps the container element.\n\n      targetRect.left = left;\n      targetRect.top = top;\n      targetRect.width = right - left;\n      targetRect.height = bottom - top;\n      gridScore = getIntersectionScore(itemRect, targetRect); // Check if this grid is the best match so far.\n\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        target = grid;\n      }\n    } // Always reset grids array.\n\n\n    gridsArray.length = 0;\n    return target;\n  }\n\n  return function (item, options) {\n    var drag = item._drag;\n\n    var rootGrid = drag._getGrid(); // Get drag sort predicate settings.\n\n\n    var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\n    var sortAction = options && options.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n    var migrateAction = options && options.migrateAction === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE; // Sort threshold must be a positive number capped to a max value of 100. If\n    // that's not the case this function will not work correctly. So let's clamp\n    // the threshold just in case.\n\n    sortThreshold = Math.min(Math.max(sortThreshold, minThreshold), maxThreshold); // Populate item rect data.\n\n    itemRect.width = item._width;\n    itemRect.height = item._height;\n    itemRect.left = drag._clientX;\n    itemRect.top = drag._clientY; // Calculate the target grid.\n\n    var grid = getTargetGrid(item, rootGrid, sortThreshold); // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n\n    if (!grid) return null;\n    var isMigration = item.getGrid() !== grid;\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = 0;\n    var matchIndex = -1;\n    var hasValidTargets = false;\n    var target;\n    var score;\n    var i; // If item is moved within it's originating grid adjust item's left and\n    // top props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n\n    if (grid === rootGrid) {\n      itemRect.left = drag._gridX + item._marginLeft;\n      itemRect.top = drag._gridY + item._marginTop;\n    } else {\n      grid._updateBorders(1, 0, 1, 0);\n\n      gridOffsetLeft = grid._left + grid._borderLeft;\n      gridOffsetTop = grid._top + grid._borderTop;\n    } // Loop through the target grid items and try to find the best match.\n\n\n    for (i = 0; i < grid._items.length; i++) {\n      target = grid._items[i]; // If the target item is not active or the target item is the dragged\n      // item let's skip to the next item.\n\n      if (!target._isActive || target === item) {\n        continue;\n      } // Mark the grid as having valid target items.\n\n\n      hasValidTargets = true; // Calculate the target's overlap score with the dragged item.\n\n      targetRect.width = target._width;\n      targetRect.height = target._height;\n      targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\n      targetRect.top = target._top + target._marginTop + gridOffsetTop;\n      score = getIntersectionScore(itemRect, targetRect); // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n    } // If there is no valid match and the dragged item is being moved into\n    // another grid we need to do some guess work here. If there simply are no\n    // valid targets (which means that the dragged item will be the only active\n    // item in the new grid) we can just add it as the first item. If we have\n    // valid items in the new grid and the dragged item is overlapping one or\n    // more of the items in the new grid let's make an exception with the\n    // threshold and just pick the item which the dragged item is overlapping\n    // most. However, if the dragged item is not overlapping any of the valid\n    // items in the new grid let's position it as the last item in the grid.\n\n\n    if (isMigration && matchScore < sortThreshold) {\n      matchIndex = hasValidTargets ? matchIndex : 0;\n      matchScore = sortThreshold;\n    } // Check if the best match overlaps enough to justify a placement switch.\n\n\n    if (matchScore >= sortThreshold) {\n      returnData.grid = grid;\n      returnData.index = matchIndex;\n      returnData.action = isMigration ? migrateAction : sortAction;\n      return returnData;\n    }\n\n    return null;\n  };\n}();\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Abort dragging and reset drag data.\n *\n * @public\n */\n\n\nItemDrag.prototype.stop = function () {\n  if (!this._isActive) return; // If the item is being dropped into another grid, finish it up and return\n  // immediately.\n\n  if (this._isMigrating) {\n    this._finishMigration();\n\n    return;\n  }\n\n  var item = this._item;\n  var itemId = item._id; // Stop auto-scroll.\n\n  ItemDrag.autoScroller.removeItem(item); // Cancel queued ticks.\n\n  cancelDragStartTick(itemId);\n  cancelDragMoveTick(itemId);\n  cancelDragScrollTick(itemId); // Cancel sort procedure.\n\n  this._cancelSort();\n\n  if (this._isStarted) {\n    // Remove scroll listeners.\n    this._unbindScrollListeners();\n\n    var element = item._element;\n\n    var grid = this._getGrid();\n\n    var draggingClass = grid._settings.itemDraggingClass; // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n\n      item._setTranslate(this._gridX, this._gridY); // We need to do forced reflow to make sure the dragging class is removed\n      // gracefully.\n      // eslint-disable-next-line\n\n\n      if (draggingClass) element.clientWidth;\n    } // Remove dragging class.\n\n\n    removeClass(element, draggingClass);\n  } // Reset drag data.\n\n\n  this._reset();\n};\n/**\n * Manually trigger drag sort. This is only needed for special edge cases where\n * e.g. you have disabled sort and want to trigger a sort right after enabling\n * it (and don't want to wait for the next move/scroll event).\n *\n * @private\n * @param {Boolean} [force=false]\n */\n\n\nItemDrag.prototype.sort = function (force) {\n  var item = this._item;\n\n  if (this._isActive && item._isActive && this._dragMoveEvent) {\n    if (force === true) {\n      this._handleSort();\n    } else {\n      addDragSortTick(item._id, this._handleSort);\n    }\n  }\n};\n/**\n * Destroy instance.\n *\n * @public\n */\n\n\nItemDrag.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n\n  this._dragger.destroy();\n\n  ItemDrag.autoScroller.removeItem(this._item);\n  this._isDestroyed = true;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Get Grid instance.\n *\n * @private\n * @returns {?Grid}\n */\n\n\nItemDrag.prototype._getGrid = function () {\n  return GRID_INSTANCES[this._gridId] || null;\n};\n/**\n * Setup/reset drag data.\n *\n * @private\n */\n\n\nItemDrag.prototype._reset = function () {\n  this._isActive = false;\n  this._isStarted = false; // The dragged item's container element.\n\n  this._container = null; // The dragged item's containing block.\n\n  this._containingBlock = null; // Drag/scroll event data.\n\n  this._dragStartEvent = null;\n  this._dragMoveEvent = null;\n  this._dragPrevMoveEvent = null;\n  this._scrollEvent = null; // All the elements which need to be listened for scroll events during\n  // dragging.\n\n  this._scrollers = []; // The current translateX/translateY position.\n\n  this._left = 0;\n  this._top = 0; // Dragged element's current position within the grid.\n\n  this._gridX = 0;\n  this._gridY = 0; // Dragged element's current offset from window's northwest corner. Does\n  // not account for element's margins.\n\n  this._clientX = 0;\n  this._clientY = 0; // Keep track of the clientX/Y diff for scrolling.\n\n  this._scrollDiffX = 0;\n  this._scrollDiffY = 0; // Keep track of the clientX/Y diff for moving.\n\n  this._moveDiffX = 0;\n  this._moveDiffY = 0; // Offset difference between the dragged element's temporary drag\n  // container and it's original container.\n\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n/**\n * Bind drag scroll handlers to all scrollable ancestor elements of the\n * dragged element and the drag container element.\n *\n * @private\n */\n\n\nItemDrag.prototype._bindScrollListeners = function () {\n  var gridContainer = this._getGrid()._element;\n\n  var dragContainer = this._container;\n  var scrollers = this._scrollers;\n  var gridScrollers;\n  var i; // Get dragged element's scrolling parents.\n\n  scrollers.length = 0;\n  getScrollableAncestors(this._item._element.parentNode, scrollers); // If drag container is defined and it's not the same element as grid\n  // container then we need to add the grid container and it's scroll parents\n  // to the elements which are going to be listener for scroll events.\n\n  if (dragContainer !== gridContainer) {\n    gridScrollers = [];\n    getScrollableAncestors(gridContainer, gridScrollers);\n\n    for (i = 0; i < gridScrollers.length; i++) {\n      if (scrollers.indexOf(gridScrollers[i]) < 0) {\n        scrollers.push(gridScrollers[i]);\n      }\n    }\n  } // Bind scroll listeners.\n\n\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n};\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n */\n\n\nItemDrag.prototype._unbindScrollListeners = function () {\n  var scrollers = this._scrollers;\n  var i;\n\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n\n  scrollers.length = 0;\n};\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n * @param {Object} event\n * @returns {Boolean}\n */\n\n\nItemDrag.prototype._resolveStartPredicate = function (event) {\n  var predicate = this._startPredicateData;\n  if (event.distance < predicate.distance || predicate.delay) return;\n\n  this._resetStartPredicate();\n\n  return true;\n};\n/**\n * Forcefully resolve drag start predicate.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._forceResolveStartPredicate = function (event) {\n  if (!this._isDestroyed && this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateState = START_PREDICATE_RESOLVED;\n\n    this._onStart(event);\n  }\n};\n/**\n * Finalize start predicate.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._finishStartPredicate = function (event) {\n  var element = this._item._element; // Check if this is a click (very subjective heuristics).\n\n  var isClick = Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200; // Reset predicate.\n\n  this._resetStartPredicate(); // If the gesture can be interpreted as click let's try to open the element's\n  // href url (if it is an anchor element).\n\n\n  if (isClick) openAnchorHref(element);\n};\n/**\n * Reset drag sort heuristics.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n */\n\n\nItemDrag.prototype._resetHeuristics = function (x, y) {\n  this._blockedSortIndex = null;\n  this._sortX1 = this._sortX2 = x;\n  this._sortY1 = this._sortY2 = y;\n};\n/**\n * Run heuristics and return true if overlap check can be performed, and false\n * if it can not.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n * @returns {Boolean}\n */\n\n\nItemDrag.prototype._checkHeuristics = function (x, y) {\n  var settings = this._getGrid()._settings.dragSortHeuristics;\n\n  var minDist = settings.minDragDistance; // Skip heuristics if not needed.\n\n  if (minDist <= 0) {\n    this._blockedSortIndex = null;\n    return true;\n  }\n\n  var diffX = x - this._sortX2;\n  var diffY = y - this._sortY2; // If we can't do proper bounce back check make sure that the blocked index\n  // is not set.\n\n  var canCheckBounceBack = minDist > 3 && settings.minBounceBackAngle > 0;\n\n  if (!canCheckBounceBack) {\n    this._blockedSortIndex = null;\n  }\n\n  if (Math.abs(diffX) > minDist || Math.abs(diffY) > minDist) {\n    // Reset blocked index if angle changed enough. This check requires a\n    // minimum value of 3 for minDragDistance to function properly.\n    if (canCheckBounceBack) {\n      var angle = Math.atan2(diffX, diffY);\n      var prevAngle = Math.atan2(this._sortX2 - this._sortX1, this._sortY2 - this._sortY1);\n      var deltaAngle = Math.atan2(Math.sin(angle - prevAngle), Math.cos(angle - prevAngle));\n\n      if (Math.abs(deltaAngle) > settings.minBounceBackAngle) {\n        this._blockedSortIndex = null;\n      }\n    } // Update points.\n\n\n    this._sortX1 = this._sortX2;\n    this._sortY1 = this._sortY2;\n    this._sortX2 = x;\n    this._sortY2 = y;\n    return true;\n  }\n\n  return false;\n};\n/**\n * Reset for default drag start predicate function.\n *\n * @private\n */\n\n\nItemDrag.prototype._resetStartPredicate = function () {\n  var predicate = this._startPredicateData;\n\n  if (predicate) {\n    if (predicate.delayTimer) {\n      predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\n    }\n\n    this._startPredicateData = null;\n  }\n};\n/**\n * Handle the sorting procedure. Manage drag sort heuristics/interval and\n * check overlap when necessary.\n *\n * @private\n */\n\n\nItemDrag.prototype._handleSort = function () {\n  if (!this._isActive) return;\n\n  var settings = this._getGrid()._settings; // No sorting when drag sort is disabled. Also, account for the scenario where\n  // dragSort is temporarily disabled during drag procedure so we need to reset\n  // sort timer heuristics state too.\n\n\n  if (!settings.dragSort || !settings.dragAutoScroll.sortDuringScroll && ItemDrag.autoScroller.isItemScrolling(this._item)) {\n    this._sortX1 = this._sortX2 = this._gridX;\n    this._sortY1 = this._sortY2 = this._gridY; // We set this to true intentionally so that overlap check would be\n    // triggered as soon as possible after sort becomes enabled again.\n\n    this._isSortNeeded = true;\n\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n\n    return;\n  } // If sorting is enabled we always need to run the heuristics check to keep\n  // the tracked coordinates updated. We also allow an exception when the sort\n  // timer is finished because the heuristics are intended to prevent overlap\n  // checks based on the dragged element's immediate movement and a delayed\n  // overlap check is valid if it comes through, because it was valid when it\n  // was invoked.\n\n\n  var shouldSort = this._checkHeuristics(this._gridX, this._gridY);\n\n  if (!this._isSortNeeded && !shouldSort) return;\n  var sortInterval = settings.dragSortHeuristics.sortInterval;\n\n  if (sortInterval <= 0 || this._isSortNeeded) {\n    this._isSortNeeded = false;\n\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n\n    this._checkOverlap();\n  } else if (this._sortTimer === undefined) {\n    this._sortTimer = window.setTimeout(this._handleSortDelayed, sortInterval);\n  }\n};\n/**\n * Delayed sort handler.\n *\n * @private\n */\n\n\nItemDrag.prototype._handleSortDelayed = function () {\n  this._isSortNeeded = true;\n  this._sortTimer = undefined;\n  addDragSortTick(this._item._id, this._handleSort);\n};\n/**\n * Cancel and reset sort procedure.\n *\n * @private\n */\n\n\nItemDrag.prototype._cancelSort = function () {\n  this._isSortNeeded = false;\n\n  if (this._sortTimer !== undefined) {\n    this._sortTimer = window.clearTimeout(this._sortTimer);\n  }\n\n  cancelDragSortTick(this._item._id);\n};\n/**\n * Handle the ending of the drag procedure for sorting.\n *\n * @private\n */\n\n\nItemDrag.prototype._finishSort = function () {\n  var isSortEnabled = this._getGrid()._settings.dragSort;\n\n  var needsFinalCheck = isSortEnabled && (this._isSortNeeded || this._sortTimer !== undefined);\n\n  this._cancelSort();\n\n  if (needsFinalCheck) this._checkOverlap();\n};\n/**\n * Check (during drag) if an item is overlapping other items and based on\n * the configuration layout the items.\n *\n * @private\n */\n\n\nItemDrag.prototype._checkOverlap = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n\n  var settings = this._getGrid()._settings;\n\n  var result;\n  var currentGrid;\n  var currentIndex;\n  var targetGrid;\n  var targetIndex;\n  var targetItem;\n  var sortAction;\n  var isMigration; // Get overlap check result.\n\n  if (isFunction(settings.dragSortPredicate)) {\n    result = settings.dragSortPredicate(item, this._dragMoveEvent);\n  } else {\n    result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\n  } // Let's make sure the result object has a valid index before going further.\n\n\n  if (!result || typeof result.index !== 'number') return;\n  sortAction = result.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n  currentGrid = item.getGrid();\n  targetGrid = result.grid || currentGrid;\n  isMigration = currentGrid !== targetGrid;\n  currentIndex = currentGrid._items.indexOf(item);\n  targetIndex = normalizeArrayIndex(targetGrid._items, result.index, isMigration && sortAction === ACTION_MOVE ? 1 : 0); // Prevent position bounce.\n\n  if (!isMigration && targetIndex === this._blockedSortIndex) {\n    return;\n  } // If the item was moved within it's current grid.\n\n\n  if (!isMigration) {\n    // Make sure the target index is not the current index.\n    if (currentIndex !== targetIndex) {\n      this._blockedSortIndex = currentIndex; // Do the sort.\n\n      (sortAction === ACTION_SWAP ? arraySwap : arrayMove)(currentGrid._items, currentIndex, targetIndex); // Emit move event.\n\n      if (currentGrid._hasListeners(EVENT_MOVE)) {\n        currentGrid._emit(EVENT_MOVE, {\n          item: item,\n          fromIndex: currentIndex,\n          toIndex: targetIndex,\n          action: sortAction\n        });\n      } // Layout the grid.\n\n\n      currentGrid.layout();\n    }\n  } // If the item was moved to another grid.\n  else {\n    this._blockedSortIndex = null; // Let's fetch the target item when it's still in it's original index.\n\n    targetItem = targetGrid._items[targetIndex]; // Emit beforeSend event.\n\n    if (currentGrid._hasListeners(EVENT_BEFORE_SEND)) {\n      currentGrid._emit(EVENT_BEFORE_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    } // Emit beforeReceive event.\n\n\n    if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n      targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    } // Update item's grid id reference.\n\n\n    item._gridId = targetGrid._id; // Update drag instance's migrating indicator.\n\n    this._isMigrating = item._gridId !== this._gridId; // Move item instance from current grid to target grid.\n\n    currentGrid._items.splice(currentIndex, 1);\n\n    arrayInsert(targetGrid._items, item, targetIndex); // Reset sort data.\n\n    item._sortData = null; // Emit send event.\n\n    if (currentGrid._hasListeners(EVENT_SEND)) {\n      currentGrid._emit(EVENT_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    } // Emit receive event.\n\n\n    if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n      targetGrid._emit(EVENT_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex\n      });\n    } // If the sort action is \"swap\" let's respect it and send the target item\n    // (if it exists) from the target grid to the originating grid. This process\n    // is done on purpose after the dragged item placed within the target grid\n    // so that we can keep this implementation as simple as possible utilizing\n    // the existing API.\n\n\n    if (sortAction === ACTION_SWAP && targetItem && targetItem.isActive()) {\n      // Sanity check to make sure that the target item is still part of the\n      // target grid. It could have been manipulated in the event handlers.\n      if (targetGrid._items.indexOf(targetItem) > -1) {\n        targetGrid.send(targetItem, currentGrid, currentIndex, {\n          appendTo: this._container || document.body,\n          layoutSender: false,\n          layoutReceiver: false\n        });\n      }\n    } // Layout both grids.\n\n\n    currentGrid.layout();\n    targetGrid.layout();\n  }\n};\n/**\n * If item is dragged into another grid, finish the migration process\n * gracefully.\n *\n * @private\n */\n\n\nItemDrag.prototype._finishMigration = function () {\n  var item = this._item;\n  var release = item._dragRelease;\n  var element = item._element;\n  var isActive = item._isActive;\n  var targetGrid = item.getGrid();\n  var targetGridElement = targetGrid._element;\n  var targetSettings = targetGrid._settings;\n  var targetContainer = targetSettings.dragContainer || targetGridElement;\n\n  var currentSettings = this._getGrid()._settings;\n\n  var currentContainer = element.parentNode;\n  var currentVisClass = isActive ? currentSettings.itemVisibleClass : currentSettings.itemHiddenClass;\n  var nextVisClass = isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  var translate;\n  var offsetDiff; // Destroy current drag. Note that we need to set the migrating flag to\n  // false first, because otherwise we create an infinite loop between this\n  // and the drag.stop() method.\n\n  this._isMigrating = false;\n  this.destroy(); // Update item class.\n\n  if (currentSettings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, currentSettings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  } // Update visibility class.\n\n\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  } // Move the item inside the target container if it's different than the\n  // current container.\n\n\n  if (targetContainer !== currentContainer) {\n    targetContainer.appendChild(element);\n    offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n    translate = getTranslate(element);\n    translate.x -= offsetDiff.left;\n    translate.y -= offsetDiff.top;\n  } // Update item's cached dimensions.\n\n\n  item._refreshDimensions(); // Calculate the offset difference between target's drag container (if any)\n  // and actual grid container element. We save it later for the release\n  // process.\n\n\n  offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n  release._containerDiffX = offsetDiff.left;\n  release._containerDiffY = offsetDiff.top; // Recreate item's drag handler.\n\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null; // Adjust the position of the item element if it was moved from a container\n  // to another.\n\n  if (targetContainer !== currentContainer) {\n    item._setTranslate(translate.x, translate.y);\n  } // Update child element's styles to reflect the current visibility state.\n\n\n  item._visibility.setStyles(isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles); // Start the release.\n\n\n  release.start();\n};\n/**\n * Drag pre-start handler.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._preStartCheck = function (event) {\n  // Let's activate drag start predicate state.\n  if (this._startPredicateState === START_PREDICATE_INACTIVE) {\n    this._startPredicateState = START_PREDICATE_PENDING;\n  } // If predicate is pending try to resolve it.\n\n\n  if (this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateResult = this._startPredicate(this._item, event);\n\n    if (this._startPredicateResult === true) {\n      this._startPredicateState = START_PREDICATE_RESOLVED;\n\n      this._onStart(event);\n    } else if (this._startPredicateResult === false) {\n      this._resetStartPredicate(event);\n\n      this._dragger._reset();\n\n      this._startPredicateState = START_PREDICATE_INACTIVE;\n    }\n  } // Otherwise if predicate is resolved and drag is active, move the item.\n  else if (this._startPredicateState === START_PREDICATE_RESOLVED && this._isActive) {\n    this._onMove(event);\n  }\n};\n/**\n * Drag pre-end handler.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._preEndCheck = function (event) {\n  var isResolved = this._startPredicateState === START_PREDICATE_RESOLVED; // Do final predicate check to allow user to unbind stuff for the current\n  // drag procedure within the predicate callback. The return value of this\n  // check will have no effect to the state of the predicate.\n\n  this._startPredicate(this._item, event);\n\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n  if (!isResolved || !this._isActive) return;\n\n  if (this._isStarted) {\n    this._onEnd(event);\n  } else {\n    this.stop();\n  }\n};\n/**\n * Drag start handler.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._onStart = function (event) {\n  var item = this._item;\n  if (!item._isActive) return;\n  this._isActive = true;\n  this._dragStartEvent = event;\n  ItemDrag.autoScroller.addItem(item);\n  addDragStartTick(item._id, this._prepareStart, this._applyStart);\n};\n/**\n * Prepare item to be dragged.\n *\n * @private\n *  ItemDrag.prototype\n */\n\n\nItemDrag.prototype._prepareStart = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  var element = item._element;\n\n  var grid = this._getGrid();\n\n  var settings = grid._settings;\n  var gridContainer = grid._element;\n  var dragContainer = settings.dragContainer || gridContainer;\n  var containingBlock = getContainingBlock(dragContainer);\n  var translate = getTranslate(element);\n  var elementRect = element.getBoundingClientRect();\n  var hasDragContainer = dragContainer !== gridContainer;\n  this._container = dragContainer;\n  this._containingBlock = containingBlock;\n  this._clientX = elementRect.left;\n  this._clientY = elementRect.top;\n  this._left = this._gridX = translate.x;\n  this._top = this._gridY = translate.y;\n  this._scrollDiffX = this._scrollDiffY = 0;\n  this._moveDiffX = this._moveDiffY = 0;\n\n  this._resetHeuristics(this._gridX, this._gridY); // If a specific drag container is set and it is different from the\n  // grid's container element we store the offset between containers.\n\n\n  if (hasDragContainer) {\n    var offsetDiff = getOffsetDiff(containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n};\n/**\n * Start drag for the item.\n *\n * @private\n */\n\n\nItemDrag.prototype._applyStart = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var grid = this._getGrid();\n\n  var element = item._element;\n  var release = item._dragRelease;\n  var migrate = item._migrate;\n  var hasDragContainer = this._container !== grid._element;\n\n  if (item.isPositioning()) {\n    item._layout.stop(true, this._left, this._top);\n  }\n\n  if (migrate._isActive) {\n    this._left -= migrate._containerDiffX;\n    this._top -= migrate._containerDiffY;\n    this._gridX -= migrate._containerDiffX;\n    this._gridY -= migrate._containerDiffY;\n    migrate.stop(true, this._left, this._top);\n  }\n\n  if (item.isReleasing()) {\n    release._reset();\n  }\n\n  if (grid._settings.dragPlaceholder.enabled) {\n    item._dragPlaceholder.create();\n  }\n\n  this._isStarted = true;\n\n  grid._emit(EVENT_DRAG_INIT, item, this._dragStartEvent);\n\n  if (hasDragContainer) {\n    // If the dragged element is a child of the drag container all we need to\n    // do is setup the relative drag position data.\n    if (element.parentNode === this._container) {\n      this._gridX -= this._containerDiffX;\n      this._gridY -= this._containerDiffY;\n    } // Otherwise we need to append the element inside the correct container,\n    // setup the actual drag position data and adjust the element's translate\n    // values to account for the DOM position shift.\n    else {\n      this._left += this._containerDiffX;\n      this._top += this._containerDiffY;\n\n      this._container.appendChild(element);\n\n      item._setTranslate(this._left, this._top);\n    }\n  }\n\n  addClass(element, grid._settings.itemDraggingClass);\n\n  this._bindScrollListeners();\n\n  grid._emit(EVENT_DRAG_START, item, this._dragStartEvent);\n};\n/**\n * Drag move handler.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._onMove = function (event) {\n  var item = this._item;\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  this._dragMoveEvent = event;\n  addDragMoveTick(item._id, this._prepareMove, this._applyMove);\n  addDragSortTick(item._id, this._handleSort);\n};\n/**\n * Prepare dragged item for moving.\n *\n * @private\n */\n\n\nItemDrag.prototype._prepareMove = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var settings = this._getGrid()._settings;\n\n  var axis = settings.dragAxis;\n  var nextEvent = this._dragMoveEvent;\n  var prevEvent = this._dragPrevMoveEvent || this._dragStartEvent || nextEvent; // Update horizontal position data.\n\n  if (axis !== 'y') {\n    var moveDiffX = nextEvent.clientX - prevEvent.clientX;\n    this._left = this._left - this._moveDiffX + moveDiffX;\n    this._gridX = this._gridX - this._moveDiffX + moveDiffX;\n    this._clientX = this._clientX - this._moveDiffX + moveDiffX;\n    this._moveDiffX = moveDiffX;\n  } // Update vertical position data.\n\n\n  if (axis !== 'x') {\n    var moveDiffY = nextEvent.clientY - prevEvent.clientY;\n    this._top = this._top - this._moveDiffY + moveDiffY;\n    this._gridY = this._gridY - this._moveDiffY + moveDiffY;\n    this._clientY = this._clientY - this._moveDiffY + moveDiffY;\n    this._moveDiffY = moveDiffY;\n  }\n\n  this._dragPrevMoveEvent = nextEvent;\n};\n/**\n * Apply movement to dragged item.\n *\n * @private\n */\n\n\nItemDrag.prototype._applyMove = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  this._moveDiffX = this._moveDiffY = 0;\n\n  item._setTranslate(this._left, this._top);\n\n  this._getGrid()._emit(EVENT_DRAG_MOVE, item, this._dragMoveEvent);\n\n  ItemDrag.autoScroller.updateItem(item);\n};\n/**\n * Drag scroll handler.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._onScroll = function (event) {\n  var item = this._item;\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  this._scrollEvent = event;\n  addDragScrollTick(item._id, this._prepareScroll, this._applyScroll);\n  addDragSortTick(item._id, this._handleSort);\n};\n/**\n * Prepare dragged item for scrolling.\n *\n * @private\n */\n\n\nItemDrag.prototype._prepareScroll = function () {\n  if (!this._isActive) return; // If item is not active do nothing.\n\n  var item = this._item;\n  if (!item._isActive) return;\n  var element = item._element;\n\n  var grid = this._getGrid();\n\n  var gridContainer = grid._element;\n  var rect = element.getBoundingClientRect(); // Update container diff.\n\n  if (this._container !== gridContainer) {\n    var offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  } // Update horizontal position data.\n\n\n  var scrollDiffX = this._clientX - this._moveDiffX - rect.left;\n  this._left = this._left - this._scrollDiffX + scrollDiffX;\n  this._scrollDiffX = scrollDiffX; // Update vertical position data.\n\n  var scrollDiffY = this._clientY - this._moveDiffY - rect.top;\n  this._top = this._top - this._scrollDiffY + scrollDiffY;\n  this._scrollDiffY = scrollDiffY; // Update grid position.\n\n  this._gridX = this._left - this._containerDiffX;\n  this._gridY = this._top - this._containerDiffY;\n};\n/**\n * Apply scroll to dragged item.\n *\n * @private\n */\n\n\nItemDrag.prototype._applyScroll = function () {\n  if (!this._isActive) return;\n  var item = this._item;\n  if (!item._isActive) return;\n  this._scrollDiffX = this._scrollDiffY = 0;\n\n  item._setTranslate(this._left, this._top);\n\n  this._getGrid()._emit(EVENT_DRAG_SCROLL, item, this._scrollEvent);\n};\n/**\n * Drag end handler.\n *\n * @private\n * @param {Object} event\n */\n\n\nItemDrag.prototype._onEnd = function (event) {\n  var item = this._item;\n  var element = item._element;\n\n  var grid = this._getGrid();\n\n  var settings = grid._settings;\n  var release = item._dragRelease; // If item is not active, reset drag.\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  } // Cancel queued ticks.\n\n\n  cancelDragStartTick(item._id);\n  cancelDragMoveTick(item._id);\n  cancelDragScrollTick(item._id); // Finish sort procedure (does final overlap check if needed).\n\n  this._finishSort(); // Remove scroll listeners.\n\n\n  this._unbindScrollListeners(); // Setup release data.\n\n\n  release._containerDiffX = this._containerDiffX;\n  release._containerDiffY = this._containerDiffY; // Reset drag data.\n\n  this._reset(); // Remove drag class name from element.\n\n\n  removeClass(element, settings.itemDraggingClass); // Stop auto-scroll.\n\n  ItemDrag.autoScroller.removeItem(item); // Emit dragEnd event.\n\n  grid._emit(EVENT_DRAG_END, item, event); // Finish up the migration process or start the release process.\n\n\n  this._isMigrating ? this._finishMigration() : release.start();\n};\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Check if an element is an anchor element and open the href url if possible.\n *\n * @param {HTMLElement} element\n */\n\n\nfunction openAnchorHref(element) {\n  // Make sure the element is anchor element.\n  if (element.tagName.toLowerCase() !== 'a') return; // Get href and make sure it exists.\n\n  var href = element.getAttribute('href');\n  if (!href) return; // Finally let's navigate to the link href.\n\n  var target = element.getAttribute('target');\n\n  if (target && target !== '_self') {\n    window.open(href, target);\n  } else {\n    window.location.href = href;\n  }\n}\n/**\n * Get current values of the provided styles definition object or array.\n *\n * @param {HTMLElement} element\n * @param {(Object|Array} styles\n * @return {Object}\n */\n\n\nfunction getCurrentStyles(element, styles) {\n  var result = {};\n  var prop, i;\n\n  if (Array.isArray(styles)) {\n    for (i = 0; i < styles.length; i++) {\n      prop = styles[i];\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  } else {\n    for (prop in styles) {\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  }\n\n  return result;\n}\n\nvar unprefixRegEx = /^(webkit|moz|ms|o|Webkit|Moz|MS|O)(?=[A-Z])/;\nvar cache = {};\n/**\n * Remove any potential vendor prefixes from a property name.\n *\n * @param {String} prop\n * @returns {String}\n */\n\nfunction getUnprefixedPropName(prop) {\n  var result = cache[prop];\n  if (result) return result;\n  result = prop.replace(unprefixRegEx, '');\n\n  if (result !== prop) {\n    result = result[0].toLowerCase() + result.slice(1);\n  }\n\n  cache[prop] = result;\n  return result;\n}\n\nvar nativeCode = '[native code]';\n/**\n * Check if a value (e.g. a method or constructor) is native code. Good for\n * detecting when a polyfill is used and when not.\n *\n * @param {*} feat\n * @returns {Boolean}\n */\n\nfunction isNative(feat) {\n  var S = window.Symbol;\n  return !!(feat && isFunction(S) && isFunction(S.toString) && S(feat).toString().indexOf(nativeCode) > -1);\n}\n/**\n * Set inline styles to an element.\n *\n * @param {HTMLElement} element\n * @param {Object} styles\n */\n\n\nfunction setStyles(element, styles) {\n  for (var prop in styles) {\n    element.style[prop] = styles[prop];\n  }\n}\n\nvar HAS_WEB_ANIMATIONS = !!(Element && isFunction(Element.prototype.animate));\nvar HAS_NATIVE_WEB_ANIMATIONS = !!(Element && isNative(Element.prototype.animate));\n/**\n * Item animation handler powered by Web Animations API.\n *\n * @class\n * @param {HTMLElement} element\n */\n\nfunction Animator(element) {\n  this._element = element;\n  this._animation = null;\n  this._duration = 0;\n  this._easing = '';\n  this._callback = null;\n  this._props = [];\n  this._values = [];\n  this._isDestroyed = false;\n  this._onFinish = this._onFinish.bind(this);\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start instance's animation. Automatically stops current animation if it is\n * running.\n *\n * @public\n * @param {Object} propsFrom\n * @param {Object} propsTo\n * @param {Object} [options]\n * @param {Number} [options.duration=300]\n * @param {String} [options.easing='ease']\n * @param {Function} [options.onFinish]\n */\n\n\nAnimator.prototype.start = function (propsFrom, propsTo, options) {\n  if (this._isDestroyed) return;\n  var element = this._element;\n  var opts = options || {}; // If we don't have web animations available let's not animate.\n\n  if (!HAS_WEB_ANIMATIONS) {\n    setStyles(element, propsTo);\n    this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n\n    this._onFinish();\n\n    return;\n  }\n\n  var animation = this._animation;\n  var currentProps = this._props;\n  var currentValues = this._values;\n  var duration = opts.duration || 300;\n  var easing = opts.easing || 'ease';\n  var cancelAnimation = false;\n  var propName, propCount, propIndex; // If we have an existing animation running, let's check if it needs to be\n  // cancelled or if it can continue running.\n\n  if (animation) {\n    propCount = 0; // Cancel animation if duration or easing has changed.\n\n    if (duration !== this._duration || easing !== this._easing) {\n      cancelAnimation = true;\n    } // Check if the requested animation target props and values match with the\n    // current props and values.\n\n\n    if (!cancelAnimation) {\n      for (propName in propsTo) {\n        ++propCount;\n        propIndex = currentProps.indexOf(propName);\n\n        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\n          cancelAnimation = true;\n          break;\n        }\n      } // Check if the target props count matches current props count. This is\n      // needed for the edge case scenario where target props contain the same\n      // styles as current props, but the current props have some additional\n      // props.\n\n\n      if (propCount !== currentProps.length) {\n        cancelAnimation = true;\n      }\n    }\n  } // Cancel animation (if required).\n\n\n  if (cancelAnimation) animation.cancel(); // Store animation callback.\n\n  this._callback = isFunction(opts.onFinish) ? opts.onFinish : null; // If we have a running animation that does not need to be cancelled, let's\n  // call it a day here and let it run.\n\n  if (animation && !cancelAnimation) return; // Store target props and values to instance.\n\n  currentProps.length = currentValues.length = 0;\n\n  for (propName in propsTo) {\n    currentProps.push(propName);\n    currentValues.push(propsTo[propName]);\n  } // Start the animation. We need to provide unprefixed property names to the\n  // Web Animations polyfill if it is being used. If we have native Web\n  // Animations available we need to provide prefixed properties instead.\n\n\n  this._duration = duration;\n  this._easing = easing;\n  this._animation = element.animate([createFrame(propsFrom, HAS_NATIVE_WEB_ANIMATIONS), createFrame(propsTo, HAS_NATIVE_WEB_ANIMATIONS)], {\n    duration: duration,\n    easing: easing\n  });\n  this._animation.onfinish = this._onFinish; // Set the end styles. This makes sure that the element stays at the end\n  // values after animation is finished.\n\n  setStyles(element, propsTo);\n};\n/**\n * Stop instance's current animation if running.\n *\n * @public\n */\n\n\nAnimator.prototype.stop = function () {\n  if (this._isDestroyed || !this._animation) return;\n\n  this._animation.cancel();\n\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n};\n/**\n * Read the current values of the element's animated styles from the DOM.\n *\n * @public\n * @return {Object}\n */\n\n\nAnimator.prototype.getCurrentStyles = function () {\n  return getCurrentStyles(element, currentProps);\n};\n/**\n * Check if the item is being animated currently.\n *\n * @public\n * @return {Boolean}\n */\n\n\nAnimator.prototype.isAnimating = function () {\n  return !!this._animation;\n};\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\n\n\nAnimator.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._element = null;\n  this._isDestroyed = true;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Animation end handler.\n *\n * @private\n */\n\n\nAnimator.prototype._onFinish = function () {\n  var callback = this._callback;\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n  callback && callback();\n};\n/**\n * Private helpers\n * ***************\n */\n\n\nfunction createFrame(props, prefix) {\n  var frame = {};\n\n  for (var prop in props) {\n    frame[prefix ? prop : getUnprefixedPropName(prop)] = props[prop];\n  }\n\n  return frame;\n}\n/**\n * Transform translateX and translateY value into CSS transform style\n * property's value.\n *\n * @param {Number} x\n * @param {Number} y\n * @returns {String}\n */\n\n\nfunction getTranslateString(x, y) {\n  return 'translateX(' + x + 'px) translateY(' + y + 'px)';\n}\n/**\n * Drag placeholder.\n *\n * @class\n * @param {Item} item\n */\n\n\nfunction ItemDragPlaceholder(item) {\n  this._item = item;\n  this._animation = new Animator();\n  this._element = null;\n  this._className = '';\n  this._didMigrate = false;\n  this._resetAfterLayout = false;\n  this._left = 0;\n  this._top = 0;\n  this._transX = 0;\n  this._transY = 0;\n  this._nextTransX = 0;\n  this._nextTransY = 0; // Bind animation handlers.\n\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n  this._updateDimensions = this._updateDimensions.bind(this); // Bind event handlers.\n\n  this._onLayoutStart = this._onLayoutStart.bind(this);\n  this._onLayoutEnd = this._onLayoutEnd.bind(this);\n  this._onReleaseEnd = this._onReleaseEnd.bind(this);\n  this._onMigrate = this._onMigrate.bind(this);\n  this._onHide = this._onHide.bind(this);\n}\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Update placeholder's dimensions to match the item's dimensions.\n *\n * @private\n */\n\n\nItemDragPlaceholder.prototype._updateDimensions = function () {\n  if (!this.isActive()) return;\n  setStyles(this._element, {\n    width: this._item._width + 'px',\n    height: this._item._height + 'px'\n  });\n};\n/**\n * Move placeholder to a new position.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} isInstant\n */\n\n\nItemDragPlaceholder.prototype._onLayoutStart = function (items, isInstant) {\n  var item = this._item; // If the item is not part of the layout anymore reset placeholder.\n\n  if (items.indexOf(item) === -1) {\n    this.reset();\n    return;\n  }\n\n  var nextLeft = item._left;\n  var nextTop = item._top;\n  var currentLeft = this._left;\n  var currentTop = this._top; // Keep track of item layout position.\n\n  this._left = nextLeft;\n  this._top = nextTop; // If item's position did not change, and the item did not migrate and the\n  // layout is not instant and we can safely skip layout.\n\n  if (!isInstant && !this._didMigrate && currentLeft === nextLeft && currentTop === nextTop) {\n    return;\n  } // Slots data is calculated with item margins added to them so we need to add\n  // item's left and top margin to the slot data to get the placeholder's\n  // next position.\n\n\n  var nextX = nextLeft + item._marginLeft;\n  var nextY = nextTop + item._marginTop; // Just snap to new position without any animations if no animation is\n  // required or if placeholder moves between grids.\n\n  var grid = item.getGrid();\n  var animEnabled = !isInstant && grid._settings.layoutDuration > 0;\n\n  if (!animEnabled || this._didMigrate) {\n    // Cancel potential (queued) layout tick.\n    cancelPlaceholderLayoutTick(item._id); // Snap placeholder to correct position.\n\n    this._element.style[transformProp] = getTranslateString(nextX, nextY);\n\n    this._animation.stop(); // Move placeholder inside correct container after migration.\n\n\n    if (this._didMigrate) {\n      grid.getElement().appendChild(this._element);\n      this._didMigrate = false;\n    }\n\n    return;\n  } // Start the placeholder's layout animation in the next tick. We do this to\n  // avoid layout thrashing.\n\n\n  this._nextTransX = nextX;\n  this._nextTransY = nextY;\n  addPlaceholderLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n/**\n * Prepare placeholder for layout animation.\n *\n * @private\n */\n\n\nItemDragPlaceholder.prototype._setupAnimation = function () {\n  if (!this.isActive()) return;\n  var translate = getTranslate(this._element);\n  this._transX = translate.x;\n  this._transY = translate.y;\n};\n/**\n * Start layout animation.\n *\n * @private\n */\n\n\nItemDragPlaceholder.prototype._startAnimation = function () {\n  if (!this.isActive()) return;\n  var animation = this._animation;\n  var currentX = this._transX;\n  var currentY = this._transY;\n  var nextX = this._nextTransX;\n  var nextY = this._nextTransY; // If placeholder is already in correct position let's just stop animation\n  // and be done with it.\n\n  if (currentX === nextX && currentY === nextY) {\n    if (animation.isAnimating()) {\n      this._element.style[transformProp] = getTranslateString(nextX, nextY);\n      animation.stop();\n    }\n\n    return;\n  } // Otherwise let's start the animation.\n\n\n  var settings = this._item.getGrid()._settings;\n\n  var currentStyles = {};\n  var targetStyles = {};\n  currentStyles[transformProp] = getTranslateString(currentX, currentY);\n  targetStyles[transformProp] = getTranslateString(nextX, nextY);\n  animation.start(currentStyles, targetStyles, {\n    duration: settings.layoutDuration,\n    easing: settings.layoutEasing,\n    onFinish: this._onLayoutEnd\n  });\n};\n/**\n * Layout end handler.\n *\n * @private\n */\n\n\nItemDragPlaceholder.prototype._onLayoutEnd = function () {\n  if (this._resetAfterLayout) {\n    this.reset();\n  }\n};\n/**\n * Drag end handler. This handler is called when dragReleaseEnd event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Item} item\n */\n\n\nItemDragPlaceholder.prototype._onReleaseEnd = function (item) {\n  if (item._id === this._item._id) {\n    // If the placeholder is not animating anymore we can safely reset it.\n    if (!this._animation.isAnimating()) {\n      this.reset();\n      return;\n    } // If the placeholder item is still animating here, let's wait for it to\n    // finish it's animation.\n\n\n    this._resetAfterLayout = true;\n  }\n};\n/**\n * Migration start handler. This handler is called when beforeSend event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Object} data\n * @param {Item} data.item\n * @param {Grid} data.fromGrid\n * @param {Number} data.fromIndex\n * @param {Grid} data.toGrid\n * @param {Number} data.toIndex\n */\n\n\nItemDragPlaceholder.prototype._onMigrate = function (data) {\n  // Make sure we have a matching item.\n  if (data.item !== this._item) return;\n\n  var grid = this._item.getGrid();\n\n  var nextGrid = data.toGrid; // Unbind listeners from current grid.\n\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide); // Bind listeners to the next grid.\n\n  nextGrid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  nextGrid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  nextGrid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  nextGrid.on(EVENT_HIDE_START, this._onHide); // Mark the item as migrated.\n\n  this._didMigrate = true;\n};\n/**\n * Reset placeholder if the associated item is hidden.\n *\n * @private\n * @param {Item[]} items\n */\n\n\nItemDragPlaceholder.prototype._onHide = function (items) {\n  if (items.indexOf(this._item) > -1) this.reset();\n};\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Create placeholder. Note that this method only writes to DOM and does not\n * read anything from DOM so it should not cause any additional layout\n * thrashing when it's called at the end of the drag start procedure.\n *\n * @public\n */\n\n\nItemDragPlaceholder.prototype.create = function () {\n  // If we already have placeholder set up we can skip the initiation logic.\n  if (this.isActive()) {\n    this._resetAfterLayout = false;\n    return;\n  }\n\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation; // Keep track of layout position.\n\n  this._left = item._left;\n  this._top = item._top; // Create placeholder element.\n\n  var element;\n\n  if (isFunction(settings.dragPlaceholder.createElement)) {\n    element = settings.dragPlaceholder.createElement(item);\n  } else {\n    element = document.createElement('div');\n  }\n\n  this._element = element; // Update element to animation instance.\n\n  animation._element = element; // Add placeholder class to the placeholder element.\n\n  this._className = settings.itemPlaceholderClass || '';\n\n  if (this._className) {\n    addClass(element, this._className);\n  } // Set initial styles.\n\n\n  setStyles(element, {\n    position: 'absolute',\n    left: '0px',\n    top: '0px',\n    width: item._width + 'px',\n    height: item._height + 'px'\n  }); // Set initial position.\n\n  element.style[transformProp] = getTranslateString(item._left + item._marginLeft, item._top + item._marginTop); // Bind event listeners.\n\n  grid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.on(EVENT_HIDE_START, this._onHide); // onCreate hook.\n\n  if (isFunction(settings.dragPlaceholder.onCreate)) {\n    settings.dragPlaceholder.onCreate(item, element);\n  } // Insert the placeholder element to the grid.\n\n\n  grid.getElement().appendChild(element);\n};\n/**\n * Reset placeholder data.\n *\n * @public\n */\n\n\nItemDragPlaceholder.prototype.reset = function () {\n  if (!this.isActive()) return;\n  var element = this._element;\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation; // Reset flag.\n\n  this._resetAfterLayout = false; // Cancel potential (queued) layout tick.\n\n  cancelPlaceholderLayoutTick(item._id);\n  cancelPlaceholderResizeTick(item._id); // Reset animation instance.\n\n  animation.stop();\n  animation._element = null; // Unbind event listeners.\n\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide); // Remove placeholder class from the placeholder element.\n\n  if (this._className) {\n    removeClass(element, this._className);\n    this._className = '';\n  } // Remove element.\n\n\n  element.parentNode.removeChild(element);\n  this._element = null; // onRemove hook. Note that here we use the current grid's onRemove callback\n  // so if the item has migrated during drag the onRemove method will not be\n  // the originating grid's method.\n\n  if (isFunction(settings.dragPlaceholder.onRemove)) {\n    settings.dragPlaceholder.onRemove(item, element);\n  }\n};\n/**\n * Check if placeholder is currently active (visible).\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItemDragPlaceholder.prototype.isActive = function () {\n  return !!this._element;\n};\n/**\n * Get placeholder element.\n *\n * @public\n * @returns {?HTMLElement}\n */\n\n\nItemDragPlaceholder.prototype.getElement = function () {\n  return this._element;\n};\n/**\n * Update placeholder's dimensions to match the item's dimensions. Note that\n * the updating is done asynchronously in the next tick to avoid layout\n * thrashing.\n *\n * @public\n */\n\n\nItemDragPlaceholder.prototype.updateDimensions = function () {\n  if (!this.isActive()) return;\n  addPlaceholderResizeTick(this._item._id, this._updateDimensions);\n};\n/**\n * Destroy placeholder instance.\n *\n * @public\n */\n\n\nItemDragPlaceholder.prototype.destroy = function () {\n  this.reset();\n\n  this._animation.destroy();\n\n  this._item = this._animation = null;\n};\n/**\n * The release process handler constructor. Although this might seem as proper\n * fit for the drag process this needs to be separated into it's own logic\n * because there might be a scenario where drag is disabled, but the release\n * process still needs to be implemented (dragging from a grid to another).\n *\n * @class\n * @param {Item} item\n */\n\n\nfunction ItemDragRelease(item) {\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the release process of an item.\n *\n * @public\n */\n\n\nItemDragRelease.prototype.start = function () {\n  if (this._isDestroyed || this._isActive) return;\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  this._isActive = true;\n  addClass(item._element, settings.itemReleasingClass);\n\n  if (!settings.dragRelease.useDragContainer) {\n    this._placeToGrid();\n  }\n\n  grid._emit(EVENT_DRAG_RELEASE_START, item); // Let's start layout manually _only_ if there is no unfinished layout in\n  // about to finish.\n\n\n  if (!grid._nextLayoutData) item._layout.start(false);\n};\n/**\n * End the release process of an item. This method can be used to abort an\n * ongoing release process (animation) or finish the release process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the release be aborted? When true, the release end event won't be\n *    emitted. Set to true only when you need to abort the release process\n *    while the item is animating to it's position.\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\n\n\nItemDragRelease.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n  var item = this._item;\n  var grid = item.getGrid();\n\n  if (!abort && (left === undefined || top === undefined)) {\n    left = item._left;\n    top = item._top;\n  }\n\n  var didReparent = this._placeToGrid(left, top);\n\n  this._reset(didReparent);\n\n  if (!abort) grid._emit(EVENT_DRAG_RELEASE_END, item);\n};\n\nItemDragRelease.prototype.isJustReleased = function () {\n  return this._isActive && this._isPositioningStarted === false;\n};\n/**\n * Destroy instance.\n *\n * @public\n */\n\n\nItemDragRelease.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Move the element back to the grid container element if it does not exist\n * there already.\n *\n * @private\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n * @returns {Boolean}\n *   - Returns `true` if the element was reparented.\n */\n\n\nItemDragRelease.prototype._placeToGrid = function (left, top) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n\n  var container = item.getGrid()._element;\n\n  var didReparent = false;\n\n  if (element.parentNode !== container) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(element);\n      left = translate.x - this._containerDiffX;\n      top = translate.y - this._containerDiffY;\n    }\n\n    container.appendChild(element);\n\n    item._setTranslate(left, top);\n\n    didReparent = true;\n  }\n\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n  return didReparent;\n};\n/**\n * Reset data and remove releasing class.\n *\n * @private\n * @param {Boolean} [needsReflow]\n */\n\n\nItemDragRelease.prototype._reset = function (needsReflow) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n\n  var releasingClass = item.getGrid()._settings.itemReleasingClass;\n\n  this._isActive = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0; // If the element was just reparented we need to do a forced reflow to remove\n  // the class gracefully.\n\n  if (releasingClass) {\n    // eslint-disable-next-line\n    if (needsReflow) item._element.clientWidth;\n    removeClass(item._element, releasingClass);\n  }\n};\n\nvar MIN_ANIMATION_DISTANCE = 2;\n/**\n * Layout manager for Item instance, handles the positioning of an item.\n *\n * @class\n * @param {Item} item\n */\n\nfunction ItemLayout(item) {\n  var element = item._element;\n  var elementStyle = element.style;\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isInterrupted = false;\n  this._currentStyles = {};\n  this._targetStyles = {};\n  this._nextLeft = 0;\n  this._nextTop = 0;\n  this._offsetLeft = 0;\n  this._offsetTop = 0;\n  this._skipNextAnimation = false;\n  this._animOptions = {\n    onFinish: this._finish.bind(this),\n    duration: 0,\n    easing: 0\n  }; // Set element's initial position styles.\n\n  elementStyle.left = '0px';\n  elementStyle.top = '0px';\n\n  item._setTranslate(0, 0);\n\n  this._animation = new Animator(element);\n  this._queue = 'layout-' + item._id; // Bind animation handlers and finish method.\n\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start item layout based on it's current data.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\n\n\nItemLayout.prototype.start = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var release = item._dragRelease;\n\n  var gridSettings = item.getGrid()._settings;\n\n  var isPositioning = this._isActive;\n  var isJustReleased = release.isJustReleased();\n  var animDuration = isJustReleased ? gridSettings.dragRelease.duration : gridSettings.layoutDuration;\n  var animEasing = isJustReleased ? gridSettings.dragRelease.easing : gridSettings.layoutEasing;\n  var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0; // If the item is currently positioning cancel potential queued layout tick\n  // and process current layout callback queue with interrupted flag on.\n\n  if (isPositioning) {\n    cancelLayoutTick(item._id);\n\n    item._emitter.burst(this._queue, true, item);\n  } // Mark release positioning as started.\n\n\n  if (isJustReleased) release._isPositioningStarted = true; // Push the callback to the callback queue.\n\n  if (isFunction(onFinish)) {\n    item._emitter.on(this._queue, onFinish);\n  } // Reset animation skipping flag.\n\n\n  this._skipNextAnimation = false; // If no animations are needed, easy peasy!\n\n  if (!animEnabled) {\n    this._updateOffsets();\n\n    item._setTranslate(this._nextLeft, this._nextTop);\n\n    this._animation.stop();\n\n    this._finish();\n\n    return;\n  } // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n\n\n  if (this._animation.isAnimating()) {\n    this._animation._animation.onfinish = null;\n  } // Kick off animation to be started in the next tick.\n\n\n  this._isActive = true;\n  this._animOptions.easing = animEasing;\n  this._animOptions.duration = animDuration;\n  this._isInterrupted = isPositioning;\n  addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n/**\n * Stop item's position animation if it is currently animating.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n * @param {Number} [left]\n * @param {Number} [top]\n */\n\n\nItemLayout.prototype.stop = function (processCallbackQueue, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n  var item = this._item; // Cancel animation init.\n\n  cancelLayoutTick(item._id); // Stop animation.\n\n  if (this._animation.isAnimating()) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(item._element);\n      left = translate.x;\n      top = translate.y;\n    }\n\n    item._setTranslate(left, top);\n\n    this._animation.stop();\n  } // Remove positioning class.\n\n\n  removeClass(item._element, item.getGrid()._settings.itemPositioningClass); // Reset active state.\n\n  this._isActive = false; // Process callback queue if needed.\n\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\n\n\nItemLayout.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var elementStyle = this._item._element.style;\n  this.stop(true, 0, 0);\n\n  this._item._emitter.clear(this._queue);\n\n  this._animation.destroy();\n\n  elementStyle[transformProp] = '';\n  elementStyle.left = '';\n  elementStyle.top = '';\n  this._item = null;\n  this._currentStyles = null;\n  this._targetStyles = null;\n  this._animOptions = null;\n  this._isDestroyed = true;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Calculate and update item's current layout offset data.\n *\n * @private\n */\n\n\nItemLayout.prototype._updateOffsets = function () {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n  this._offsetLeft = release._isActive ? release._containerDiffX : migrate._isActive ? migrate._containerDiffX : 0;\n  this._offsetTop = release._isActive ? release._containerDiffY : migrate._isActive ? migrate._containerDiffY : 0;\n  this._nextLeft = this._item._left + this._offsetLeft;\n  this._nextTop = this._item._top + this._offsetTop;\n};\n/**\n * Finish item layout procedure.\n *\n * @private\n */\n\n\nItemLayout.prototype._finish = function () {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease; // Update internal translate values.\n\n  item._tX = this._nextLeft;\n  item._tY = this._nextTop; // Mark the item as inactive and remove positioning classes.\n\n  if (this._isActive) {\n    this._isActive = false;\n    removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n  } // Finish up release and migration.\n\n\n  if (release._isActive) release.stop();\n  if (migrate._isActive) migrate.stop(); // Process the callback queue.\n\n  item._emitter.burst(this._queue, false, item);\n};\n/**\n * Prepare item for layout animation.\n *\n * @private\n */\n\n\nItemLayout.prototype._setupAnimation = function () {\n  var item = this._item;\n\n  if (item._tX === undefined || item._tY === undefined) {\n    var translate = getTranslate(item._element);\n    item._tX = translate.x;\n    item._tY = translate.y;\n  }\n};\n/**\n * Start layout animation.\n *\n * @private\n */\n\n\nItemLayout.prototype._startAnimation = function () {\n  var item = this._item;\n\n  var settings = item.getGrid()._settings;\n\n  var isInstant = this._animOptions.duration <= 0; // Let's update the offset data and target styles.\n\n  this._updateOffsets();\n\n  var xDiff = Math.abs(item._left - (item._tX - this._offsetLeft));\n  var yDiff = Math.abs(item._top - (item._tY - this._offsetTop)); // If there is no need for animation or if the item is already in correct\n  // position (or near it) let's finish the process early.\n\n  if (isInstant || xDiff < MIN_ANIMATION_DISTANCE && yDiff < MIN_ANIMATION_DISTANCE) {\n    if (xDiff || yDiff || this._isInterrupted) {\n      item._setTranslate(this._nextLeft, this._nextTop);\n    }\n\n    this._animation.stop();\n\n    this._finish();\n\n    return;\n  } // Set item's positioning class if needed.\n\n\n  if (!this._isInterrupted) {\n    addClass(item._element, settings.itemPositioningClass);\n  } // Get current/next styles for animation.\n\n\n  this._currentStyles[transformProp] = getTranslateString(item._tX, item._tY);\n  this._targetStyles[transformProp] = getTranslateString(this._nextLeft, this._nextTop); // Set internal translation values to undefined for the duration of the\n  // animation since they will be changing on each animation frame for the\n  // duration of the animation and tracking them would mean reading the DOM on\n  // each frame, which is pretty darn expensive.\n\n  item._tX = item._tY = undefined; // Start animation.\n\n  this._animation.start(this._currentStyles, this._targetStyles, this._animOptions);\n};\n/**\n * The migrate process handler constructor.\n *\n * @class\n * @param {Item} item\n */\n\n\nfunction ItemMigrate(item) {\n  // Private props.\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._container = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the migrate process of an item.\n *\n * @public\n * @param {Grid} targetGrid\n * @param {(HTMLElement|Number|Item)} position\n * @param {HTMLElement} [container]\n */\n\n\nItemMigrate.prototype.start = function (targetGrid, position, container) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var isActive = item.isActive();\n  var isVisible = item.isVisible();\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var targetSettings = targetGrid._settings;\n  var targetElement = targetGrid._element;\n  var targetItems = targetGrid._items;\n\n  var currentIndex = grid._items.indexOf(item);\n\n  var targetContainer = container || document.body;\n  var targetIndex;\n  var targetItem;\n  var currentContainer;\n  var offsetDiff;\n  var containerDiff;\n  var translate;\n  var translateX;\n  var translateY;\n  var currentVisClass;\n  var nextVisClass; // Get target index.\n\n  if (typeof position === 'number') {\n    targetIndex = normalizeArrayIndex(targetItems, position, 1);\n  } else {\n    targetItem = targetGrid.getItem(position);\n    if (!targetItem) return;\n    targetIndex = targetItems.indexOf(targetItem);\n  } // Get current translateX and translateY values if needed.\n\n\n  if (item.isPositioning() || this._isActive || item.isReleasing()) {\n    translate = getTranslate(element);\n    translateX = translate.x;\n    translateY = translate.y;\n  } // Abort current positioning.\n\n\n  if (item.isPositioning()) {\n    item._layout.stop(true, translateX, translateY);\n  } // Abort current migration.\n\n\n  if (this._isActive) {\n    translateX -= this._containerDiffX;\n    translateY -= this._containerDiffY;\n    this.stop(true, translateX, translateY);\n  } // Abort current release.\n\n\n  if (item.isReleasing()) {\n    translateX -= item._dragRelease._containerDiffX;\n    translateY -= item._dragRelease._containerDiffY;\n\n    item._dragRelease.stop(true, translateX, translateY);\n  } // Stop current visibility animation.\n\n\n  item._visibility.stop(true); // Destroy current drag.\n\n\n  if (item._drag) item._drag.destroy(); // Emit beforeSend event.\n\n  if (grid._hasListeners(EVENT_BEFORE_SEND)) {\n    grid._emit(EVENT_BEFORE_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  } // Emit beforeReceive event.\n\n\n  if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n    targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  } // Update item class.\n\n\n  if (settings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, settings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  } // Update visibility class.\n\n\n  currentVisClass = isVisible ? settings.itemVisibleClass : settings.itemHiddenClass;\n  nextVisClass = isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  } // Move item instance from current grid to target grid.\n\n\n  grid._items.splice(currentIndex, 1);\n\n  arrayInsert(targetItems, item, targetIndex); // Update item's grid id reference.\n\n  item._gridId = targetGrid._id; // If item is active we need to move the item inside the target container for\n  // the duration of the (potential) animation if it's different than the\n  // current container.\n\n  if (isActive) {\n    currentContainer = element.parentNode;\n\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n\n      if (!translate) {\n        translate = getTranslate(element);\n        translateX = translate.x;\n        translateY = translate.y;\n      }\n\n      item._setTranslate(translateX + offsetDiff.left, translateY + offsetDiff.top);\n    }\n  } // If item is not active let's just append it to the target grid's element.\n  else {\n    targetElement.appendChild(element);\n  } // Update child element's styles to reflect the current visibility state.\n\n\n  item._visibility.setStyles(isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles); // Get offset diff for the migration data, if the item is active.\n\n\n  if (isActive) {\n    containerDiff = getOffsetDiff(targetContainer, targetElement, true);\n  } // Update item's cached dimensions.\n\n\n  item._refreshDimensions(); // Reset item's sort data.\n\n\n  item._sortData = null; // Create new drag handler.\n\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null; // Setup migration data.\n\n  if (isActive) {\n    this._isActive = true;\n    this._container = targetContainer;\n    this._containerDiffX = containerDiff.left;\n    this._containerDiffY = containerDiff.top;\n  } else {\n    this._isActive = false;\n    this._container = null;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  } // Emit send event.\n\n\n  if (grid._hasListeners(EVENT_SEND)) {\n    grid._emit(EVENT_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  } // Emit receive event.\n\n\n  if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n    targetGrid._emit(EVENT_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex\n    });\n  }\n};\n/**\n * End the migrate process of an item. This method can be used to abort an\n * ongoing migrate process (animation) or finish the migrate process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the migration be aborted?\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\n\n\nItemMigrate.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var gridElement = grid._element;\n  var translate;\n\n  if (this._container !== gridElement) {\n    if (left === undefined || top === undefined) {\n      if (abort) {\n        translate = getTranslate(element);\n        left = translate.x - this._containerDiffX;\n        top = translate.y - this._containerDiffY;\n      } else {\n        left = item._left;\n        top = item._top;\n      }\n    }\n\n    gridElement.appendChild(element);\n\n    item._setTranslate(left, top);\n  }\n\n  this._isActive = false;\n  this._container = null;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n/**\n * Destroy instance.\n *\n * @public\n */\n\n\nItemMigrate.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n/**\n * Visibility manager for Item instance, handles visibility of an item.\n *\n * @class\n * @param {Item} item\n */\n\n\nfunction ItemVisibility(item) {\n  var isActive = item._isActive;\n  var element = item._element;\n  var childElement = element.children[0];\n\n  var settings = item.getGrid()._settings;\n\n  if (!childElement) {\n    throw new Error('No valid child element found within item element.');\n  }\n\n  this._item = item;\n  this._isDestroyed = false;\n  this._isHidden = !isActive;\n  this._isHiding = false;\n  this._isShowing = false;\n  this._childElement = childElement;\n  this._currentStyleProps = [];\n  this._animation = new Animator(childElement);\n  this._queue = 'visibility-' + item._id;\n  this._finishShow = this._finishShow.bind(this);\n  this._finishHide = this._finishHide.bind(this);\n  element.style.display = isActive ? '' : 'none';\n  addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass);\n  this.setStyles(isActive ? settings.visibleStyles : settings.hiddenStyles);\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Show item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\n\n\nItemVisibility.prototype.show = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings; // If item is visible call the callback and be done with it.\n\n  if (!this._isShowing && !this._isHidden) {\n    callback && callback(false, item);\n    return;\n  } // If item is showing and does not need to be shown instantly, let's just\n  // push callback to the callback queue and be done with it.\n\n\n  if (this._isShowing && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  } // If the item is hiding or hidden process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n\n\n  if (!this._isShowing) {\n    item._emitter.burst(this._queue, true, item);\n\n    removeClass(element, settings.itemHiddenClass);\n    addClass(element, settings.itemVisibleClass);\n    if (!this._isHiding) element.style.display = '';\n  } // Push callback to the callback queue.\n\n\n  callback && item._emitter.on(this._queue, callback); // Update visibility states.\n\n  this._isShowing = true;\n  this._isHiding = this._isHidden = false; // Finally let's start show animation.\n\n  this._startAnimation(true, instant, this._finishShow);\n};\n/**\n * Hide item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\n\n\nItemVisibility.prototype.hide = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings; // If item is already hidden call the callback and be done with it.\n\n  if (!this._isHiding && this._isHidden) {\n    callback && callback(false, item);\n    return;\n  } // If item is hiding and does not need to be hidden instantly, let's just\n  // push callback to the callback queue and be done with it.\n\n\n  if (this._isHiding && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  } // If the item is showing or visible process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n\n\n  if (!this._isHiding) {\n    item._emitter.burst(this._queue, true, item);\n\n    addClass(element, settings.itemHiddenClass);\n    removeClass(element, settings.itemVisibleClass);\n  } // Push callback to the callback queue.\n\n\n  callback && item._emitter.on(this._queue, callback); // Update visibility states.\n\n  this._isHidden = this._isHiding = true;\n  this._isShowing = false; // Finally let's start hide animation.\n\n  this._startAnimation(false, instant, this._finishHide);\n};\n/**\n * Stop current hiding/showing process.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n */\n\n\nItemVisibility.prototype.stop = function (processCallbackQueue) {\n  if (this._isDestroyed) return;\n  if (!this._isHiding && !this._isShowing) return;\n  var item = this._item;\n  cancelVisibilityTick(item._id);\n\n  this._animation.stop();\n\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n/**\n * Reset all existing visibility styles and apply new visibility styles to the\n * visibility element. This method should be used to set styles when there is a\n * chance that the current style properties differ from the new ones (basically\n * on init and on migrations).\n *\n * @public\n * @param {Object} styles\n */\n\n\nItemVisibility.prototype.setStyles = function (styles) {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n\n  this._removeCurrentStyles();\n\n  for (var prop in styles) {\n    currentStyleProps.push(prop);\n    childElement.style[prop] = styles[prop];\n  }\n};\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\n\n\nItemVisibility.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  this.stop(true);\n\n  item._emitter.clear(this._queue);\n\n  this._animation.destroy();\n\n  this._removeCurrentStyles();\n\n  removeClass(element, settings.itemVisibleClass);\n  removeClass(element, settings.itemHiddenClass);\n  element.style.display = ''; // Reset state.\n\n  this._isHiding = this._isShowing = false;\n  this._isDestroyed = this._isHidden = true;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Start visibility animation.\n *\n * @private\n * @param {Boolean} toVisible\n * @param {Boolean} [instant]\n * @param {Function} [onFinish]\n */\n\n\nItemVisibility.prototype._startAnimation = function (toVisible, instant, onFinish) {\n  if (this._isDestroyed) return;\n  var item = this._item;\n  var animation = this._animation;\n  var childElement = this._childElement;\n\n  var settings = item.getGrid()._settings;\n\n  var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\n  var duration = toVisible ? settings.showDuration : settings.hideDuration;\n  var easing = toVisible ? settings.showEasing : settings.hideEasing;\n  var isInstant = instant || duration <= 0;\n  var currentStyles; // No target styles? Let's quit early.\n\n  if (!targetStyles) {\n    onFinish && onFinish();\n    return;\n  } // Cancel queued visibility tick.\n\n\n  cancelVisibilityTick(item._id); // If we need to apply the styles instantly without animation.\n\n  if (isInstant) {\n    setStyles(childElement, targetStyles);\n    animation.stop();\n    onFinish && onFinish();\n    return;\n  } // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n\n\n  if (animation.isAnimating()) {\n    animation._animation.onfinish = null;\n  } // Start the animation in the next tick (to avoid layout thrashing).\n\n\n  addVisibilityTick(item._id, function () {\n    currentStyles = getCurrentStyles(childElement, targetStyles);\n  }, function () {\n    animation.start(currentStyles, targetStyles, {\n      duration: duration,\n      easing: easing,\n      onFinish: onFinish\n    });\n  });\n};\n/**\n * Finish show procedure.\n *\n * @private\n */\n\n\nItemVisibility.prototype._finishShow = function () {\n  if (this._isHidden) return;\n  this._isShowing = false;\n\n  this._item._emitter.burst(this._queue, false, this._item);\n};\n/**\n * Finish hide procedure.\n *\n * @private\n */\n\n\nItemVisibility.prototype._finishHide = function () {\n  if (!this._isHidden) return;\n  var item = this._item;\n  this._isHiding = false;\n\n  item._layout.stop(true, 0, 0);\n\n  item._element.style.display = 'none';\n\n  item._emitter.burst(this._queue, false, item);\n};\n/**\n * Remove currently applied visibility related inline style properties.\n *\n * @private\n */\n\n\nItemVisibility.prototype._removeCurrentStyles = function () {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n\n  for (var i = 0; i < currentStyleProps.length; i++) {\n    childElement.style[currentStyleProps[i]] = '';\n  }\n\n  currentStyleProps.length = 0;\n};\n\nvar id = 0;\n/**\n * Returns a unique numeric id (increments a base value on every call).\n * @returns {Number}\n */\n\nfunction createUid() {\n  return ++id;\n}\n/**\n * Creates a new Item instance for a Grid instance.\n *\n * @class\n * @param {Grid} grid\n * @param {HTMLElement} element\n * @param {Boolean} [isActive]\n */\n\n\nfunction Item(grid, element, isActive) {\n  var settings = grid._settings; // Store item/element pair to a map (for faster item querying by element).\n\n  if (ITEM_ELEMENT_MAP) {\n    if (ITEM_ELEMENT_MAP.has(element)) {\n      throw new Error('You can only create one Muuri Item per element!');\n    } else {\n      ITEM_ELEMENT_MAP.set(element, this);\n    }\n  }\n\n  this._id = createUid();\n  this._gridId = grid._id;\n  this._element = element;\n  this._isDestroyed = false;\n  this._left = 0;\n  this._top = 0;\n  this._width = 0;\n  this._height = 0;\n  this._marginLeft = 0;\n  this._marginRight = 0;\n  this._marginTop = 0;\n  this._marginBottom = 0;\n  this._tX = undefined;\n  this._tY = undefined;\n  this._sortData = null;\n  this._emitter = new Emitter(); // If the provided item element is not a direct child of the grid container\n  // element, append it to the grid container. Note, we are indeed reading the\n  // DOM here but it's a property that does not cause reflowing.\n\n  if (element.parentNode !== grid._element) {\n    grid._element.appendChild(element);\n  } // Set item class.\n\n\n  addClass(element, settings.itemClass); // If isActive is not defined, let's try to auto-detect it. Note, we are\n  // indeed reading the DOM here but it's a property that does not cause\n  // reflowing.\n\n  if (typeof isActive !== 'boolean') {\n    isActive = getStyle(element, 'display') !== 'none';\n  } // Set up active state (defines if the item is considered part of the layout\n  // or not).\n\n\n  this._isActive = isActive; // Setup visibility handler.\n\n  this._visibility = new ItemVisibility(this); // Set up layout handler.\n\n  this._layout = new ItemLayout(this); // Set up migration handler data.\n\n  this._migrate = new ItemMigrate(this); // Set up drag handler.\n\n  this._drag = settings.dragEnabled ? new ItemDrag(this) : null; // Set up release handler. Note that although this is fully linked to dragging\n  // this still needs to be always instantiated to handle migration scenarios\n  // correctly.\n\n  this._dragRelease = new ItemDragRelease(this); // Set up drag placeholder handler. Note that although this is fully linked to\n  // dragging this still needs to be always instantiated to handle migration\n  // scenarios correctly.\n\n  this._dragPlaceholder = new ItemDragPlaceholder(this); // Note! You must call the following methods before you start using the\n  // instance. They are deliberately not called in the end as it would cause\n  // potentially a massive amount of reflows if multiple items were instantiated\n  // in a loop.\n  // this._refreshDimensions();\n  // this._refreshSortData();\n}\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Get the instance grid reference.\n *\n * @public\n * @returns {Grid}\n */\n\n\nItem.prototype.getGrid = function () {\n  return GRID_INSTANCES[this._gridId];\n};\n/**\n * Get the instance element.\n *\n * @public\n * @returns {HTMLElement}\n */\n\n\nItem.prototype.getElement = function () {\n  return this._element;\n};\n/**\n * Get instance element's cached width.\n *\n * @public\n * @returns {Number}\n */\n\n\nItem.prototype.getWidth = function () {\n  return this._width;\n};\n/**\n * Get instance element's cached height.\n *\n * @public\n * @returns {Number}\n */\n\n\nItem.prototype.getHeight = function () {\n  return this._height;\n};\n/**\n * Get instance element's cached margins.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left, right, top and bottom properties\n *     which indicate the item element's cached margins.\n */\n\n\nItem.prototype.getMargin = function () {\n  return {\n    left: this._marginLeft,\n    right: this._marginRight,\n    top: this._marginTop,\n    bottom: this._marginBottom\n  };\n};\n/**\n * Get instance element's cached position.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left and top properties which indicate the\n *     item element's cached position in the grid.\n */\n\n\nItem.prototype.getPosition = function () {\n  return {\n    left: this._left,\n    top: this._top\n  };\n};\n/**\n * Is the item active?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isActive = function () {\n  return this._isActive;\n};\n/**\n * Is the item visible?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isVisible = function () {\n  return !!this._visibility && !this._visibility._isHidden;\n};\n/**\n * Is the item being animated to visible?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isShowing = function () {\n  return !!(this._visibility && this._visibility._isShowing);\n};\n/**\n * Is the item being animated to hidden?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isHiding = function () {\n  return !!(this._visibility && this._visibility._isHiding);\n};\n/**\n * Is the item positioning?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isPositioning = function () {\n  return !!(this._layout && this._layout._isActive);\n};\n/**\n * Is the item being dragged (or queued for dragging)?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isDragging = function () {\n  return !!(this._drag && this._drag._isActive);\n};\n/**\n * Is the item being released?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isReleasing = function () {\n  return !!(this._dragRelease && this._dragRelease._isActive);\n};\n/**\n * Is the item destroyed?\n *\n * @public\n * @returns {Boolean}\n */\n\n\nItem.prototype.isDestroyed = function () {\n  return this._isDestroyed;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Recalculate item's dimensions.\n *\n * @private\n * @param {Boolean} [force=false]\n */\n\n\nItem.prototype._refreshDimensions = function (force) {\n  if (this._isDestroyed) return;\n  if (force !== true && this._visibility._isHidden) return;\n  var element = this._element;\n  var dragPlaceholder = this._dragPlaceholder;\n  var rect = element.getBoundingClientRect(); // Calculate width and height.\n\n  this._width = rect.width;\n  this._height = rect.height; // Calculate margins (ignore negative margins).\n\n  this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\n  this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\n  this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\n  this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom')); // Keep drag placeholder's dimensions synced with the item's.\n\n  if (dragPlaceholder) dragPlaceholder.updateDimensions();\n};\n/**\n * Fetch and store item's sort data.\n *\n * @private\n */\n\n\nItem.prototype._refreshSortData = function () {\n  if (this._isDestroyed) return;\n  var data = this._sortData = {};\n\n  var getters = this.getGrid()._settings.sortData;\n\n  var prop;\n\n  for (prop in getters) {\n    data[prop] = getters[prop](this, this._element);\n  }\n};\n/**\n * Add item to layout.\n *\n * @private\n */\n\n\nItem.prototype._addToLayout = function (left, top) {\n  if (this._isActive === true) return;\n  this._isActive = true;\n  this._left = left || 0;\n  this._top = top || 0;\n};\n/**\n * Remove item from layout.\n *\n * @private\n */\n\n\nItem.prototype._removeFromLayout = function () {\n  if (this._isActive === false) return;\n  this._isActive = false;\n  this._left = 0;\n  this._top = 0;\n};\n/**\n * Check if the layout procedure can be skipped for the item.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\n\n\nItem.prototype._canSkipLayout = function (left, top) {\n  return this._left === left && this._top === top && !this._migrate._isActive && !this._layout._skipNextAnimation && !this._dragRelease.isJustReleased();\n};\n/**\n * Set the provided left and top arguments as the item element's translate\n * values in the DOM. This method keeps track of the currently applied\n * translate values and skips the update operation if the provided values are\n * identical to the currently applied values. Returns `false` if there was no\n * need for update and `true` if the translate value was updated.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\n\n\nItem.prototype._setTranslate = function (left, top) {\n  if (this._tX === left && this._tY === top) return false;\n  this._tX = left;\n  this._tY = top;\n  this._element.style[transformProp] = getTranslateString(left, top);\n  return true;\n};\n/**\n * Destroy item instance.\n *\n * @private\n * @param {Boolean} [removeElement=false]\n */\n\n\nItem.prototype._destroy = function (removeElement) {\n  if (this._isDestroyed) return;\n  var element = this._element;\n  var grid = this.getGrid();\n  var settings = grid._settings; // Destroy handlers.\n\n  this._dragPlaceholder.destroy();\n\n  this._dragRelease.destroy();\n\n  this._migrate.destroy();\n\n  this._layout.destroy();\n\n  this._visibility.destroy();\n\n  if (this._drag) this._drag.destroy(); // Destroy emitter.\n\n  this._emitter.destroy(); // Remove item class.\n\n\n  removeClass(element, settings.itemClass); // Remove element from DOM.\n\n  if (removeElement) element.parentNode.removeChild(element); // Remove item/element pair from map.\n\n  if (ITEM_ELEMENT_MAP) ITEM_ELEMENT_MAP.delete(element); // Reset state.\n\n  this._isActive = false;\n  this._isDestroyed = true;\n};\n\nfunction createPackerProcessor(isWorker) {\n  var FILL_GAPS = 1;\n  var HORIZONTAL = 2;\n  var ALIGN_RIGHT = 4;\n  var ALIGN_BOTTOM = 8;\n  var ROUNDING = 16;\n  var EPS = 0.001;\n  var MIN_SLOT_SIZE = 0.5; // Rounds number first to three decimal precision and then floors the result\n  // to two decimal precision.\n  // Math.floor(Math.round(number * 1000) / 10) / 100\n\n  function roundNumber(number) {\n    return ((number * 1000 + 0.5 << 0) / 10 << 0) / 100;\n  }\n  /**\n   * @class\n   */\n\n\n  function PackerProcessor() {\n    this.currentRects = [];\n    this.nextRects = [];\n    this.rectTarget = {};\n    this.rectStore = [];\n    this.slotSizes = [];\n    this.rectId = 0;\n    this.slotIndex = -1;\n    this.slotData = {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n    this.sortRectsLeftTop = this.sortRectsLeftTop.bind(this);\n    this.sortRectsTopLeft = this.sortRectsTopLeft.bind(this);\n  }\n  /**\n   * Takes a layout object as an argument and computes positions (slots) for the\n   * layout items. Also computes the final width and height of the layout. The\n   * provided layout object's slots array is mutated as well as the width and\n   * height properties.\n   *\n   * @param {Object} layout\n   * @param {Number} layout.width\n   *   - The start (current) width of the layout in pixels.\n   * @param {Number} layout.height\n   *   - The start (current) height of the layout in pixels.\n   * @param {(Item[]|Number[])} layout.items\n   *   - List of Muuri.Item instances or a list of item dimensions\n   *     (e.g [ item1Width, item1Height, item2Width, item2Height, ... ]).\n   * @param {(Array|Float32Array)} layout.slots\n   *   - An Array/Float32Array instance which's length should equal to\n   *     the amount of items times two. The position (width and height) of each\n   *     item will be written into this array.\n   * @param {Number} settings\n   *   - The layout's settings as bitmasks.\n   * @returns {Object}\n   */\n\n\n  PackerProcessor.prototype.computeLayout = function (layout, settings) {\n    var items = layout.items;\n    var slots = layout.slots;\n    var fillGaps = !!(settings & FILL_GAPS);\n    var horizontal = !!(settings & HORIZONTAL);\n    var alignRight = !!(settings & ALIGN_RIGHT);\n    var alignBottom = !!(settings & ALIGN_BOTTOM);\n    var rounding = !!(settings & ROUNDING);\n    var isPreProcessed = typeof items[0] === 'number';\n    var i, bump, item, slotWidth, slotHeight, slot; // No need to go further if items do not exist.\n\n    if (!items.length) return layout; // Compute slots for the items.\n\n    bump = isPreProcessed ? 2 : 1;\n\n    for (i = 0; i < items.length; i += bump) {\n      // If items are pre-processed it means that items array contains only\n      // the raw dimensions of the items. Otherwise we assume it is an array\n      // of normal Muuri items.\n      if (isPreProcessed) {\n        slotWidth = items[i];\n        slotHeight = items[i + 1];\n      } else {\n        item = items[i];\n        slotWidth = item._width + item._marginLeft + item._marginRight;\n        slotHeight = item._height + item._marginTop + item._marginBottom;\n      } // If rounding is enabled let's round the item's width and height to\n      // make the layout algorithm a bit more stable. This has a performance\n      // cost so don't use this if not necessary.\n\n\n      if (rounding) {\n        slotWidth = roundNumber(slotWidth);\n        slotHeight = roundNumber(slotHeight);\n      } // Get slot data.\n\n\n      slot = this.computeNextSlot(layout, slotWidth, slotHeight, fillGaps, horizontal); // Update layout width/height.\n\n      if (horizontal) {\n        if (slot.left + slot.width > layout.width) {\n          layout.width = slot.left + slot.width;\n        }\n      } else {\n        if (slot.top + slot.height > layout.height) {\n          layout.height = slot.top + slot.height;\n        }\n      } // Add item slot data to layout slots.\n\n\n      slots[++this.slotIndex] = slot.left;\n      slots[++this.slotIndex] = slot.top; // Store the size too (for later usage) if needed.\n\n      if (alignRight || alignBottom) {\n        this.slotSizes.push(slot.width, slot.height);\n      }\n    } // If the alignment is set to right we need to adjust the results.\n\n\n    if (alignRight) {\n      for (i = 0; i < slots.length; i += 2) {\n        slots[i] = layout.width - (slots[i] + this.slotSizes[i]);\n      }\n    } // If the alignment is set to bottom we need to adjust the results.\n\n\n    if (alignBottom) {\n      for (i = 1; i < slots.length; i += 2) {\n        slots[i] = layout.height - (slots[i] + this.slotSizes[i]);\n      }\n    } // Reset stuff.\n\n\n    this.slotSizes.length = 0;\n    this.currentRects.length = 0;\n    this.nextRects.length = 0;\n    this.rectStore.length = 0;\n    this.rectId = 0;\n    this.slotIndex = -1;\n    return layout;\n  };\n  /**\n   * Calculate next slot in the layout. Returns a slot object with position and\n   * dimensions data. The returned object is reused between calls.\n   *\n   * @param {Object} layout\n   * @param {Number} slotWidth\n   * @param {Number} slotHeight\n   * @param {Boolean} fillGaps\n   * @param {Boolean} horizontal\n   * @returns {Object}\n   */\n\n\n  PackerProcessor.prototype.computeNextSlot = function (layout, slotWidth, slotHeight, fillGaps, horizontal) {\n    var slot = this.slotData;\n    var currentRects = this.currentRects;\n    var nextRects = this.nextRects;\n    var ignoreCurrentRects = false;\n    var rect;\n    var rectId;\n    var shards;\n    var i;\n    var j; // Reset new slots.\n\n    nextRects.length = 0; // Set item slot initial data.\n\n    slot.left = null;\n    slot.top = null;\n    slot.width = slotWidth;\n    slot.height = slotHeight; // Try to find position for the slot from the existing free spaces in the\n    // layout.\n\n    for (i = 0; i < currentRects.length; i++) {\n      rectId = currentRects[i];\n      if (!rectId) continue;\n      rect = this.getRect(rectId);\n\n      if (slot.width <= rect.width + EPS && slot.height <= rect.height + EPS) {\n        slot.left = rect.left;\n        slot.top = rect.top;\n        break;\n      }\n    } // If no position was found for the slot let's position the slot to\n    // the bottom left (in vertical mode) or top right (in horizontal mode) of\n    // the layout.\n\n\n    if (slot.left === null) {\n      if (horizontal) {\n        slot.left = layout.width;\n        slot.top = 0;\n      } else {\n        slot.left = 0;\n        slot.top = layout.height;\n      } // If gaps don't need filling let's throw away all the current free spaces\n      // (currentRects).\n\n\n      if (!fillGaps) {\n        ignoreCurrentRects = true;\n      }\n    } // In vertical mode, if the slot's bottom overlaps the layout's bottom.\n\n\n    if (!horizontal && slot.top + slot.height > layout.height + EPS) {\n      // If slot is not aligned to the left edge, create a new free space to the\n      // left of the slot.\n      if (slot.left > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(0, layout.height, slot.left, Infinity));\n      } // If slot is not aligned to the right edge, create a new free space to\n      // the right of the slot.\n\n\n      if (slot.left + slot.width < layout.width - MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(slot.left + slot.width, layout.height, layout.width - slot.left - slot.width, Infinity));\n      } // Update layout height.\n\n\n      layout.height = slot.top + slot.height;\n    } // In horizontal mode, if the slot's right overlaps the layout's right edge.\n\n\n    if (horizontal && slot.left + slot.width > layout.width + EPS) {\n      // If slot is not aligned to the top, create a new free space above the\n      // slot.\n      if (slot.top > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(layout.width, 0, Infinity, slot.top));\n      } // If slot is not aligned to the bottom, create a new free space below\n      // the slot.\n\n\n      if (slot.top + slot.height < layout.height - MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(layout.width, slot.top + slot.height, Infinity, layout.height - slot.top - slot.height));\n      } // Update layout width.\n\n\n      layout.width = slot.left + slot.width;\n    } // Clean up the current free spaces making sure none of them overlap with\n    // the slot. Split all overlapping free spaces into smaller shards that do\n    // not overlap with the slot.\n\n\n    if (!ignoreCurrentRects) {\n      if (fillGaps) i = 0;\n\n      for (; i < currentRects.length; i++) {\n        rectId = currentRects[i];\n        if (!rectId) continue;\n        rect = this.getRect(rectId);\n        shards = this.splitRect(rect, slot);\n\n        for (j = 0; j < shards.length; j++) {\n          rectId = shards[j];\n          rect = this.getRect(rectId); // Make sure that the free space is within the boundaries of the\n          // layout. This routine is critical to the algorithm as it makes sure\n          // that there are no leftover spaces with infinite height/width.\n          // It's also essential that we don't compare values absolutely to each\n          // other but leave a little headroom (EPSILON) to get rid of false\n          // positives.\n\n          if (horizontal ? rect.left + EPS < layout.width - EPS : rect.top + EPS < layout.height - EPS) {\n            nextRects.push(rectId);\n          }\n        }\n      }\n    } // Sanitize and sort all the new free spaces that will be used in the next\n    // iteration. This procedure is critical to make the bin-packing algorithm\n    // work. The free spaces have to be in correct order in the beginning of the\n    // next iteration.\n\n\n    if (nextRects.length > 1) {\n      this.purgeRects(nextRects).sort(horizontal ? this.sortRectsLeftTop : this.sortRectsTopLeft);\n    } // Finally we need to make sure that `this.currentRects` points to\n    // `nextRects` array as that is used in the next iteration's beginning when\n    // we try to find a space for the next slot.\n\n\n    this.currentRects = nextRects;\n    this.nextRects = currentRects;\n    return slot;\n  };\n  /**\n   * Add a new rectangle to the rectangle store. Returns the id of the new\n   * rectangle.\n   *\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} width\n   * @param {Number} height\n   * @returns {Number}\n   */\n\n\n  PackerProcessor.prototype.addRect = function (left, top, width, height) {\n    var rectId = ++this.rectId;\n    this.rectStore[rectId] = left || 0;\n    this.rectStore[++this.rectId] = top || 0;\n    this.rectStore[++this.rectId] = width || 0;\n    this.rectStore[++this.rectId] = height || 0;\n    return rectId;\n  };\n  /**\n   * Get rectangle data from the rectangle store by id. Optionally you can\n   * provide a target object where the rectangle data will be written in. By\n   * default an internal object is reused as a target object.\n   *\n   * @param {Number} id\n   * @param {Object} [target]\n   * @returns {Object}\n   */\n\n\n  PackerProcessor.prototype.getRect = function (id, target) {\n    if (!target) target = this.rectTarget;\n    target.left = this.rectStore[id] || 0;\n    target.top = this.rectStore[++id] || 0;\n    target.width = this.rectStore[++id] || 0;\n    target.height = this.rectStore[++id] || 0;\n    return target;\n  };\n  /**\n   * Punch a hole into a rectangle and return the shards (1-4).\n   *\n   * @param {Object} rect\n   * @param {Object} hole\n   * @returns {Number[]}\n   */\n\n\n  PackerProcessor.prototype.splitRect = function () {\n    var shards = [];\n    var width = 0;\n    var height = 0;\n    return function (rect, hole) {\n      // Reset old shards.\n      shards.length = 0; // If the slot does not overlap with the hole add slot to the return data\n      // as is. Note that in this case we are eager to keep the slot as is if\n      // possible so we use the EPSILON in favour of that logic.\n\n      if (rect.left + rect.width <= hole.left + EPS || hole.left + hole.width <= rect.left + EPS || rect.top + rect.height <= hole.top + EPS || hole.top + hole.height <= rect.top + EPS) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, rect.height));\n        return shards;\n      } // Left split.\n\n\n      width = hole.left - rect.left;\n\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, width, rect.height));\n      } // Right split.\n\n\n      width = rect.left + rect.width - (hole.left + hole.width);\n\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(hole.left + hole.width, rect.top, width, rect.height));\n      } // Top split.\n\n\n      height = hole.top - rect.top;\n\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, height));\n      } // Bottom split.\n\n\n      height = rect.top + rect.height - (hole.top + hole.height);\n\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, hole.top + hole.height, rect.width, height));\n      }\n\n      return shards;\n    };\n  }();\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @param {Object} a\n   * @param {Object} b\n   * @returns {Boolean}\n   */\n\n\n  PackerProcessor.prototype.isRectAWithinRectB = function (a, b) {\n    return a.left + EPS >= b.left && a.top + EPS >= b.top && a.left + a.width - EPS <= b.left + b.width && a.top + a.height - EPS <= b.top + b.height;\n  };\n  /**\n   * Loops through an array of rectangle ids and resets all that are fully\n   * within another rectangle in the array. Resetting in this case means that\n   * the rectangle id value is replaced with zero.\n   *\n   * @param {Number[]} rectIds\n   * @returns {Number[]}\n   */\n\n\n  PackerProcessor.prototype.purgeRects = function () {\n    var rectA = {};\n    var rectB = {};\n    return function (rectIds) {\n      var i = rectIds.length;\n      var j;\n\n      while (i--) {\n        j = rectIds.length;\n        if (!rectIds[i]) continue;\n        this.getRect(rectIds[i], rectA);\n\n        while (j--) {\n          if (!rectIds[j] || i === j) continue;\n          this.getRect(rectIds[j], rectB);\n\n          if (this.isRectAWithinRectB(rectA, rectB)) {\n            rectIds[i] = 0;\n            break;\n          }\n        }\n      }\n\n      return rectIds;\n    };\n  }();\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n\n\n  PackerProcessor.prototype.sortRectsTopLeft = function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n      return rectA.top < rectB.top && rectA.top + EPS < rectB.top ? -1 : rectA.top > rectB.top && rectA.top - EPS > rectB.top ? 1 : rectA.left < rectB.left && rectA.left + EPS < rectB.left ? -1 : rectA.left > rectB.left && rectA.left - EPS > rectB.left ? 1 : 0;\n    };\n  }();\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n\n\n  PackerProcessor.prototype.sortRectsLeftTop = function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n      return rectA.left < rectB.left && rectA.left + EPS < rectB.left ? -1 : rectA.left > rectB.left && rectA.left - EPS < rectB.left ? 1 : rectA.top < rectB.top && rectA.top + EPS < rectB.top ? -1 : rectA.top > rectB.top && rectA.top - EPS > rectB.top ? 1 : 0;\n    };\n  }();\n\n  if (isWorker) {\n    var PACKET_INDEX_WIDTH = 1;\n    var PACKET_INDEX_HEIGHT = 2;\n    var PACKET_INDEX_OPTIONS = 3;\n    var PACKET_HEADER_SLOTS = 4;\n    var processor = new PackerProcessor();\n\n    self.onmessage = function (msg) {\n      var data = new Float32Array(msg.data);\n      var items = data.subarray(PACKET_HEADER_SLOTS, data.length);\n      var slots = new Float32Array(items.length);\n      var settings = data[PACKET_INDEX_OPTIONS];\n      var layout = {\n        items: items,\n        slots: slots,\n        width: data[PACKET_INDEX_WIDTH],\n        height: data[PACKET_INDEX_HEIGHT]\n      }; // Compute the layout (width / height / slots).\n\n      processor.computeLayout(layout, settings); // Copy layout data to the return data.\n\n      data[PACKET_INDEX_WIDTH] = layout.width;\n      data[PACKET_INDEX_HEIGHT] = layout.height;\n      data.set(layout.slots, PACKET_HEADER_SLOTS); // Send layout back to the main thread.\n\n      postMessage(data.buffer, [data.buffer]);\n    };\n  }\n\n  return PackerProcessor;\n}\n\nvar PackerProcessor = createPackerProcessor(); //\n// WORKER UTILS\n//\n\nvar blobUrl = null;\nvar activeWorkers = [];\n\nfunction createWorkerProcessors(amount, onmessage) {\n  var workers = [];\n\n  if (amount > 0) {\n    if (!blobUrl) {\n      blobUrl = URL.createObjectURL(new Blob(['(' + createPackerProcessor.toString() + ')(true)'], {\n        type: 'application/javascript'\n      }));\n    }\n\n    for (var i = 0, worker; i < amount; i++) {\n      worker = new Worker(blobUrl);\n      if (onmessage) worker.onmessage = onmessage;\n      workers.push(worker);\n      activeWorkers.push(worker);\n    }\n  }\n\n  return workers;\n}\n\nfunction destroyWorkerProcessors(workers) {\n  var worker;\n  var index;\n\n  for (var i = 0; i < workers.length; i++) {\n    worker = workers[i];\n    worker.onmessage = null;\n    worker.onerror = null;\n    worker.onmessageerror = null;\n    worker.terminate();\n    index = activeWorkers.indexOf(worker);\n    if (index > -1) activeWorkers.splice(index, 1);\n  }\n\n  if (blobUrl && !activeWorkers.length) {\n    URL.revokeObjectURL(blobUrl);\n    blobUrl = null;\n  }\n}\n\nfunction isWorkerProcessorsSupported() {\n  return !!(window.Worker && window.URL && window.Blob);\n}\n\nvar FILL_GAPS = 1;\nvar HORIZONTAL = 2;\nvar ALIGN_RIGHT = 4;\nvar ALIGN_BOTTOM = 8;\nvar ROUNDING = 16;\nvar PACKET_INDEX_ID = 0;\nvar PACKET_INDEX_WIDTH = 1;\nvar PACKET_INDEX_HEIGHT = 2;\nvar PACKET_INDEX_OPTIONS = 3;\nvar PACKET_HEADER_SLOTS = 4;\n/**\n * @class\n * @param {Number} [numWorkers=0]\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps=false]\n * @param {Boolean} [options.horizontal=false]\n * @param {Boolean} [options.alignRight=false]\n * @param {Boolean} [options.alignBottom=false]\n * @param {Boolean} [options.rounding=false]\n */\n\nfunction Packer(numWorkers, options) {\n  this._options = 0;\n  this._processor = null;\n  this._layoutQueue = [];\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n  this._workers = [];\n  this._onWorkerMessage = this._onWorkerMessage.bind(this); // Set initial options.\n\n  this.setOptions(options); // Init the worker(s) or the processor if workers can't be used.\n\n  numWorkers = typeof numWorkers === 'number' ? Math.max(0, numWorkers) : 0;\n\n  if (numWorkers && isWorkerProcessorsSupported()) {\n    try {\n      this._workers = createWorkerProcessors(numWorkers, this._onWorkerMessage);\n    } catch (e) {\n      this._processor = new PackerProcessor();\n    }\n  } else {\n    this._processor = new PackerProcessor();\n  }\n}\n\nPacker.prototype._sendToWorker = function () {\n  if (!this._layoutQueue.length || !this._workers.length) return;\n\n  var layoutId = this._layoutQueue.shift();\n\n  var worker = this._workers.pop();\n\n  var data = this._layoutWorkerData[layoutId];\n  delete this._layoutWorkerData[layoutId];\n  this._layoutWorkers[layoutId] = worker;\n  worker.postMessage(data.buffer, [data.buffer]);\n};\n\nPacker.prototype._onWorkerMessage = function (msg) {\n  var data = new Float32Array(msg.data);\n  var layoutId = data[PACKET_INDEX_ID];\n  var layout = this._layouts[layoutId];\n  var callback = this._layoutCallbacks[layoutId];\n  var worker = this._layoutWorkers[layoutId];\n  if (layout) delete this._layouts[layoutId];\n  if (callback) delete this._layoutCallbacks[layoutId];\n  if (worker) delete this._layoutWorkers[layoutId];\n\n  if (layout && callback) {\n    layout.width = data[PACKET_INDEX_WIDTH];\n    layout.height = data[PACKET_INDEX_HEIGHT];\n    layout.slots = data.subarray(PACKET_HEADER_SLOTS, data.length);\n\n    this._finalizeLayout(layout);\n\n    callback(layout);\n  }\n\n  if (worker) {\n    this._workers.push(worker);\n\n    this._sendToWorker();\n  }\n};\n\nPacker.prototype._finalizeLayout = function (layout) {\n  var grid = layout._grid;\n  var isHorizontal = layout._settings & HORIZONTAL;\n  var isBorderBox = grid._boxSizing === 'border-box';\n  delete layout._grid;\n  delete layout._settings;\n  layout.styles = {};\n\n  if (isHorizontal) {\n    layout.styles.width = (isBorderBox ? layout.width + grid._borderLeft + grid._borderRight : layout.width) + 'px';\n  } else {\n    layout.styles.height = (isBorderBox ? layout.height + grid._borderTop + grid._borderBottom : layout.height) + 'px';\n  }\n\n  return layout;\n};\n/**\n * @public\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps]\n * @param {Boolean} [options.horizontal]\n * @param {Boolean} [options.alignRight]\n * @param {Boolean} [options.alignBottom]\n * @param {Boolean} [options.rounding]\n */\n\n\nPacker.prototype.setOptions = function (options) {\n  if (!options) return;\n  var fillGaps;\n\n  if (typeof options.fillGaps === 'boolean') {\n    fillGaps = options.fillGaps ? FILL_GAPS : 0;\n  } else {\n    fillGaps = this._options & FILL_GAPS;\n  }\n\n  var horizontal;\n\n  if (typeof options.horizontal === 'boolean') {\n    horizontal = options.horizontal ? HORIZONTAL : 0;\n  } else {\n    horizontal = this._options & HORIZONTAL;\n  }\n\n  var alignRight;\n\n  if (typeof options.alignRight === 'boolean') {\n    alignRight = options.alignRight ? ALIGN_RIGHT : 0;\n  } else {\n    alignRight = this._options & ALIGN_RIGHT;\n  }\n\n  var alignBottom;\n\n  if (typeof options.alignBottom === 'boolean') {\n    alignBottom = options.alignBottom ? ALIGN_BOTTOM : 0;\n  } else {\n    alignBottom = this._options & ALIGN_BOTTOM;\n  }\n\n  var rounding;\n\n  if (typeof options.rounding === 'boolean') {\n    rounding = options.rounding ? ROUNDING : 0;\n  } else {\n    rounding = this._options & ROUNDING;\n  }\n\n  this._options = fillGaps | horizontal | alignRight | alignBottom | rounding;\n};\n/**\n * @public\n * @param {Grid} grid\n * @param {Number} layoutId\n * @param {Item[]} items\n * @param {Number} width\n * @param {Number} height\n * @param {Function} callback\n * @returns {?Function}\n */\n\n\nPacker.prototype.createLayout = function (grid, layoutId, items, width, height, callback) {\n  if (this._layouts[layoutId]) {\n    throw new Error('A layout with the provided id is currently being processed.');\n  }\n\n  var horizontal = this._options & HORIZONTAL;\n  var layout = {\n    id: layoutId,\n    items: items,\n    slots: null,\n    width: horizontal ? 0 : width,\n    height: !horizontal ? 0 : height,\n    // Temporary data, which will be removed before sending the layout data\n    // outside of Packer's context.\n    _grid: grid,\n    _settings: this._options\n  }; // If there are no items let's call the callback immediately.\n\n  if (!items.length) {\n    layout.slots = [];\n\n    this._finalizeLayout(layout);\n\n    callback(layout);\n    return;\n  } // Create layout synchronously if needed.\n\n\n  if (this._processor) {\n    layout.slots = window.Float32Array ? new Float32Array(items.length * 2) : new Array(items.length * 2);\n\n    this._processor.computeLayout(layout, layout._settings);\n\n    this._finalizeLayout(layout);\n\n    callback(layout);\n    return;\n  } // Worker data.\n\n\n  var data = new Float32Array(PACKET_HEADER_SLOTS + items.length * 2); // Worker data header.\n\n  data[PACKET_INDEX_ID] = layoutId;\n  data[PACKET_INDEX_WIDTH] = layout.width;\n  data[PACKET_INDEX_HEIGHT] = layout.height;\n  data[PACKET_INDEX_OPTIONS] = layout._settings; // Worker data items.\n\n  var i, j, item;\n\n  for (i = 0, j = PACKET_HEADER_SLOTS - 1, item; i < items.length; i++) {\n    item = items[i];\n    data[++j] = item._width + item._marginLeft + item._marginRight;\n    data[++j] = item._height + item._marginTop + item._marginBottom;\n  }\n\n  this._layoutQueue.push(layoutId);\n\n  this._layouts[layoutId] = layout;\n  this._layoutCallbacks[layoutId] = callback;\n  this._layoutWorkerData[layoutId] = data;\n\n  this._sendToWorker();\n\n  return this.cancelLayout.bind(this, layoutId);\n};\n/**\n * @public\n * @param {Number} layoutId\n */\n\n\nPacker.prototype.cancelLayout = function (layoutId) {\n  var layout = this._layouts[layoutId];\n  if (!layout) return;\n  delete this._layouts[layoutId];\n  delete this._layoutCallbacks[layoutId];\n\n  if (this._layoutWorkerData[layoutId]) {\n    delete this._layoutWorkerData[layoutId];\n\n    var queueIndex = this._layoutQueue.indexOf(layoutId);\n\n    if (queueIndex > -1) this._layoutQueue.splice(queueIndex, 1);\n  }\n};\n/**\n * @public\n */\n\n\nPacker.prototype.destroy = function () {\n  // Move all currently used workers back in the workers array.\n  for (var key in this._layoutWorkers) {\n    this._workers.push(this._layoutWorkers[key]);\n  } // Destroy all instance's workers.\n\n\n  destroyWorkerProcessors(this._workers); // Reset data.\n\n  this._workers.length = 0;\n  this._layoutQueue.length = 0;\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n};\n\nvar debounceId = 0;\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. The returned function accepts one argument which, when\n * being `true`, cancels the debounce function immediately. When the debounce\n * function is canceled it cannot be invoked again.\n *\n * @param {Function} fn\n * @param {Number} durationMs\n * @returns {Function}\n */\n\nfunction debounce(fn, durationMs) {\n  var id = ++debounceId;\n  var timer = 0;\n  var lastTime = 0;\n  var isCanceled = false;\n\n  var tick = function (time) {\n    if (isCanceled) return;\n    if (lastTime) timer -= time - lastTime;\n    lastTime = time;\n\n    if (timer > 0) {\n      addDebounceTick(id, tick);\n    } else {\n      timer = lastTime = 0;\n      fn();\n    }\n  };\n\n  return function (cancel) {\n    if (isCanceled) return;\n\n    if (durationMs <= 0) {\n      if (cancel !== true) fn();\n      return;\n    }\n\n    if (cancel === true) {\n      isCanceled = true;\n      timer = lastTime = 0;\n      tick = undefined;\n      cancelDebounceTick(id);\n      return;\n    }\n\n    if (timer <= 0) {\n      timer = durationMs;\n      tick(0);\n    } else {\n      timer = durationMs;\n    }\n  };\n}\n\nvar htmlCollectionType = '[object HTMLCollection]';\nvar nodeListType = '[object NodeList]';\n/**\n * Check if a value is a node list or a html collection.\n *\n * @param {*} val\n * @returns {Boolean}\n */\n\nfunction isNodeList(val) {\n  var type = Object.prototype.toString.call(val);\n  return type === htmlCollectionType || type === nodeListType;\n}\n\nvar objectType = 'object';\nvar objectToStringType = '[object Object]';\nvar toString = Object.prototype.toString;\n/**\n * Check if a value is a plain object.\n *\n * @param {*} val\n * @returns {Boolean}\n */\n\nfunction isPlainObject(val) {\n  return typeof val === objectType && toString.call(val) === objectToStringType;\n}\n\nfunction noop() {}\n/**\n * Converts a value to an array or clones an array.\n *\n * @param {*} val\n * @returns {Array}\n */\n\n\nfunction toArray(val) {\n  return isNodeList(val) ? Array.prototype.slice.call(val) : Array.prototype.concat(val);\n}\n\nvar NUMBER_TYPE = 'number';\nvar STRING_TYPE = 'string';\nvar INSTANT_LAYOUT = 'instant';\nvar layoutId = 0;\n/**\n * Creates a new Grid instance.\n *\n * @class\n * @param {(HTMLElement|String)} element\n * @param {Object} [options]\n * @param {(String|HTMLElement[]|NodeList|HTMLCollection)} [options.items=\"*\"]\n * @param {Number} [options.showDuration=300]\n * @param {String} [options.showEasing=\"ease\"]\n * @param {Object} [options.visibleStyles={opacity: \"1\", transform: \"scale(1)\"}]\n * @param {Number} [options.hideDuration=300]\n * @param {String} [options.hideEasing=\"ease\"]\n * @param {Object} [options.hiddenStyles={opacity: \"0\", transform: \"scale(0.5)\"}]\n * @param {(Function|Object)} [options.layout]\n * @param {Boolean} [options.layout.fillGaps=false]\n * @param {Boolean} [options.layout.horizontal=false]\n * @param {Boolean} [options.layout.alignRight=false]\n * @param {Boolean} [options.layout.alignBottom=false]\n * @param {Boolean} [options.layout.rounding=false]\n * @param {(Boolean|Number)} [options.layoutOnResize=150]\n * @param {Boolean} [options.layoutOnInit=true]\n * @param {Number} [options.layoutDuration=300]\n * @param {String} [options.layoutEasing=\"ease\"]\n * @param {?Object} [options.sortData=null]\n * @param {Boolean} [options.dragEnabled=false]\n * @param {?String} [options.dragHandle=null]\n * @param {?HtmlElement} [options.dragContainer=null]\n * @param {?Function} [options.dragStartPredicate]\n * @param {Number} [options.dragStartPredicate.distance=0]\n * @param {Number} [options.dragStartPredicate.delay=0]\n * @param {String} [options.dragAxis=\"xy\"]\n * @param {(Boolean|Function)} [options.dragSort=true]\n * @param {Object} [options.dragSortHeuristics]\n * @param {Number} [options.dragSortHeuristics.sortInterval=100]\n * @param {Number} [options.dragSortHeuristics.minDragDistance=10]\n * @param {Number} [options.dragSortHeuristics.minBounceBackAngle=1]\n * @param {(Function|Object)} [options.dragSortPredicate]\n * @param {Number} [options.dragSortPredicate.threshold=50]\n * @param {String} [options.dragSortPredicate.action=\"move\"]\n * @param {String} [options.dragSortPredicate.migrateAction=\"move\"]\n * @param {Object} [options.dragRelease]\n * @param {Number} [options.dragRelease.duration=300]\n * @param {String} [options.dragRelease.easing=\"ease\"]\n * @param {Boolean} [options.dragRelease.useDragContainer=true]\n * @param {Object} [options.dragCssProps]\n * @param {Object} [options.dragPlaceholder]\n * @param {Boolean} [options.dragPlaceholder.enabled=false]\n * @param {?Function} [options.dragPlaceholder.createElement=null]\n * @param {?Function} [options.dragPlaceholder.onCreate=null]\n * @param {?Function} [options.dragPlaceholder.onRemove=null]\n * @param {Object} [options.dragAutoScroll]\n * @param {(Function|Array)} [options.dragAutoScroll.targets=[]]\n * @param {?Function} [options.dragAutoScroll.handle=null]\n * @param {Number} [options.dragAutoScroll.threshold=50]\n * @param {Number} [options.dragAutoScroll.safeZone=0.2]\n * @param {(Function|Number)} [options.dragAutoScroll.speed]\n * @param {Boolean} [options.dragAutoScroll.sortDuringScroll=true]\n * @param {Boolean} [options.dragAutoScroll.smoothStop=false]\n * @param {?Function} [options.dragAutoScroll.onStart=null]\n * @param {?Function} [options.dragAutoScroll.onStop=null]\n * @param {String} [options.containerClass=\"muuri\"]\n * @param {String} [options.itemClass=\"muuri-item\"]\n * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n * @param {String} [options.itemPlaceholderClass=\"muuri-item-placeholder\"]\n */\n\nfunction Grid(element, options) {\n  // Allow passing element as selector string\n  if (typeof element === STRING_TYPE) {\n    element = document.querySelector(element);\n  } // Throw an error if the container element is not body element or does not\n  // exist within the body element.\n\n\n  var isElementInDom = element.getRootNode ? element.getRootNode({\n    composed: true\n  }) === document : document.body.contains(element);\n\n  if (!isElementInDom || element === document.documentElement) {\n    throw new Error('Container element must be an existing DOM element.');\n  } // Create instance settings by merging the options with default options.\n\n\n  var settings = mergeSettings(Grid.defaultOptions, options);\n  settings.visibleStyles = normalizeStyles(settings.visibleStyles);\n  settings.hiddenStyles = normalizeStyles(settings.hiddenStyles);\n\n  if (!isFunction(settings.dragSort)) {\n    settings.dragSort = !!settings.dragSort;\n  }\n\n  this._id = createUid();\n  this._element = element;\n  this._settings = settings;\n  this._isDestroyed = false;\n  this._items = [];\n  this._layout = {\n    id: 0,\n    items: [],\n    slots: []\n  };\n  this._isLayoutFinished = true;\n  this._nextLayoutData = null;\n  this._emitter = new Emitter();\n  this._onLayoutDataReceived = this._onLayoutDataReceived.bind(this); // Store grid instance to the grid instances collection.\n\n  GRID_INSTANCES[this._id] = this; // Add container element's class name.\n\n  addClass(element, settings.containerClass); // If layoutOnResize option is a valid number sanitize it and bind the resize\n  // handler.\n\n  bindLayoutOnResize(this, settings.layoutOnResize); // Add initial items.\n\n  this.add(getInitialGridElements(element, settings.items), {\n    layout: false\n  }); // Layout on init if necessary.\n\n  if (settings.layoutOnInit) {\n    this.layout(true);\n  }\n}\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @see Item\n */\n\n\nGrid.Item = Item;\n/**\n * @public\n * @static\n * @see ItemLayout\n */\n\nGrid.ItemLayout = ItemLayout;\n/**\n * @public\n * @static\n * @see ItemVisibility\n */\n\nGrid.ItemVisibility = ItemVisibility;\n/**\n * @public\n * @static\n * @see ItemMigrate\n */\n\nGrid.ItemMigrate = ItemMigrate;\n/**\n * @public\n * @static\n * @see ItemDrag\n */\n\nGrid.ItemDrag = ItemDrag;\n/**\n * @public\n * @static\n * @see ItemDragRelease\n */\n\nGrid.ItemDragRelease = ItemDragRelease;\n/**\n * @public\n * @static\n * @see ItemDragPlaceholder\n */\n\nGrid.ItemDragPlaceholder = ItemDragPlaceholder;\n/**\n * @public\n * @static\n * @see Emitter\n */\n\nGrid.Emitter = Emitter;\n/**\n * @public\n * @static\n * @see Animator\n */\n\nGrid.Animator = Animator;\n/**\n * @public\n * @static\n * @see Dragger\n */\n\nGrid.Dragger = Dragger;\n/**\n * @public\n * @static\n * @see Packer\n */\n\nGrid.Packer = Packer;\n/**\n * @public\n * @static\n * @see AutoScroller\n */\n\nGrid.AutoScroller = AutoScroller;\n/**\n * The default Packer instance used by default for all layouts.\n *\n * @public\n * @static\n * @type {Packer}\n */\n\nGrid.defaultPacker = new Packer(2);\n/**\n * Default options for Grid instance.\n *\n * @public\n * @static\n * @type {Object}\n */\n\nGrid.defaultOptions = {\n  // Initial item elements\n  items: '*',\n  // Default show animation\n  showDuration: 300,\n  showEasing: 'ease',\n  // Default hide animation\n  hideDuration: 300,\n  hideEasing: 'ease',\n  // Item's visible/hidden state styles\n  visibleStyles: {\n    opacity: '1',\n    transform: 'scale(1)'\n  },\n  hiddenStyles: {\n    opacity: '0',\n    transform: 'scale(0.5)'\n  },\n  // Layout\n  layout: {\n    fillGaps: false,\n    horizontal: false,\n    alignRight: false,\n    alignBottom: false,\n    rounding: false\n  },\n  layoutOnResize: 150,\n  layoutOnInit: true,\n  layoutDuration: 300,\n  layoutEasing: 'ease',\n  // Sorting\n  sortData: null,\n  // Drag & Drop\n  dragEnabled: false,\n  dragContainer: null,\n  dragHandle: null,\n  dragStartPredicate: {\n    distance: 0,\n    delay: 0\n  },\n  dragAxis: 'xy',\n  dragSort: true,\n  dragSortHeuristics: {\n    sortInterval: 100,\n    minDragDistance: 10,\n    minBounceBackAngle: 1\n  },\n  dragSortPredicate: {\n    threshold: 50,\n    action: ACTION_MOVE,\n    migrateAction: ACTION_MOVE\n  },\n  dragRelease: {\n    duration: 300,\n    easing: 'ease',\n    useDragContainer: true\n  },\n  dragCssProps: {\n    touchAction: 'none',\n    userSelect: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0, 0, 0, 0)',\n    touchCallout: 'none',\n    contentZooming: 'none'\n  },\n  dragPlaceholder: {\n    enabled: false,\n    createElement: null,\n    onCreate: null,\n    onRemove: null\n  },\n  dragAutoScroll: {\n    targets: [],\n    handle: null,\n    threshold: 50,\n    safeZone: 0.2,\n    speed: AutoScroller.smoothSpeed(1000, 2000, 2500),\n    sortDuringScroll: true,\n    smoothStop: false,\n    onStart: null,\n    onStop: null\n  },\n  // Classnames\n  containerClass: 'muuri',\n  itemClass: 'muuri-item',\n  itemVisibleClass: 'muuri-item-shown',\n  itemHiddenClass: 'muuri-item-hidden',\n  itemPositioningClass: 'muuri-item-positioning',\n  itemDraggingClass: 'muuri-item-dragging',\n  itemReleasingClass: 'muuri-item-releasing',\n  itemPlaceholderClass: 'muuri-item-placeholder'\n};\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\n\nGrid.prototype.on = function (event, listener) {\n  this._emitter.on(event, listener);\n\n  return this;\n};\n/**\n * Unbind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\n\n\nGrid.prototype.off = function (event, listener) {\n  this._emitter.off(event, listener);\n\n  return this;\n};\n/**\n * Get the container element.\n *\n * @public\n * @returns {HTMLElement}\n */\n\n\nGrid.prototype.getElement = function () {\n  return this._element;\n};\n/**\n * Get instance's item by element or by index. Target can also be an Item\n * instance in which case the function returns the item if it exists within\n * related Grid instance. If nothing is found with the provided target, null\n * is returned.\n *\n * @private\n * @param {(HtmlElement|Number|Item)} [target]\n * @returns {?Item}\n */\n\n\nGrid.prototype.getItem = function (target) {\n  // If no target is specified or the instance is destroyed, return null.\n  if (this._isDestroyed || !target && target !== 0) {\n    return null;\n  } // If target is number return the item in that index. If the number is lower\n  // than zero look for the item starting from the end of the items array. For\n  // example -1 for the last item, -2 for the second last item, etc.\n\n\n  if (typeof target === NUMBER_TYPE) {\n    return this._items[target > -1 ? target : this._items.length + target] || null;\n  } // If the target is an instance of Item return it if it is attached to this\n  // Grid instance, otherwise return null.\n\n\n  if (target instanceof Item) {\n    return target._gridId === this._id ? target : null;\n  } // In other cases let's assume that the target is an element, so let's try\n  // to find an item that matches the element and return it. If item is not\n  // found return null.\n\n\n  if (ITEM_ELEMENT_MAP) {\n    var item = ITEM_ELEMENT_MAP.get(target);\n    return item && item._gridId === this._id ? item : null;\n  } else {\n    for (var i = 0; i < this._items.length; i++) {\n      if (this._items[i]._element === target) {\n        return this._items[i];\n      }\n    }\n  }\n\n  return null;\n};\n/**\n * Get all items. Optionally you can provide specific targets (elements,\n * indices and item instances). All items that are not found are omitted from\n * the returned array.\n *\n * @public\n * @param {(HtmlElement|Number|Item|Array)} [targets]\n * @returns {Item[]}\n */\n\n\nGrid.prototype.getItems = function (targets) {\n  // Return all items immediately if no targets were provided or if the\n  // instance is destroyed.\n  if (this._isDestroyed || targets === undefined) {\n    return this._items.slice(0);\n  }\n\n  var items = [];\n  var i, item;\n\n  if (Array.isArray(targets) || isNodeList(targets)) {\n    for (i = 0; i < targets.length; i++) {\n      item = this.getItem(targets[i]);\n      if (item) items.push(item);\n    }\n  } else {\n    item = this.getItem(targets);\n    if (item) items.push(item);\n  }\n\n  return items;\n};\n/**\n * Update the cached dimensions of the instance's items. By default all the\n * items are refreshed, but you can also provide an array of target items as the\n * first argument if you want to refresh specific items. Note that all hidden\n * items are not refreshed by default since their \"display\" property is \"none\"\n * and their dimensions are therefore not readable from the DOM. However, if you\n * do want to force update hidden item dimensions too you can provide `true`\n * as the second argument, which makes the elements temporarily visible while\n * their dimensions are being read.\n *\n * @public\n * @param {Item[]} [items]\n * @param {Boolean} [force=false]\n * @returns {Grid}\n */\n\n\nGrid.prototype.refreshItems = function (items, force) {\n  if (this._isDestroyed) return this;\n  var targets = items || this._items;\n  var i, item, style, hiddenItemStyles;\n\n  if (force === true) {\n    hiddenItemStyles = [];\n\n    for (i = 0; i < targets.length; i++) {\n      item = targets[i];\n\n      if (!item.isVisible() && !item.isHiding()) {\n        style = item.getElement().style;\n        style.visibility = 'hidden';\n        style.display = '';\n        hiddenItemStyles.push(style);\n      }\n    }\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    targets[i]._refreshDimensions(force);\n  }\n\n  if (force === true) {\n    for (i = 0; i < hiddenItemStyles.length; i++) {\n      style = hiddenItemStyles[i];\n      style.visibility = '';\n      style.display = 'none';\n    }\n\n    hiddenItemStyles.length = 0;\n  }\n\n  return this;\n};\n/**\n * Update the sort data of the instance's items. By default all the items are\n * refreshed, but you can also provide an array of target items if you want to\n * refresh specific items.\n *\n * @public\n * @param {Item[]} [items]\n * @returns {Grid}\n */\n\n\nGrid.prototype.refreshSortData = function (items) {\n  if (this._isDestroyed) return this;\n  var targets = items || this._items;\n\n  for (var i = 0; i < targets.length; i++) {\n    targets[i]._refreshSortData();\n  }\n\n  return this;\n};\n/**\n * Synchronize the item elements to match the order of the items in the DOM.\n * This comes handy if you need to keep the DOM structure matched with the\n * order of the items. Note that if an item's element is not currently a child\n * of the container element (if it is dragged for example) it is ignored and\n * left untouched.\n *\n * @public\n * @returns {Grid}\n */\n\n\nGrid.prototype.synchronize = function () {\n  if (this._isDestroyed) return this;\n  var items = this._items;\n  if (!items.length) return this;\n  var fragment;\n  var element;\n\n  for (var i = 0; i < items.length; i++) {\n    element = items[i]._element;\n\n    if (element.parentNode === this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n\n  if (!fragment) return this;\n\n  this._element.appendChild(fragment);\n\n  this._emit(EVENT_SYNCHRONIZE);\n\n  return this;\n};\n/**\n * Calculate and apply item positions.\n *\n * @public\n * @param {Boolean} [instant=false]\n * @param {Function} [onFinish]\n * @returns {Grid}\n */\n\n\nGrid.prototype.layout = function (instant, onFinish) {\n  if (this._isDestroyed) return this; // Cancel unfinished layout algorithm if possible.\n\n  var unfinishedLayout = this._nextLayoutData;\n\n  if (unfinishedLayout && isFunction(unfinishedLayout.cancel)) {\n    unfinishedLayout.cancel();\n  } // Compute layout id (let's stay in Float32 range).\n\n\n  layoutId = layoutId % MAX_SAFE_FLOAT32_INTEGER + 1;\n  var nextLayoutId = layoutId; // Store data for next layout.\n\n  this._nextLayoutData = {\n    id: nextLayoutId,\n    instant: instant,\n    onFinish: onFinish,\n    cancel: null\n  }; // Collect layout items (all active grid items).\n\n  var items = this._items;\n  var layoutItems = [];\n\n  for (var i = 0; i < items.length; i++) {\n    if (items[i]._isActive) layoutItems.push(items[i]);\n  } // Compute new layout.\n\n\n  this._refreshDimensions();\n\n  var gridWidth = this._width - this._borderLeft - this._borderRight;\n  var gridHeight = this._height - this._borderTop - this._borderBottom;\n  var layoutSettings = this._settings.layout;\n  var cancelLayout;\n\n  if (isFunction(layoutSettings)) {\n    cancelLayout = layoutSettings(this, nextLayoutId, layoutItems, gridWidth, gridHeight, this._onLayoutDataReceived);\n  } else {\n    Grid.defaultPacker.setOptions(layoutSettings);\n    cancelLayout = Grid.defaultPacker.createLayout(this, nextLayoutId, layoutItems, gridWidth, gridHeight, this._onLayoutDataReceived);\n  } // Store layout cancel method if available.\n\n\n  if (isFunction(cancelLayout) && this._nextLayoutData && this._nextLayoutData.id === nextLayoutId) {\n    this._nextLayoutData.cancel = cancelLayout;\n  }\n\n  return this;\n};\n/**\n * Add new items by providing the elements you wish to add to the instance and\n * optionally provide the index where you want the items to be inserted into.\n * All elements that are not already children of the container element will be\n * automatically appended to the container element. If an element has it's CSS\n * display property set to \"none\" it will be marked as inactive during the\n * initiation process. As long as the item is inactive it will not be part of\n * the layout, but it will retain it's index. You can activate items at any\n * point with grid.show() method. This method will automatically call\n * grid.layout() if one or more of the added elements are visible. If only\n * hidden items are added no layout will be called. All the new visible items\n * are positioned without animation during their first layout.\n *\n * @public\n * @param {(HTMLElement|HTMLElement[])} elements\n * @param {Object} [options]\n * @param {Number} [options.index=-1]\n * @param {Boolean} [options.active]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\n\n\nGrid.prototype.add = function (elements, options) {\n  if (this._isDestroyed || !elements) return [];\n  var newItems = toArray(elements);\n  if (!newItems.length) return newItems;\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var items = this._items;\n  var needsLayout = false;\n  var fragment;\n  var element;\n  var item;\n  var i; // Collect all the elements that are not child of the grid element into a\n  // document fragment.\n\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n\n    if (element.parentNode !== this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  } // If we have a fragment, let's append it to the grid element. We could just\n  // not do this and the `new Item()` instantiation would handle this for us,\n  // but this way we can add the elements into the DOM a bit faster.\n\n\n  if (fragment) {\n    this._element.appendChild(fragment);\n  } // Map provided elements into new grid items.\n\n\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    item = newItems[i] = new Item(this, element, opts.active); // If the item to be added is active, we need to do a layout. Also, we\n    // need to mark the item with the skipNextAnimation flag to make it\n    // position instantly (without animation) during the next layout. Without\n    // the hack the item would animate to it's new position from the northwest\n    // corner of the grid, which feels a bit buggy (imho).\n\n    if (item._isActive) {\n      needsLayout = true;\n      item._layout._skipNextAnimation = true;\n    }\n  } // Set up the items' initial dimensions and sort data. This needs to be done\n  // in a separate loop to avoid layout thrashing.\n\n\n  for (i = 0; i < newItems.length; i++) {\n    item = newItems[i];\n\n    item._refreshDimensions();\n\n    item._refreshSortData();\n  } // Add the new items to the items collection to correct index.\n\n\n  arrayInsert(items, newItems, opts.index); // Emit add event.\n\n  if (this._hasListeners(EVENT_ADD)) {\n    this._emit(EVENT_ADD, newItems.slice(0));\n  } // If layout is needed.\n\n\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n\n  return newItems;\n};\n/**\n * Remove items from the instance.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.removeElements=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\n\n\nGrid.prototype.remove = function (items, options) {\n  if (this._isDestroyed || !items.length) return [];\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var needsLayout = false;\n  var allItems = this.getItems();\n  var targetItems = [];\n  var indices = [];\n  var index;\n  var item;\n  var i; // Remove the individual items.\n\n  for (i = 0; i < items.length; i++) {\n    item = items[i];\n    if (item._isDestroyed) continue;\n    index = this._items.indexOf(item);\n    if (index === -1) continue;\n    if (item._isActive) needsLayout = true;\n    targetItems.push(item);\n    indices.push(allItems.indexOf(item));\n\n    item._destroy(opts.removeElements);\n\n    this._items.splice(index, 1);\n  } // Emit remove event.\n\n\n  if (this._hasListeners(EVENT_REMOVE)) {\n    this._emit(EVENT_REMOVE, targetItems.slice(0), indices);\n  } // If layout is needed.\n\n\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n\n  return targetItems;\n};\n/**\n * Show specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\n\n\nGrid.prototype.show = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, true, options);\n  }\n\n  return this;\n};\n/**\n * Hide specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\n\n\nGrid.prototype.hide = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, false, options);\n  }\n\n  return this;\n};\n/**\n * Filter items. Expects at least one argument, a predicate, which should be\n * either a function or a string. The predicate callback is executed for every\n * item in the instance. If the return value of the predicate is truthy the\n * item in question will be shown and otherwise hidden. The predicate callback\n * receives the item instance as it's argument. If the predicate is a string\n * it is considered to be a selector and it is checked against every item\n * element in the instance with the native element.matches() method. All the\n * matching items will be shown and others hidden.\n *\n * @public\n * @param {(Function|String)} predicate\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {FilterCallback} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\n\n\nGrid.prototype.filter = function (predicate, options) {\n  if (this._isDestroyed || !this._items.length) return this;\n  var itemsToShow = [];\n  var itemsToHide = [];\n  var isPredicateString = typeof predicate === STRING_TYPE;\n  var isPredicateFn = isFunction(predicate);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var syncWithLayout = opts.syncWithLayout;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var onFinish = isFunction(opts.onFinish) ? opts.onFinish : null;\n  var tryFinishCounter = -1;\n  var tryFinish = noop;\n  var item;\n  var i; // If we have onFinish callback, let's create proper tryFinish callback.\n\n  if (onFinish) {\n    tryFinish = function () {\n      ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\n    };\n  } // Check which items need to be shown and which hidden.\n\n\n  if (isPredicateFn || isPredicateString) {\n    for (i = 0; i < this._items.length; i++) {\n      item = this._items[i];\n\n      if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n        itemsToShow.push(item);\n      } else {\n        itemsToHide.push(item);\n      }\n    }\n  } // Show items that need to be shown.\n\n\n  if (itemsToShow.length) {\n    this.show(itemsToShow, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false\n    });\n  } else {\n    tryFinish();\n  } // Hide items that need to be hidden.\n\n\n  if (itemsToHide.length) {\n    this.hide(itemsToHide, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false\n    });\n  } else {\n    tryFinish();\n  } // If there are any items to filter.\n\n\n  if (itemsToShow.length || itemsToHide.length) {\n    // Emit filter event.\n    if (this._hasListeners(EVENT_FILTER)) {\n      this._emit(EVENT_FILTER, itemsToShow.slice(0), itemsToHide.slice(0));\n    } // If layout is needed.\n\n\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n\n  return this;\n};\n/**\n * Sort items. There are three ways to sort the items. The first is simply by\n * providing a function as the comparer which works identically to native\n * array sort. Alternatively you can sort by the sort data you have provided\n * in the instance's options. Just provide the sort data key(s) as a string\n * (separated by space) and the items will be sorted based on the provided\n * sort data keys. Lastly you have the opportunity to provide a presorted\n * array of items which will be used to sync the internal items array in the\n * same order.\n *\n * @public\n * @param {(Function|String|Item[])} comparer\n * @param {Object} [options]\n * @param {Boolean} [options.descending=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\n\n\nGrid.prototype.sort = function () {\n  var sortComparer;\n  var isDescending;\n  var origItems;\n  var indexMap;\n\n  function defaultComparer(a, b) {\n    var result = 0;\n    var criteriaName;\n    var criteriaOrder;\n    var valA;\n    var valB; // Loop through the list of sort criteria.\n\n    for (var i = 0; i < sortComparer.length; i++) {\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = sortComparer[i][0];\n      criteriaOrder = sortComparer[i][1]; // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n\n      valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\n      valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName]; // Sort the items in descending order if defined so explicitly. Otherwise\n      // sort items in ascending order.\n\n      if (criteriaOrder === 'desc' || !criteriaOrder && isDescending) {\n        result = valB < valA ? -1 : valB > valA ? 1 : 0;\n      } else {\n        result = valA < valB ? -1 : valA > valB ? 1 : 0;\n      } // If we have -1 or 1 as the return value, let's return it immediately.\n\n\n      if (result) return result;\n    } // If values are equal let's compare the item indices to make sure we\n    // have a stable sort. Note that this is not necessary in evergreen browsers\n    // because Array.sort() is nowadays stable. However, in order to guarantee\n    // same results in older browsers we need this.\n\n\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n\n    return result;\n  }\n\n  function customComparer(a, b) {\n    var result = isDescending ? -sortComparer(a, b) : sortComparer(a, b);\n\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n\n    return result;\n  }\n\n  return function (comparer, options) {\n    if (this._isDestroyed || this._items.length < 2) return this;\n    var items = this._items;\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined; // Setup parent scope data.\n\n    isDescending = !!opts.descending;\n    origItems = items.slice(0);\n    indexMap = null; // If function is provided do a native array sort.\n\n    if (isFunction(comparer)) {\n      sortComparer = comparer;\n      items.sort(customComparer);\n    } // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof comparer === STRING_TYPE) {\n      sortComparer = comparer.trim().split(' ').filter(function (val) {\n        return val;\n      }).map(function (val) {\n        return val.split(':');\n      });\n      items.sort(defaultComparer);\n    } // Otherwise if we got an array, let's assume it's a presorted array of the\n    // items and order the items based on it. Here we blindly trust that the\n    // presorted array consists of the same item instances as the current\n    // `gird._items` array.\n    else if (Array.isArray(comparer)) {\n      items.length = 0;\n      items.push.apply(items, comparer);\n    } // Otherwise let's throw an error.\n    else {\n      sortComparer = isDescending = origItems = indexMap = null;\n      throw new Error('Invalid comparer argument provided.');\n    } // Emit sort event.\n\n\n    if (this._hasListeners(EVENT_SORT)) {\n      this._emit(EVENT_SORT, items.slice(0), origItems);\n    } // If layout is needed.\n\n\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    } // Reset data (to avoid mem leaks).\n\n\n    sortComparer = isDescending = origItems = indexMap = null;\n    return this;\n  };\n}();\n/**\n * Move item to another index or in place of another item.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {String} [options.action=\"move\"]\n *   - Accepts either \"move\" or \"swap\".\n *   - \"move\" moves the item in place of the other item.\n *   - \"swap\" swaps the position of the items.\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\n\n\nGrid.prototype.move = function (item, position, options) {\n  if (this._isDestroyed || this._items.length < 2) return this;\n  var items = this._items;\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var isSwap = opts.action === ACTION_SWAP;\n  var action = isSwap ? ACTION_SWAP : ACTION_MOVE;\n  var fromItem = this.getItem(item);\n  var toItem = this.getItem(position);\n  var fromIndex;\n  var toIndex; // Make sure the items exist and are not the same.\n\n  if (fromItem && toItem && fromItem !== toItem) {\n    // Get the indices of the items.\n    fromIndex = items.indexOf(fromItem);\n    toIndex = items.indexOf(toItem); // Do the move/swap.\n\n    if (isSwap) {\n      arraySwap(items, fromIndex, toIndex);\n    } else {\n      arrayMove(items, fromIndex, toIndex);\n    } // Emit move event.\n\n\n    if (this._hasListeners(EVENT_MOVE)) {\n      this._emit(EVENT_MOVE, {\n        item: fromItem,\n        fromIndex: fromIndex,\n        toIndex: toIndex,\n        action: action\n      });\n    } // If layout is needed.\n\n\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n\n  return this;\n};\n/**\n * Send item to another Grid instance.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {Grid} targetGrid\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {HTMLElement} [options.appendTo=document.body]\n * @param {(Boolean|Function|String)} [options.layoutSender=true]\n * @param {(Boolean|Function|String)} [options.layoutReceiver=true]\n * @returns {Grid}\n */\n\n\nGrid.prototype.send = function (item, targetGrid, position, options) {\n  if (this._isDestroyed || targetGrid._isDestroyed || this === targetGrid) return this; // Make sure we have a valid target item.\n\n  item = this.getItem(item);\n  if (!item) return this;\n  var opts = options || {};\n  var container = opts.appendTo || document.body;\n  var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n  var layoutReceiver = opts.layoutReceiver ? opts.layoutReceiver : opts.layoutReceiver === undefined; // Start the migration process.\n\n  item._migrate.start(targetGrid, position, container); // If migration was started successfully and the item is active, let's layout\n  // the grids.\n\n\n  if (item._migrate._isActive && item._isActive) {\n    if (layoutSender) {\n      this.layout(layoutSender === INSTANT_LAYOUT, isFunction(layoutSender) ? layoutSender : undefined);\n    }\n\n    if (layoutReceiver) {\n      targetGrid.layout(layoutReceiver === INSTANT_LAYOUT, isFunction(layoutReceiver) ? layoutReceiver : undefined);\n    }\n  }\n\n  return this;\n};\n/**\n * Destroy the instance.\n *\n * @public\n * @param {Boolean} [removeElements=false]\n * @returns {Grid}\n */\n\n\nGrid.prototype.destroy = function (removeElements) {\n  if (this._isDestroyed) return this;\n  var container = this._element;\n\n  var items = this._items.slice(0);\n\n  var layoutStyles = this._layout && this._layout.styles || {};\n  var i, prop; // Unbind window resize event listener.\n\n  unbindLayoutOnResize(this); // Destroy items.\n\n  for (i = 0; i < items.length; i++) items[i]._destroy(removeElements);\n\n  this._items.length = 0; // Restore container.\n\n  removeClass(container, this._settings.containerClass);\n\n  for (prop in layoutStyles) container.style[prop] = ''; // Emit destroy event and unbind all events.\n\n\n  this._emit(EVENT_DESTROY);\n\n  this._emitter.destroy(); // Remove reference from the grid instances collection.\n\n\n  delete GRID_INSTANCES[this._id]; // Flag instance as destroyed.\n\n  this._isDestroyed = true;\n  return this;\n};\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Emit a grid event.\n *\n * @private\n * @param {String} event\n * @param {...*} [arg]\n */\n\n\nGrid.prototype._emit = function () {\n  if (this._isDestroyed) return;\n\n  this._emitter.emit.apply(this._emitter, arguments);\n};\n/**\n * Check if there are any events listeners for an event.\n *\n * @private\n * @param {String} event\n * @returns {Boolean}\n */\n\n\nGrid.prototype._hasListeners = function (event) {\n  if (this._isDestroyed) return false;\n  return this._emitter.countListeners(event) > 0;\n};\n/**\n * Update container's width, height and offsets.\n *\n * @private\n */\n\n\nGrid.prototype._updateBoundingRect = function () {\n  var element = this._element;\n  var rect = element.getBoundingClientRect();\n  this._width = rect.width;\n  this._height = rect.height;\n  this._left = rect.left;\n  this._top = rect.top;\n  this._right = rect.right;\n  this._bottom = rect.bottom;\n};\n/**\n * Update container's border sizes.\n *\n * @private\n * @param {Boolean} left\n * @param {Boolean} right\n * @param {Boolean} top\n * @param {Boolean} bottom\n */\n\n\nGrid.prototype._updateBorders = function (left, right, top, bottom) {\n  var element = this._element;\n  if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\n  if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\n  if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\n  if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\n};\n/**\n * Refresh all of container's internal dimensions and offsets.\n *\n * @private\n */\n\n\nGrid.prototype._refreshDimensions = function () {\n  this._updateBoundingRect();\n\n  this._updateBorders(1, 1, 1, 1);\n\n  this._boxSizing = getStyle(this._element, 'box-sizing');\n};\n/**\n * Calculate and apply item positions.\n *\n * @private\n * @param {Object} layout\n */\n\n\nGrid.prototype._onLayoutDataReceived = function () {\n  var itemsToLayout = [];\n  return function (layout) {\n    if (this._isDestroyed || !this._nextLayoutData || this._nextLayoutData.id !== layout.id) return;\n    var grid = this;\n    var instant = this._nextLayoutData.instant;\n    var onFinish = this._nextLayoutData.onFinish;\n    var numItems = layout.items.length;\n    var counter = numItems;\n    var item;\n    var left;\n    var top;\n    var i; // Reset next layout data.\n\n    this._nextLayoutData = null;\n\n    if (!this._isLayoutFinished && this._hasListeners(EVENT_LAYOUT_ABORT)) {\n      this._emit(EVENT_LAYOUT_ABORT, this._layout.items.slice(0));\n    } // Update the layout reference.\n\n\n    this._layout = layout; // Update the item positions and collect all items that need to be laid\n    // out. It is critical that we update the item position _before_ the\n    // layoutStart event as the new data might be needed in the callback.\n\n    itemsToLayout.length = 0;\n\n    for (i = 0; i < numItems; i++) {\n      item = layout.items[i]; // Make sure we have a matching item.\n\n      if (!item) {\n        --counter;\n        continue;\n      } // Get the item's new left and top values.\n\n\n      left = layout.slots[i * 2];\n      top = layout.slots[i * 2 + 1]; // Let's skip the layout process if we can. Possibly avoids a lot of DOM\n      // operations which saves us some CPU cycles.\n\n      if (item._canSkipLayout(left, top)) {\n        --counter;\n        continue;\n      } // Update the item's position.\n\n\n      item._left = left;\n      item._top = top; // Only active non-dragged items need to be moved.\n\n      if (item.isActive() && !item.isDragging()) {\n        itemsToLayout.push(item);\n      } else {\n        --counter;\n      }\n    } // Set layout styles to the grid element.\n\n\n    if (layout.styles) {\n      setStyles(this._element, layout.styles);\n    } // layoutStart event is intentionally emitted after the container element's\n    // dimensions are set, because otherwise there would be no hook for reacting\n    // to container dimension changes.\n\n\n    if (this._hasListeners(EVENT_LAYOUT_START)) {\n      this._emit(EVENT_LAYOUT_START, layout.items.slice(0), instant === true); // Let's make sure that the current layout process has not been overridden\n      // in the layoutStart event, and if so, let's stop processing the aborted\n      // layout.\n\n\n      if (this._layout.id !== layout.id) return;\n    }\n\n    var tryFinish = function () {\n      if (--counter > 0) return;\n      var hasLayoutChanged = grid._layout.id !== layout.id;\n      var callback = isFunction(instant) ? instant : onFinish;\n\n      if (!hasLayoutChanged) {\n        grid._isLayoutFinished = true;\n      }\n\n      if (isFunction(callback)) {\n        callback(layout.items.slice(0), hasLayoutChanged);\n      }\n\n      if (!hasLayoutChanged && grid._hasListeners(EVENT_LAYOUT_END)) {\n        grid._emit(EVENT_LAYOUT_END, layout.items.slice(0));\n      }\n    };\n\n    if (!itemsToLayout.length) {\n      tryFinish();\n      return this;\n    }\n\n    this._isLayoutFinished = false;\n\n    for (i = 0; i < itemsToLayout.length; i++) {\n      if (this._layout.id !== layout.id) break;\n\n      itemsToLayout[i]._layout.start(instant === true, tryFinish);\n    }\n\n    if (this._layout.id === layout.id) {\n      itemsToLayout.length = 0;\n    }\n\n    return this;\n  };\n}();\n/**\n * Show or hide Grid instance's items.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} toVisible\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n */\n\n\nGrid.prototype._setItemsVisibility = function (items, toVisible, options) {\n  var grid = this;\n  var targetItems = items.slice(0);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var callback = opts.onFinish;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var counter = targetItems.length;\n  var startEvent = toVisible ? EVENT_SHOW_START : EVENT_HIDE_START;\n  var endEvent = toVisible ? EVENT_SHOW_END : EVENT_HIDE_END;\n  var method = toVisible ? 'show' : 'hide';\n  var needsLayout = false;\n  var completedItems = [];\n  var hiddenItems = [];\n  var item;\n  var i; // If there are no items call the callback, but don't emit any events.\n\n  if (!counter) {\n    if (isFunction(callback)) callback(targetItems);\n    return;\n  } // Prepare the items.\n\n\n  for (i = 0; i < targetItems.length; i++) {\n    item = targetItems[i]; // If inactive item is shown or active item is hidden we need to do\n    // layout.\n\n    if (toVisible && !item._isActive || !toVisible && item._isActive) {\n      needsLayout = true;\n    } // If inactive item is shown we also need to do a little hack to make the\n    // item not animate it's next positioning (layout).\n\n\n    item._layout._skipNextAnimation = !!(toVisible && !item._isActive); // If a hidden item is being shown we need to refresh the item's\n    // dimensions.\n\n    if (toVisible && item._visibility._isHidden) {\n      hiddenItems.push(item);\n    } // Add item to layout or remove it from layout.\n\n\n    if (toVisible) {\n      item._addToLayout();\n    } else {\n      item._removeFromLayout();\n    }\n  } // Force refresh the dimensions of all hidden items.\n\n\n  if (hiddenItems.length) {\n    this.refreshItems(hiddenItems, true);\n    hiddenItems.length = 0;\n  } // Show the items in sync with the next layout.\n\n\n  function triggerVisibilityChange() {\n    if (needsLayout && opts.syncWithLayout !== false) {\n      grid.off(EVENT_LAYOUT_START, triggerVisibilityChange);\n    }\n\n    if (grid._hasListeners(startEvent)) {\n      grid._emit(startEvent, targetItems.slice(0));\n    }\n\n    for (i = 0; i < targetItems.length; i++) {\n      // Make sure the item is still in the original grid. There is a chance\n      // that the item starts migrating before tiggerVisibilityChange is called.\n      if (targetItems[i]._gridId !== grid._id) {\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n\n        continue;\n      }\n\n      targetItems[i]._visibility[method](isInstant, function (interrupted, item) {\n        // If the current item's animation was not interrupted add it to the\n        // completedItems array.\n        if (!interrupted) completedItems.push(item); // If all items have finished their animations call the callback\n        // and emit showEnd/hideEnd event.\n\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n      });\n    }\n  } // Trigger the visibility change, either async with layout or instantly.\n\n\n  if (needsLayout && opts.syncWithLayout !== false) {\n    this.on(EVENT_LAYOUT_START, triggerVisibilityChange);\n  } else {\n    triggerVisibilityChange();\n  } // Trigger layout if needed.\n\n\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n};\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Merge default settings with user settings. The returned object is a new\n * object with merged values. The merging is a deep merge meaning that all\n * objects and arrays within the provided settings objects will be also merged\n * so that modifying the values of the settings object will have no effect on\n * the returned object.\n *\n * @param {Object} defaultSettings\n * @param {Object} [userSettings]\n * @returns {Object} Returns a new object.\n */\n\n\nfunction mergeSettings(defaultSettings, userSettings) {\n  // Create a fresh copy of default settings.\n  var settings = mergeObjects({}, defaultSettings); // Merge user settings to default settings.\n\n  if (userSettings) {\n    settings = mergeObjects(settings, userSettings);\n  } // Handle visible/hidden styles manually so that the whole object is\n  // overridden instead of the props.\n\n\n  if (userSettings && userSettings.visibleStyles) {\n    settings.visibleStyles = userSettings.visibleStyles;\n  } else if (defaultSettings && defaultSettings.visibleStyles) {\n    settings.visibleStyles = defaultSettings.visibleStyles;\n  }\n\n  if (userSettings && userSettings.hiddenStyles) {\n    settings.hiddenStyles = userSettings.hiddenStyles;\n  } else if (defaultSettings && defaultSettings.hiddenStyles) {\n    settings.hiddenStyles = defaultSettings.hiddenStyles;\n  }\n\n  return settings;\n}\n/**\n * Merge two objects recursively (deep merge). The source object's properties\n * are merged to the target object.\n *\n * @param {Object} target\n *   - The target object.\n * @param {Object} source\n *   - The source object.\n * @returns {Object} Returns the target object.\n */\n\n\nfunction mergeObjects(target, source) {\n  var sourceKeys = Object.keys(source);\n  var length = sourceKeys.length;\n  var isSourceObject;\n  var propName;\n  var i;\n\n  for (i = 0; i < length; i++) {\n    propName = sourceKeys[i];\n    isSourceObject = isPlainObject(source[propName]); // If target and source values are both objects, merge the objects and\n    // assign the merged value to the target property.\n\n    if (isPlainObject(target[propName]) && isSourceObject) {\n      target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\n      continue;\n    } // If source's value is object and target's is not let's clone the object as\n    // the target's value.\n\n\n    if (isSourceObject) {\n      target[propName] = mergeObjects({}, source[propName]);\n      continue;\n    } // If source's value is an array let's clone the array as the target's\n    // value.\n\n\n    if (Array.isArray(source[propName])) {\n      target[propName] = source[propName].slice(0);\n      continue;\n    } // In all other cases let's just directly assign the source's value as the\n    // target's value.\n\n\n    target[propName] = source[propName];\n  }\n\n  return target;\n}\n/**\n * Collect and return initial items for grid.\n *\n * @param {HTMLElement} gridElement\n * @param {?(HTMLElement[]|NodeList|HtmlCollection|String)} elements\n * @returns {(HTMLElement[]|NodeList|HtmlCollection)}\n */\n\n\nfunction getInitialGridElements(gridElement, elements) {\n  // If we have a wildcard selector let's return all the children.\n  if (elements === '*') {\n    return gridElement.children;\n  } // If we have some more specific selector, let's filter the elements.\n\n\n  if (typeof elements === STRING_TYPE) {\n    var result = [];\n    var children = gridElement.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (elementMatches(children[i], elements)) {\n        result.push(children[i]);\n      }\n    }\n\n    return result;\n  } // If we have an array of elements or a node list.\n\n\n  if (Array.isArray(elements) || isNodeList(elements)) {\n    return elements;\n  } // Otherwise just return an empty array.\n\n\n  return [];\n}\n/**\n * Bind grid's resize handler to window.\n *\n * @param {Grid} grid\n * @param {(Number|Boolean)} delay\n */\n\n\nfunction bindLayoutOnResize(grid, delay) {\n  if (typeof delay !== NUMBER_TYPE) {\n    delay = delay === true ? 0 : -1;\n  }\n\n  if (delay >= 0) {\n    grid._resizeHandler = debounce(function () {\n      grid.refreshItems().layout();\n    }, delay);\n    window.addEventListener('resize', grid._resizeHandler);\n  }\n}\n/**\n * Unbind grid's resize handler from window.\n *\n * @param {Grid} grid\n */\n\n\nfunction unbindLayoutOnResize(grid) {\n  if (grid._resizeHandler) {\n    grid._resizeHandler(true);\n\n    window.removeEventListener('resize', grid._resizeHandler);\n    grid._resizeHandler = null;\n  }\n}\n/**\n * Normalize style declaration object, returns a normalized (new) styles object\n * (prefixed properties and invalid properties removed).\n *\n * @param {Object} styles\n * @returns {Object}\n */\n\n\nfunction normalizeStyles(styles) {\n  var normalized = {};\n  var docElemStyle = document.documentElement.style;\n  var prop, prefixedProp; // Normalize visible styles (prefix and remove invalid).\n\n  for (prop in styles) {\n    if (!styles[prop]) continue;\n    prefixedProp = getPrefixedPropName(docElemStyle, prop);\n    if (!prefixedProp) continue;\n    normalized[prefixedProp] = styles[prop];\n  }\n\n  return normalized;\n}\n/**\n * Create index map from items.\n *\n * @param {Item[]} items\n * @returns {Object}\n */\n\n\nfunction createIndexMap(items) {\n  var result = {};\n\n  for (var i = 0; i < items.length; i++) {\n    result[items[i]._id] = i;\n  }\n\n  return result;\n}\n/**\n * Sort comparer function for items' index map.\n *\n * @param {Object} indexMap\n * @param {Item} itemA\n * @param {Item} itemB\n * @returns {Number}\n */\n\n\nfunction compareIndexMap(indexMap, itemA, itemB) {\n  var indexA = indexMap[itemA._id];\n  var indexB = indexMap[itemB._id];\n  return indexA - indexB;\n}\n\nexport default Grid;","map":{"version":3,"sources":["D:/MyGitHub/muuri-example/node_modules/muuri/dist/muuri.module.js"],"names":["GRID_INSTANCES","ITEM_ELEMENT_MAP","Map","ACTION_SWAP","ACTION_MOVE","EVENT_SYNCHRONIZE","EVENT_LAYOUT_START","EVENT_LAYOUT_END","EVENT_LAYOUT_ABORT","EVENT_ADD","EVENT_REMOVE","EVENT_SHOW_START","EVENT_SHOW_END","EVENT_HIDE_START","EVENT_HIDE_END","EVENT_FILTER","EVENT_SORT","EVENT_MOVE","EVENT_SEND","EVENT_BEFORE_SEND","EVENT_RECEIVE","EVENT_BEFORE_RECEIVE","EVENT_DRAG_INIT","EVENT_DRAG_START","EVENT_DRAG_MOVE","EVENT_DRAG_SCROLL","EVENT_DRAG_END","EVENT_DRAG_RELEASE_START","EVENT_DRAG_RELEASE_END","EVENT_DESTROY","HAS_TOUCH_EVENTS","window","HAS_POINTER_EVENTS","PointerEvent","HAS_MS_POINTER_EVENTS","navigator","msPointerEnabled","MAX_SAFE_FLOAT32_INTEGER","Emitter","_events","_queue","_counter","_clearOnEmit","prototype","on","event","listener","listeners","push","off","length","index","indexOf","splice","clear","emit","queue","startIndex","argsLength","arguments","args","apply","shift","i","endIndex","burst","countListeners","destroy","pointerout","waitDuration","EdgeHack","dragger","_dragger","_timeout","_outEvent","_isActive","_addBehaviour","bind","_removeBehaviour","_onTimeout","_resetData","_onStart","_onOut","addEventListener","removeEventListener","clearTimeout","e","pointerType","_getTrackedTouch","setTimeout","isActive","_onCancel","vendorPrefixes","cache$2","getPrefixedPropName","style","prop","prefixedProp","camelProp","toUpperCase","slice","hasPassiveEvents","isPassiveEventsSupported","passiveOpts","Object","defineProperty","get","ua","userAgent","toLowerCase","isEdge","isIE","isFirefox","isAndroid","listenerOptions","passive","taProp","taPropPrefixed","document","documentElement","taDefaultValue","Dragger","element","cssProps","_element","_emitter","_isDestroyed","_cssProps","_touchAction","_pointerId","_startTime","_startX","_startY","_currentX","_currentY","_onMove","_onEnd","_edgeHack","setCssProps","setTouchAction","_preventDefault","_inputEvents","start","_pointerEvents","move","cancel","end","_msPointerEvents","_touchEvents","_mouseEvents","_emitterEvents","_activeInstances","preventDefault","cancelable","_activateInstance","instance","_bindListeners","_deactivateInstance","_unbindListeners","_getEventPointerId","pointerId","changedTouches","identifier","_getTouchById","id","_reset","_createEvent","type","touch","srcEvent","distance","getDistance","deltaX","getDeltaX","deltaY","getDeltaY","deltaTime","getDeltaTime","isFirst","isFinal","touches","screenX","screenY","clientX","clientY","pageX","pageY","target","_emit","Date","now","value","newProps","currentProps","x","y","Math","sqrt","eventName","dt","raf","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","callback","Ticker","numLanes","_nextStep","_lanes","_stepQueue","_stepCallbacks","_step","TickerLane","time","lanes","stepQueue","stepCallbacks","j","laneQueue","laneCallbacks","laneIndices","callbacks","indices","add","laneIndex","remove","undefined","LAYOUT_READ","LAYOUT_WRITE","VISIBILITY_READ","VISIBILITY_WRITE","DRAG_START_READ","DRAG_START_WRITE","DRAG_MOVE_READ","DRAG_MOVE_WRITE","DRAG_SCROLL_READ","DRAG_SCROLL_WRITE","DRAG_SORT_READ","PLACEHOLDER_LAYOUT_READ","PLACEHOLDER_LAYOUT_WRITE","PLACEHOLDER_RESIZE_WRITE","AUTO_SCROLL_READ","AUTO_SCROLL_WRITE","DEBOUNCE_READ","LANE_READ","LANE_READ_TAIL","LANE_WRITE","ticker","addLayoutTick","itemId","read","write","cancelLayoutTick","addVisibilityTick","cancelVisibilityTick","addDragStartTick","cancelDragStartTick","addDragMoveTick","cancelDragMoveTick","addDragScrollTick","cancelDragScrollTick","addDragSortTick","cancelDragSortTick","addPlaceholderLayoutTick","cancelPlaceholderLayoutTick","addPlaceholderResizeTick","cancelPlaceholderResizeTick","addAutoScrollTick","cancelAutoScrollTick","addDebounceTick","debounceId","cancelDebounceTick","AXIS_X","AXIS_Y","FORWARD","BACKWARD","LEFT","RIGHT","UP","DOWN","functionType","isFunction","val","cache$1","WeakMap","getStyle","styles","getComputedStyle","set","getPropertyValue","getStyleAsFloat","el","parseFloat","DOC_ELEM","BODY","body","THRESHOLD_DATA","offset","getScrollElement","getScrollLeft","pageXOffset","scrollLeft","getScrollTop","pageYOffset","scrollTop","getScrollLeftMax","scrollWidth","clientWidth","getScrollTopMax","scrollHeight","clientHeight","getContentRect","result","width","height","left","right","top","bottom","bcr","getBoundingClientRect","borderLeft","clientLeft","borderTop","clientTop","getItemAutoScrollSettings","item","_drag","_getGrid","_settings","dragAutoScroll","prepareItemScrollSync","_prepareScroll","applyItemScrollSync","drag","_scrollDiffX","_scrollDiffY","_setTranslate","_left","_top","computeThreshold","threshold","safeZone","itemSize","targetSize","min","max","ScrollRequest","reset","onStop","isEnding","direction","maxValue","speed","duration","action","hasReachedEnd","computeCurrentScrollValue","computeNextScrollValue","delta","nextValue","computeSpeed","data","tick","onStart","sort","ScrollAction","requestX","requestY","addRequest","request","removeRequest","computeScrollValues","scroll","scrollTo","Pool","createItem","releaseItem","pool","pick","pop","release","isOverlapping","a","b","getIntersectionArea","getIntersectionScore","area","maxArea","RECT_1","RECT_2","AutoScroller","_isTicking","_tickTime","_tickDeltaTime","_items","_actions","_requests","_requestOverlapCheck","_dragPositions","_dragDirections","_overlapCheckInterval","_requestPool","_actionPool","_readTick","_writeTick","smoothSpeed","maxSpeed","acceleration","deceleration","targetSpeed","factor","currentSpeed","nextSpeed","pointerHandle","pointerSize","rect","size","w","h","pX","pY","_updateRequests","_updateActions","_applyActions","_startTicking","_stopTicking","_getItemHandleRect","handle","itemDrag","ev","_dragMoveEvent","_dragStartEvent","_clientX","_clientY","_width","_height","_requestItemScroll","axis","reqMap","_id","_cancelItemScroll","_checkItemOverlap","checkX","checkY","settings","targets","dragDirections","dragDirectionX","dragDirectionY","itemRect","testRect","testElement","testAxisX","testAxisY","testScore","testPriority","testThreshold","testDirection","testDistance","testMaxScrollX","testMaxScrollY","xElement","xPriority","Infinity","xThreshold","xScore","xDirection","xDistance","xMaxScroll","yElement","yPriority","yThreshold","yScore","yDirection","yDistance","yMaxScroll","priority","_updateScrollRequest","scrollRequest","targetCount","testIsAxisX","testScroll","testMaxScroll","smoothStop","items","requestsX","requestsY","reqX","reqY","checkTime","needsCheck","_requestAction","actions","isAxisX","requests","_updateDragDirection","dragPositions","x1","y1","x2","y2","addItem","updateItem","removeItem","isItemScrollingX","isItemScrollingY","isItemScrolling","ElProto","Element","matchesFn","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","elementMatches","selector","call","addClass","className","classList","tempArray","numberType","arrayInsert","array","concat","normalizeArrayIndex","sizeOffset","maxIndex","arrayMove","fromIndex","toIndex","from","to","arraySwap","withIndex","indexA","indexB","temp","transformProp","styleNameRegEx","prefixRegex","msPrefixRegex","getStyleName","property","styleName","replace","transformStyle","transformNone$1","displayInline","displayNone","displayStyle","isTransformed","transform","display","getContainingBlock","doc","res","parentElement","offsetA","offsetB","offsetDiff","getOffset","offsetData","self","getOffsetDiff","elemA","elemB","compareContainingBlocks","isScrollableOverflow","isScrollable","getScrollableAncestors","getRootNode","DocumentFragment","host","parentNode","translateValue","transformNone","rxMat3d","rxMatTx","rxMat3dTx","rxNextItem","getTranslate","isMat3d","test","tX","tY","removeClass","trim","IS_IOS","platform","maxTouchPoints","START_PREDICATE_INACTIVE","START_PREDICATE_PENDING","START_PREDICATE_RESOLVED","SCROLL_LISTENER_OPTIONS","ItemDrag","grid","getGrid","_item","_gridId","_isMigrating","_startPredicate","dragStartPredicate","defaultStartPredicate","_startPredicateState","_startPredicateResult","_isSortNeeded","_sortTimer","_blockedSortIndex","_sortX1","_sortX2","_sortY1","_sortY2","_preStartCheck","_preEndCheck","_onScroll","_prepareStart","_applyStart","_prepareMove","_applyMove","_applyScroll","_handleSort","_handleSortDelayed","_handle","dragHandle","querySelector","dragCssProps","autoScroller","options","button","isTrusted","defaultPrevented","_finishStartPredicate","predicate","_startPredicateData","config","delay","delayTimer","_resolveStartPredicate","_forceResolveStartPredicate","_resetStartPredicate","defaultSortPredicate","targetRect","returnData","gridsArray","minThreshold","maxThreshold","getTargetGrid","rootGrid","dragSort","bestScore","gridScore","grids","container","containerRect","Array","isArray","_updateBoundingRect","innerWidth","_right","innerHeight","_bottom","sortThreshold","sortAction","migrateAction","isMigration","gridOffsetLeft","gridOffsetTop","matchScore","matchIndex","hasValidTargets","score","_gridX","_marginLeft","_gridY","_marginTop","_updateBorders","_borderLeft","_borderTop","stop","_finishMigration","_cancelSort","_isStarted","_unbindScrollListeners","draggingClass","itemDraggingClass","appendChild","force","_container","_containingBlock","_dragPrevMoveEvent","_scrollEvent","_scrollers","_moveDiffX","_moveDiffY","_containerDiffX","_containerDiffY","_bindScrollListeners","gridContainer","dragContainer","scrollers","gridScrollers","isClick","abs","openAnchorHref","_resetHeuristics","_checkHeuristics","dragSortHeuristics","minDist","minDragDistance","diffX","diffY","canCheckBounceBack","minBounceBackAngle","angle","atan2","prevAngle","deltaAngle","sin","cos","sortDuringScroll","shouldSort","sortInterval","_checkOverlap","_finishSort","isSortEnabled","needsFinalCheck","currentGrid","currentIndex","targetGrid","targetIndex","targetItem","dragSortPredicate","_hasListeners","layout","fromGrid","toGrid","_sortData","send","appendTo","layoutSender","layoutReceiver","_dragRelease","targetGridElement","targetSettings","targetContainer","currentSettings","currentContainer","currentVisClass","itemVisibleClass","itemHiddenClass","nextVisClass","translate","itemClass","_refreshDimensions","dragEnabled","_visibility","setStyles","visibleStyles","hiddenStyles","isResolved","containingBlock","elementRect","hasDragContainer","migrate","_migrate","isPositioning","_layout","isReleasing","dragPlaceholder","enabled","_dragPlaceholder","create","dragAxis","nextEvent","prevEvent","moveDiffX","moveDiffY","scrollDiffX","scrollDiffY","tagName","href","getAttribute","open","location","getCurrentStyles","unprefixRegEx","cache","getUnprefixedPropName","nativeCode","isNative","feat","S","Symbol","toString","HAS_WEB_ANIMATIONS","animate","HAS_NATIVE_WEB_ANIMATIONS","Animator","_animation","_duration","_easing","_callback","_props","_values","_onFinish","propsFrom","propsTo","opts","onFinish","animation","currentValues","easing","cancelAnimation","propName","propCount","propIndex","createFrame","onfinish","isAnimating","props","prefix","frame","getTranslateString","ItemDragPlaceholder","_className","_didMigrate","_resetAfterLayout","_transX","_transY","_nextTransX","_nextTransY","_setupAnimation","_startAnimation","_updateDimensions","_onLayoutStart","_onLayoutEnd","_onReleaseEnd","_onMigrate","_onHide","isInstant","nextLeft","nextTop","currentLeft","currentTop","nextX","nextY","animEnabled","layoutDuration","getElement","currentX","currentY","currentStyles","targetStyles","layoutEasing","nextGrid","createElement","itemPlaceholderClass","position","onCreate","removeChild","onRemove","updateDimensions","ItemDragRelease","_isPositioningStarted","itemReleasingClass","dragRelease","useDragContainer","_placeToGrid","_nextLayoutData","abort","didReparent","isJustReleased","needsReflow","releasingClass","MIN_ANIMATION_DISTANCE","ItemLayout","elementStyle","_isInterrupted","_currentStyles","_targetStyles","_nextLeft","_nextTop","_offsetLeft","_offsetTop","_skipNextAnimation","_animOptions","_finish","instant","gridSettings","animDuration","animEasing","_updateOffsets","processCallbackQueue","itemPositioningClass","_tX","_tY","xDiff","yDiff","ItemMigrate","isVisible","targetElement","targetItems","containerDiff","translateX","translateY","getItem","gridElement","ItemVisibility","childElement","children","Error","_isHidden","_isHiding","_isShowing","_childElement","_currentStyleProps","_finishShow","_finishHide","show","hide","currentStyleProps","_removeCurrentStyles","toVisible","showDuration","hideDuration","showEasing","hideEasing","createUid","Item","has","_marginRight","_marginBottom","getWidth","getHeight","getMargin","getPosition","isShowing","isHiding","isDragging","isDestroyed","_refreshSortData","getters","sortData","_addToLayout","_removeFromLayout","_canSkipLayout","_destroy","removeElement","delete","createPackerProcessor","isWorker","FILL_GAPS","HORIZONTAL","ALIGN_RIGHT","ALIGN_BOTTOM","ROUNDING","EPS","MIN_SLOT_SIZE","roundNumber","number","PackerProcessor","currentRects","nextRects","rectTarget","rectStore","slotSizes","rectId","slotIndex","slotData","sortRectsLeftTop","sortRectsTopLeft","computeLayout","slots","fillGaps","horizontal","alignRight","alignBottom","rounding","isPreProcessed","bump","slotWidth","slotHeight","slot","computeNextSlot","ignoreCurrentRects","shards","getRect","addRect","splitRect","purgeRects","hole","isRectAWithinRectB","rectA","rectB","rectIds","aId","bId","PACKET_INDEX_WIDTH","PACKET_INDEX_HEIGHT","PACKET_INDEX_OPTIONS","PACKET_HEADER_SLOTS","processor","onmessage","msg","Float32Array","subarray","postMessage","buffer","blobUrl","activeWorkers","createWorkerProcessors","amount","workers","URL","createObjectURL","Blob","worker","Worker","destroyWorkerProcessors","onerror","onmessageerror","terminate","revokeObjectURL","isWorkerProcessorsSupported","PACKET_INDEX_ID","Packer","numWorkers","_options","_processor","_layoutQueue","_layouts","_layoutCallbacks","_layoutWorkers","_layoutWorkerData","_workers","_onWorkerMessage","setOptions","_sendToWorker","layoutId","_finalizeLayout","_grid","isHorizontal","isBorderBox","_boxSizing","_borderRight","_borderBottom","createLayout","cancelLayout","queueIndex","key","debounce","fn","durationMs","timer","lastTime","isCanceled","htmlCollectionType","nodeListType","isNodeList","objectType","objectToStringType","isPlainObject","noop","toArray","NUMBER_TYPE","STRING_TYPE","INSTANT_LAYOUT","Grid","isElementInDom","composed","contains","mergeSettings","defaultOptions","normalizeStyles","_isLayoutFinished","_onLayoutDataReceived","containerClass","bindLayoutOnResize","layoutOnResize","getInitialGridElements","layoutOnInit","defaultPacker","opacity","touchAction","userSelect","userDrag","tapHighlightColor","touchCallout","contentZooming","getItems","refreshItems","hiddenItemStyles","visibility","refreshSortData","synchronize","fragment","createDocumentFragment","unfinishedLayout","nextLayoutId","layoutItems","gridWidth","gridHeight","layoutSettings","elements","newItems","needsLayout","active","allItems","removeElements","_setItemsVisibility","filter","itemsToShow","itemsToHide","isPredicateString","isPredicateFn","syncWithLayout","tryFinishCounter","tryFinish","sortComparer","isDescending","origItems","indexMap","defaultComparer","criteriaName","criteriaOrder","valA","valB","createIndexMap","compareIndexMap","customComparer","comparer","descending","split","map","isSwap","fromItem","toItem","layoutStyles","unbindLayoutOnResize","itemsToLayout","numItems","counter","hasLayoutChanged","startEvent","endEvent","method","completedItems","hiddenItems","triggerVisibilityChange","interrupted","defaultSettings","userSettings","mergeObjects","source","sourceKeys","keys","isSourceObject","_resizeHandler","normalized","docElemStyle","itemA","itemB"],"mappings":"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","sourcesContent":["/**\n* Muuri v0.9.5\n* https://muuri.dev/\n* Copyright (c) 2015-present, Haltu Oy\n* Released under the MIT license\n* https://github.com/haltu/muuri/blob/master/LICENSE.md\n* @license MIT\n*\n* Muuri Packer\n* Copyright (c) 2016-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri Ticker / Muuri Emitter / Muuri Dragger\n* Copyright (c) 2018-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*\n* Muuri AutoScroller\n* Copyright (c) 2019-present, Niklas Rämö <inramo@gmail.com>\n* @license MIT\n*/\n\nvar GRID_INSTANCES = {};\nvar ITEM_ELEMENT_MAP = typeof Map === 'function' ? new Map() : null;\n\nvar ACTION_SWAP = 'swap';\nvar ACTION_MOVE = 'move';\n\nvar EVENT_SYNCHRONIZE = 'synchronize';\nvar EVENT_LAYOUT_START = 'layoutStart';\nvar EVENT_LAYOUT_END = 'layoutEnd';\nvar EVENT_LAYOUT_ABORT = 'layoutAbort';\nvar EVENT_ADD = 'add';\nvar EVENT_REMOVE = 'remove';\nvar EVENT_SHOW_START = 'showStart';\nvar EVENT_SHOW_END = 'showEnd';\nvar EVENT_HIDE_START = 'hideStart';\nvar EVENT_HIDE_END = 'hideEnd';\nvar EVENT_FILTER = 'filter';\nvar EVENT_SORT = 'sort';\nvar EVENT_MOVE = 'move';\nvar EVENT_SEND = 'send';\nvar EVENT_BEFORE_SEND = 'beforeSend';\nvar EVENT_RECEIVE = 'receive';\nvar EVENT_BEFORE_RECEIVE = 'beforeReceive';\nvar EVENT_DRAG_INIT = 'dragInit';\nvar EVENT_DRAG_START = 'dragStart';\nvar EVENT_DRAG_MOVE = 'dragMove';\nvar EVENT_DRAG_SCROLL = 'dragScroll';\nvar EVENT_DRAG_END = 'dragEnd';\nvar EVENT_DRAG_RELEASE_START = 'dragReleaseStart';\nvar EVENT_DRAG_RELEASE_END = 'dragReleaseEnd';\nvar EVENT_DESTROY = 'destroy';\n\nvar HAS_TOUCH_EVENTS = 'ontouchstart' in window;\nvar HAS_POINTER_EVENTS = !!window.PointerEvent;\nvar HAS_MS_POINTER_EVENTS = !!window.navigator.msPointerEnabled;\n\nvar MAX_SAFE_FLOAT32_INTEGER = 16777216;\n\n/**\n * Event emitter constructor.\n *\n * @class\n */\nfunction Emitter() {\n  this._events = {};\n  this._queue = [];\n  this._counter = 0;\n  this._clearOnEmit = false;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\nEmitter.prototype.on = function (event, listener) {\n  if (!this._events || !event || !listener) return this;\n\n  // Get listeners queue and create it if it does not exist.\n  var listeners = this._events[event];\n  if (!listeners) listeners = this._events[event] = [];\n\n  // Add the listener to the queue.\n  listeners.push(listener);\n\n  return this;\n};\n\n/**\n * Unbind all event listeners that match the provided listener function.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Emitter}\n */\nEmitter.prototype.off = function (event, listener) {\n  if (!this._events || !event || !listener) return this;\n\n  // Get listeners and return immediately if none is found.\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) return this;\n\n  // Remove all matching listeners.\n  var index;\n  while ((index = listeners.indexOf(listener)) !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  return this;\n};\n\n/**\n * Unbind all listeners of the provided event.\n *\n * @public\n * @param {String} event\n * @returns {Emitter}\n */\nEmitter.prototype.clear = function (event) {\n  if (!this._events || !event) return this;\n\n  var listeners = this._events[event];\n  if (listeners) {\n    listeners.length = 0;\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Emit all listeners in a specified event with the provided arguments.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\nEmitter.prototype.emit = function (event) {\n  if (!this._events || !event) {\n    this._clearOnEmit = false;\n    return this;\n  }\n\n  // Get event listeners and quit early if there's no listeners.\n  var listeners = this._events[event];\n  if (!listeners || !listeners.length) {\n    this._clearOnEmit = false;\n    return this;\n  }\n\n  var queue = this._queue;\n  var startIndex = queue.length;\n  var argsLength = arguments.length - 1;\n  var args;\n\n  // If we have more than 3 arguments let's put the arguments in an array and\n  // apply it to the listeners.\n  if (argsLength > 3) {\n    args = [];\n    args.push.apply(args, arguments);\n    args.shift();\n  }\n\n  // Add the current listeners to the callback queue before we process them.\n  // This is necessary to guarantee that all of the listeners are called in\n  // correct order even if new event listeners are removed/added during\n  // processing and/or events are emitted during processing.\n  queue.push.apply(queue, listeners);\n\n  // Reset the event's listeners if need be.\n  if (this._clearOnEmit) {\n    listeners.length = 0;\n    this._clearOnEmit = false;\n  }\n\n  // Increment queue counter. This is needed for the scenarios where emit is\n  // triggered while the queue is already processing. We need to keep track of\n  // how many \"queue processors\" there are active so that we can safely reset\n  // the queue in the end when the last queue processor is finished.\n  ++this._counter;\n\n  // Process the queue (the specific part of it for this emit).\n  var i = startIndex;\n  var endIndex = queue.length;\n  for (; i < endIndex; i++) {\n    // prettier-ignore\n    argsLength === 0 ? queue[i]() :\n    argsLength === 1 ? queue[i](arguments[1]) :\n    argsLength === 2 ? queue[i](arguments[1], arguments[2]) :\n    argsLength === 3 ? queue[i](arguments[1], arguments[2], arguments[3]) :\n                       queue[i].apply(null, args);\n\n    // Stop processing if the emitter is destroyed.\n    if (!this._events) return this;\n  }\n\n  // Decrement queue process counter.\n  --this._counter;\n\n  // Reset the queue if there are no more queue processes running.\n  if (!this._counter) queue.length = 0;\n\n  return this;\n};\n\n/**\n * Emit all listeners in a specified event with the provided arguments and\n * remove the event's listeners just before calling the them. This method allows\n * the emitter to serve as a queue where all listeners are called only once.\n *\n * @public\n * @param {String} event\n * @param {...*} [args]\n * @returns {Emitter}\n */\nEmitter.prototype.burst = function () {\n  if (!this._events) return this;\n  this._clearOnEmit = true;\n  this.emit.apply(this, arguments);\n  return this;\n};\n\n/**\n * Check how many listeners there are for a specific event.\n *\n * @public\n * @param {String} event\n * @returns {Boolean}\n */\nEmitter.prototype.countListeners = function (event) {\n  if (!this._events) return 0;\n  var listeners = this._events[event];\n  return listeners ? listeners.length : 0;\n};\n\n/**\n * Destroy emitter instance. Basically just removes all bound listeners.\n *\n * @public\n * @returns {Emitter}\n */\nEmitter.prototype.destroy = function () {\n  if (!this._events) return this;\n  this._queue.length = this._counter = 0;\n  this._events = null;\n  return this;\n};\n\nvar pointerout = HAS_POINTER_EVENTS ? 'pointerout' : HAS_MS_POINTER_EVENTS ? 'MSPointerOut' : '';\nvar waitDuration = 100;\n\n/**\n * If you happen to use Edge or IE on a touch capable device there is a\n * a specific case where pointercancel and pointerend events are never emitted,\n * even though one them should always be emitted when you release your finger\n * from the screen. The bug appears specifically when Muuri shifts the dragged\n * element's position in the DOM after pointerdown event, IE and Edge don't like\n * that behaviour and quite often forget to emit the pointerend/pointercancel\n * event. But, they do emit pointerout event so we utilize that here.\n * Specifically, if there has been no pointermove event within 100 milliseconds\n * since the last pointerout event we force cancel the drag operation. This hack\n * works surprisingly well 99% of the time. There is that 1% chance there still\n * that dragged items get stuck but it is what it is.\n *\n * @class\n * @param {Dragger} dragger\n */\nfunction EdgeHack(dragger) {\n  if (!pointerout) return;\n\n  this._dragger = dragger;\n  this._timeout = null;\n  this._outEvent = null;\n  this._isActive = false;\n\n  this._addBehaviour = this._addBehaviour.bind(this);\n  this._removeBehaviour = this._removeBehaviour.bind(this);\n  this._onTimeout = this._onTimeout.bind(this);\n  this._resetData = this._resetData.bind(this);\n  this._onStart = this._onStart.bind(this);\n  this._onOut = this._onOut.bind(this);\n\n  this._dragger.on('start', this._onStart);\n}\n\n/**\n * @private\n */\nEdgeHack.prototype._addBehaviour = function () {\n  if (this._isActive) return;\n  this._isActive = true;\n  this._dragger.on('move', this._resetData);\n  this._dragger.on('cancel', this._removeBehaviour);\n  this._dragger.on('end', this._removeBehaviour);\n  window.addEventListener(pointerout, this._onOut);\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._removeBehaviour = function () {\n  if (!this._isActive) return;\n  this._dragger.off('move', this._resetData);\n  this._dragger.off('cancel', this._removeBehaviour);\n  this._dragger.off('end', this._removeBehaviour);\n  window.removeEventListener(pointerout, this._onOut);\n  this._resetData();\n  this._isActive = false;\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._resetData = function () {\n  window.clearTimeout(this._timeout);\n  this._timeout = null;\n  this._outEvent = null;\n};\n\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nEdgeHack.prototype._onStart = function (e) {\n  if (e.pointerType === 'mouse') return;\n  this._addBehaviour();\n};\n\n/**\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nEdgeHack.prototype._onOut = function (e) {\n  if (!this._dragger._getTrackedTouch(e)) return;\n  this._resetData();\n  this._outEvent = e;\n  this._timeout = window.setTimeout(this._onTimeout, waitDuration);\n};\n\n/**\n * @private\n */\nEdgeHack.prototype._onTimeout = function () {\n  var e = this._outEvent;\n  this._resetData();\n  if (this._dragger.isActive()) this._dragger._onCancel(e);\n};\n\n/**\n * @public\n */\nEdgeHack.prototype.destroy = function () {\n  if (!pointerout) return;\n  this._dragger.off('start', this._onStart);\n  this._removeBehaviour();\n};\n\n// Playing it safe here, test all potential prefixes capitalized and lowercase.\nvar vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o', 'Webkit', 'Moz', 'MS', 'O'];\nvar cache$2 = {};\n\n/**\n * Get prefixed CSS property name when given a non-prefixed CSS property name.\n * Returns null if the property is not supported at all.\n *\n * @param {CSSStyleDeclaration} style\n * @param {String} prop\n * @returns {String}\n */\nfunction getPrefixedPropName(style, prop) {\n  var prefixedProp = cache$2[prop] || '';\n  if (prefixedProp) return prefixedProp;\n\n  var camelProp = prop[0].toUpperCase() + prop.slice(1);\n  var i = 0;\n  while (i < vendorPrefixes.length) {\n    prefixedProp = vendorPrefixes[i] ? vendorPrefixes[i] + camelProp : prop;\n    if (prefixedProp in style) {\n      cache$2[prop] = prefixedProp;\n      return prefixedProp;\n    }\n    ++i;\n  }\n\n  return '';\n}\n\n/**\n * Check if passive events are supported.\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n *\n * @returns {Boolean}\n */\nfunction hasPassiveEvents() {\n  var isPassiveEventsSupported = false;\n\n  try {\n    var passiveOpts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        isPassiveEventsSupported = true;\n      },\n    });\n    window.addEventListener('testPassive', null, passiveOpts);\n    window.removeEventListener('testPassive', null, passiveOpts);\n  } catch (e) {}\n\n  return isPassiveEventsSupported;\n}\n\nvar ua = window.navigator.userAgent.toLowerCase();\nvar isEdge = ua.indexOf('edge') > -1;\nvar isIE = ua.indexOf('trident') > -1;\nvar isFirefox = ua.indexOf('firefox') > -1;\nvar isAndroid = ua.indexOf('android') > -1;\n\nvar listenerOptions = hasPassiveEvents() ? { passive: true } : false;\n\nvar taProp = 'touchAction';\nvar taPropPrefixed = getPrefixedPropName(document.documentElement.style, taProp);\nvar taDefaultValue = 'auto';\n\n/**\n * Creates a new Dragger instance for an element.\n *\n * @public\n * @class\n * @param {HTMLElement} element\n * @param {Object} [cssProps]\n */\nfunction Dragger(element, cssProps) {\n  this._element = element;\n  this._emitter = new Emitter();\n  this._isDestroyed = false;\n  this._cssProps = {};\n  this._touchAction = '';\n  this._isActive = false;\n\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n\n  this._onStart = this._onStart.bind(this);\n  this._onMove = this._onMove.bind(this);\n  this._onCancel = this._onCancel.bind(this);\n  this._onEnd = this._onEnd.bind(this);\n\n  // Can't believe had to build a freaking class for a hack!\n  this._edgeHack = null;\n  if ((isEdge || isIE) && (HAS_POINTER_EVENTS || HAS_MS_POINTER_EVENTS)) {\n    this._edgeHack = new EdgeHack(this);\n  }\n\n  // Apply initial CSS props.\n  this.setCssProps(cssProps);\n\n  // If touch action was not provided with initial CSS props let's assume it's\n  // auto.\n  if (!this._touchAction) {\n    this.setTouchAction(taDefaultValue);\n  }\n\n  // Prevent native link/image dragging for the item and it's children.\n  element.addEventListener('dragstart', Dragger._preventDefault, false);\n\n  // Listen to start event.\n  element.addEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n}\n\n/**\n * Protected properties\n * ********************\n */\n\nDragger._pointerEvents = {\n  start: 'pointerdown',\n  move: 'pointermove',\n  cancel: 'pointercancel',\n  end: 'pointerup',\n};\n\nDragger._msPointerEvents = {\n  start: 'MSPointerDown',\n  move: 'MSPointerMove',\n  cancel: 'MSPointerCancel',\n  end: 'MSPointerUp',\n};\n\nDragger._touchEvents = {\n  start: 'touchstart',\n  move: 'touchmove',\n  cancel: 'touchcancel',\n  end: 'touchend',\n};\n\nDragger._mouseEvents = {\n  start: 'mousedown',\n  move: 'mousemove',\n  cancel: '',\n  end: 'mouseup',\n};\n\nDragger._inputEvents = (function () {\n  if (HAS_TOUCH_EVENTS) return Dragger._touchEvents;\n  if (HAS_POINTER_EVENTS) return Dragger._pointerEvents;\n  if (HAS_MS_POINTER_EVENTS) return Dragger._msPointerEvents;\n  return Dragger._mouseEvents;\n})();\n\nDragger._emitter = new Emitter();\n\nDragger._emitterEvents = {\n  start: 'start',\n  move: 'move',\n  end: 'end',\n  cancel: 'cancel',\n};\n\nDragger._activeInstances = [];\n\n/**\n * Protected static methods\n * ************************\n */\n\nDragger._preventDefault = function (e) {\n  if (e.preventDefault && e.cancelable !== false) e.preventDefault();\n};\n\nDragger._activateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n  if (index > -1) return;\n\n  Dragger._activeInstances.push(instance);\n  Dragger._emitter.on(Dragger._emitterEvents.move, instance._onMove);\n  Dragger._emitter.on(Dragger._emitterEvents.cancel, instance._onCancel);\n  Dragger._emitter.on(Dragger._emitterEvents.end, instance._onEnd);\n\n  if (Dragger._activeInstances.length === 1) {\n    Dragger._bindListeners();\n  }\n};\n\nDragger._deactivateInstance = function (instance) {\n  var index = Dragger._activeInstances.indexOf(instance);\n  if (index === -1) return;\n\n  Dragger._activeInstances.splice(index, 1);\n  Dragger._emitter.off(Dragger._emitterEvents.move, instance._onMove);\n  Dragger._emitter.off(Dragger._emitterEvents.cancel, instance._onCancel);\n  Dragger._emitter.off(Dragger._emitterEvents.end, instance._onEnd);\n\n  if (!Dragger._activeInstances.length) {\n    Dragger._unbindListeners();\n  }\n};\n\nDragger._bindListeners = function () {\n  window.addEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.addEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n  if (Dragger._inputEvents.cancel) {\n    window.addEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\n\nDragger._unbindListeners = function () {\n  window.removeEventListener(Dragger._inputEvents.move, Dragger._onMove, listenerOptions);\n  window.removeEventListener(Dragger._inputEvents.end, Dragger._onEnd, listenerOptions);\n  if (Dragger._inputEvents.cancel) {\n    window.removeEventListener(Dragger._inputEvents.cancel, Dragger._onCancel, listenerOptions);\n  }\n};\n\nDragger._getEventPointerId = function (event) {\n  // If we have pointer id available let's use it.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId;\n  }\n\n  // For touch events let's get the first changed touch's identifier.\n  if (event.changedTouches) {\n    return event.changedTouches[0] ? event.changedTouches[0].identifier : null;\n  }\n\n  // For mouse/other events let's provide a static id.\n  return 1;\n};\n\nDragger._getTouchById = function (event, id) {\n  // If we have a pointer event return the whole event if there's a match, and\n  // null otherwise.\n  if (typeof event.pointerId === 'number') {\n    return event.pointerId === id ? event : null;\n  }\n\n  // For touch events let's check if there's a changed touch object that matches\n  // the pointerId in which case return the touch object.\n  if (event.changedTouches) {\n    for (var i = 0; i < event.changedTouches.length; i++) {\n      if (event.changedTouches[i].identifier === id) {\n        return event.changedTouches[i];\n      }\n    }\n    return null;\n  }\n\n  // For mouse/other events let's assume there's only one pointer and just\n  // return the event.\n  return event;\n};\n\nDragger._onMove = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.move, e);\n};\n\nDragger._onCancel = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.cancel, e);\n};\n\nDragger._onEnd = function (e) {\n  Dragger._emitter.emit(Dragger._emitterEvents.end, e);\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Reset current drag operation (if any).\n *\n * @private\n */\nDragger.prototype._reset = function () {\n  this._pointerId = null;\n  this._startTime = 0;\n  this._startX = 0;\n  this._startY = 0;\n  this._currentX = 0;\n  this._currentY = 0;\n  this._isActive = false;\n  Dragger._deactivateInstance(this);\n};\n\n/**\n * Create a custom dragger event from a raw event.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {Object}\n */\nDragger.prototype._createEvent = function (type, e) {\n  var touch = this._getTrackedTouch(e);\n  return {\n    // Hammer.js compatibility interface.\n    type: type,\n    srcEvent: e,\n    distance: this.getDistance(),\n    deltaX: this.getDeltaX(),\n    deltaY: this.getDeltaY(),\n    deltaTime: type === Dragger._emitterEvents.start ? 0 : this.getDeltaTime(),\n    isFirst: type === Dragger._emitterEvents.start,\n    isFinal: type === Dragger._emitterEvents.end || type === Dragger._emitterEvents.cancel,\n    pointerType: e.pointerType || (e.touches ? 'touch' : 'mouse'),\n    // Partial Touch API interface.\n    identifier: this._pointerId,\n    screenX: touch.screenX,\n    screenY: touch.screenY,\n    clientX: touch.clientX,\n    clientY: touch.clientY,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    target: touch.target,\n  };\n};\n\n/**\n * Emit a raw event as dragger event internally.\n *\n * @private\n * @param {String} type\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._emit = function (type, e) {\n  this._emitter.emit(type, this._createEvent(type, e));\n};\n\n/**\n * If the provided event is a PointerEvent this method will return it if it has\n * the same pointerId as the instance. If the provided event is a TouchEvent\n * this method will try to look for a Touch instance in the changedTouches that\n * has an identifier matching this instance's pointerId. If the provided event\n * is a MouseEvent (or just any other event than PointerEvent or TouchEvent)\n * it will be returned immediately.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n * @returns {?(Touch|PointerEvent|MouseEvent)}\n */\nDragger.prototype._getTrackedTouch = function (e) {\n  if (this._pointerId === null) return null;\n  return Dragger._getTouchById(e, this._pointerId);\n};\n\n/**\n * Handler for start event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onStart = function (e) {\n  if (this._isDestroyed) return;\n\n  // If pointer id is already assigned let's return early.\n  if (this._pointerId !== null) return;\n\n  // Get (and set) pointer id.\n  this._pointerId = Dragger._getEventPointerId(e);\n  if (this._pointerId === null) return;\n\n  // Setup initial data and emit start event.\n  var touch = this._getTrackedTouch(e);\n  this._startX = this._currentX = touch.clientX;\n  this._startY = this._currentY = touch.clientY;\n  this._startTime = Date.now();\n  this._isActive = true;\n  this._emit(Dragger._emitterEvents.start, e);\n\n  // If the drag procedure was not reset within the start procedure let's\n  // activate the instance (start listening to move/cancel/end events).\n  if (this._isActive) {\n    Dragger._activateInstance(this);\n  }\n};\n\n/**\n * Handler for move event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onMove = function (e) {\n  var touch = this._getTrackedTouch(e);\n  if (!touch) return;\n  this._currentX = touch.clientX;\n  this._currentY = touch.clientY;\n  this._emit(Dragger._emitterEvents.move, e);\n};\n\n/**\n * Handler for cancel event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onCancel = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n  this._emit(Dragger._emitterEvents.cancel, e);\n  this._reset();\n};\n\n/**\n * Handler for end event.\n *\n * @private\n * @param {(PointerEvent|TouchEvent|MouseEvent)} e\n */\nDragger.prototype._onEnd = function (e) {\n  if (!this._getTrackedTouch(e)) return;\n  this._emit(Dragger._emitterEvents.end, e);\n  this._reset();\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Check if the element is being dragged at the moment.\n *\n * @public\n * @returns {Boolean}\n */\nDragger.prototype.isActive = function () {\n  return this._isActive;\n};\n\n/**\n * Set element's touch-action CSS property.\n *\n * @public\n * @param {String} value\n */\nDragger.prototype.setTouchAction = function (value) {\n  // Store unmodified touch action value (we trust user input here).\n  this._touchAction = value;\n\n  // Set touch-action style.\n  if (taPropPrefixed) {\n    this._cssProps[taPropPrefixed] = '';\n    this._element.style[taPropPrefixed] = value;\n  }\n\n  // If we have an unsupported touch-action value let's add a special listener\n  // that prevents default action on touch start event. A dirty hack, but best\n  // we can do for now. The other options would be to somehow polyfill the\n  // unsupported touch action behavior with custom heuristics which sounds like\n  // a can of worms. We do a special exception here for Firefox Android which's\n  // touch-action does not work properly if the dragged element is moved in the\n  // the DOM tree on touchstart.\n  if (HAS_TOUCH_EVENTS) {\n    this._element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    if (this._element.style[taPropPrefixed] !== value || (isFirefox && isAndroid)) {\n      this._element.addEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n    }\n  }\n};\n\n/**\n * Update element's CSS properties. Accepts an object with camel cased style\n * props with value pairs as it's first argument.\n *\n * @public\n * @param {Object} [newProps]\n */\nDragger.prototype.setCssProps = function (newProps) {\n  if (!newProps) return;\n\n  var currentProps = this._cssProps;\n  var element = this._element;\n  var prop;\n  var prefixedProp;\n\n  // Reset current props.\n  for (prop in currentProps) {\n    element.style[prop] = currentProps[prop];\n    delete currentProps[prop];\n  }\n\n  // Set new props.\n  for (prop in newProps) {\n    // Make sure we have a value for the prop.\n    if (!newProps[prop]) continue;\n\n    // Special handling for touch-action.\n    if (prop === taProp) {\n      this.setTouchAction(newProps[prop]);\n      continue;\n    }\n\n    // Get prefixed prop and skip if it does not exist.\n    prefixedProp = getPrefixedPropName(element.style, prop);\n    if (!prefixedProp) continue;\n\n    // Store the prop and add the style.\n    currentProps[prefixedProp] = '';\n    element.style[prefixedProp] = newProps[prop];\n  }\n};\n\n/**\n * How much the pointer has moved on x-axis from start position, in pixels.\n * Positive value indicates movement from left to right.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaX = function () {\n  return this._currentX - this._startX;\n};\n\n/**\n * How much the pointer has moved on y-axis from start position, in pixels.\n * Positive value indicates movement from top to bottom.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaY = function () {\n  return this._currentY - this._startY;\n};\n\n/**\n * How far (in pixels) has pointer moved from start position.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDistance = function () {\n  var x = this.getDeltaX();\n  var y = this.getDeltaY();\n  return Math.sqrt(x * x + y * y);\n};\n\n/**\n * How long has pointer been dragged.\n *\n * @public\n * @returns {Number}\n */\nDragger.prototype.getDeltaTime = function () {\n  return this._startTime ? Date.now() - this._startTime : 0;\n};\n\n/**\n * Bind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\nDragger.prototype.on = function (eventName, listener) {\n  this._emitter.on(eventName, listener);\n};\n\n/**\n * Unbind drag event listeners.\n *\n * @public\n * @param {String} eventName\n *   - 'start', 'move', 'cancel' or 'end'.\n * @param {Function} listener\n */\nDragger.prototype.off = function (eventName, listener) {\n  this._emitter.off(eventName, listener);\n};\n\n/**\n * Destroy the instance and unbind all drag event listeners.\n *\n * @public\n */\nDragger.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var element = this._element;\n\n  if (this._edgeHack) this._edgeHack.destroy();\n\n  // Reset data and deactivate the instance.\n  this._reset();\n\n  // Destroy emitter.\n  this._emitter.destroy();\n\n  // Unbind event handlers.\n  element.removeEventListener(Dragger._inputEvents.start, this._onStart, listenerOptions);\n  element.removeEventListener('dragstart', Dragger._preventDefault, false);\n  element.removeEventListener(Dragger._touchEvents.start, Dragger._preventDefault, true);\n\n  // Reset styles.\n  for (var prop in this._cssProps) {\n    element.style[prop] = this._cssProps[prop];\n    delete this._cssProps[prop];\n  }\n\n  // Reset data.\n  this._element = null;\n\n  // Mark as destroyed.\n  this._isDestroyed = true;\n};\n\nvar dt = 1000 / 60;\n\nvar raf = (\n  window.requestAnimationFrame ||\n  window.webkitRequestAnimationFrame ||\n  window.mozRequestAnimationFrame ||\n  window.msRequestAnimationFrame ||\n  function (callback) {\n    return this.setTimeout(function () {\n      callback(Date.now());\n    }, dt);\n  }\n).bind(window);\n\n/**\n * A ticker system for handling DOM reads and writes in an efficient way.\n *\n * @class\n */\nfunction Ticker(numLanes) {\n  this._nextStep = null;\n  this._lanes = [];\n  this._stepQueue = [];\n  this._stepCallbacks = {};\n  this._step = this._step.bind(this);\n  for (var i = 0; i < numLanes; i++) {\n    this._lanes.push(new TickerLane());\n  }\n}\n\nTicker.prototype._step = function (time) {\n  var lanes = this._lanes;\n  var stepQueue = this._stepQueue;\n  var stepCallbacks = this._stepCallbacks;\n  var i, j, id, laneQueue, laneCallbacks, laneIndices;\n\n  this._nextStep = null;\n\n  for (i = 0; i < lanes.length; i++) {\n    laneQueue = lanes[i].queue;\n    laneCallbacks = lanes[i].callbacks;\n    laneIndices = lanes[i].indices;\n    for (j = 0; j < laneQueue.length; j++) {\n      id = laneQueue[j];\n      if (!id) continue;\n      stepQueue.push(id);\n      stepCallbacks[id] = laneCallbacks[id];\n      delete laneCallbacks[id];\n      delete laneIndices[id];\n    }\n    laneQueue.length = 0;\n  }\n\n  for (i = 0; i < stepQueue.length; i++) {\n    id = stepQueue[i];\n    if (stepCallbacks[id]) stepCallbacks[id](time);\n    delete stepCallbacks[id];\n  }\n\n  stepQueue.length = 0;\n};\n\nTicker.prototype.add = function (laneIndex, id, callback) {\n  this._lanes[laneIndex].add(id, callback);\n  if (!this._nextStep) this._nextStep = raf(this._step);\n};\n\nTicker.prototype.remove = function (laneIndex, id) {\n  this._lanes[laneIndex].remove(id);\n};\n\n/**\n * A lane for ticker.\n *\n * @class\n */\nfunction TickerLane() {\n  this.queue = [];\n  this.indices = {};\n  this.callbacks = {};\n}\n\nTickerLane.prototype.add = function (id, callback) {\n  var index = this.indices[id];\n  if (index !== undefined) this.queue[index] = undefined;\n  this.queue.push(id);\n  this.callbacks[id] = callback;\n  this.indices[id] = this.queue.length - 1;\n};\n\nTickerLane.prototype.remove = function (id) {\n  var index = this.indices[id];\n  if (index === undefined) return;\n  this.queue[index] = undefined;\n  delete this.callbacks[id];\n  delete this.indices[id];\n};\n\nvar LAYOUT_READ = 'layoutRead';\nvar LAYOUT_WRITE = 'layoutWrite';\nvar VISIBILITY_READ = 'visibilityRead';\nvar VISIBILITY_WRITE = 'visibilityWrite';\nvar DRAG_START_READ = 'dragStartRead';\nvar DRAG_START_WRITE = 'dragStartWrite';\nvar DRAG_MOVE_READ = 'dragMoveRead';\nvar DRAG_MOVE_WRITE = 'dragMoveWrite';\nvar DRAG_SCROLL_READ = 'dragScrollRead';\nvar DRAG_SCROLL_WRITE = 'dragScrollWrite';\nvar DRAG_SORT_READ = 'dragSortRead';\nvar PLACEHOLDER_LAYOUT_READ = 'placeholderLayoutRead';\nvar PLACEHOLDER_LAYOUT_WRITE = 'placeholderLayoutWrite';\nvar PLACEHOLDER_RESIZE_WRITE = 'placeholderResizeWrite';\nvar AUTO_SCROLL_READ = 'autoScrollRead';\nvar AUTO_SCROLL_WRITE = 'autoScrollWrite';\nvar DEBOUNCE_READ = 'debounceRead';\n\nvar LANE_READ = 0;\nvar LANE_READ_TAIL = 1;\nvar LANE_WRITE = 2;\n\nvar ticker = new Ticker(3);\n\nfunction addLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, LAYOUT_WRITE + itemId, write);\n}\n\nfunction cancelLayoutTick(itemId) {\n  ticker.remove(LANE_READ, LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, LAYOUT_WRITE + itemId);\n}\n\nfunction addVisibilityTick(itemId, read, write) {\n  ticker.add(LANE_READ, VISIBILITY_READ + itemId, read);\n  ticker.add(LANE_WRITE, VISIBILITY_WRITE + itemId, write);\n}\n\nfunction cancelVisibilityTick(itemId) {\n  ticker.remove(LANE_READ, VISIBILITY_READ + itemId);\n  ticker.remove(LANE_WRITE, VISIBILITY_WRITE + itemId);\n}\n\nfunction addDragStartTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_START_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_START_WRITE + itemId, write);\n}\n\nfunction cancelDragStartTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_START_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_START_WRITE + itemId);\n}\n\nfunction addDragMoveTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_MOVE_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_MOVE_WRITE + itemId, write);\n}\n\nfunction cancelDragMoveTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_MOVE_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_MOVE_WRITE + itemId);\n}\n\nfunction addDragScrollTick(itemId, read, write) {\n  ticker.add(LANE_READ, DRAG_SCROLL_READ + itemId, read);\n  ticker.add(LANE_WRITE, DRAG_SCROLL_WRITE + itemId, write);\n}\n\nfunction cancelDragScrollTick(itemId) {\n  ticker.remove(LANE_READ, DRAG_SCROLL_READ + itemId);\n  ticker.remove(LANE_WRITE, DRAG_SCROLL_WRITE + itemId);\n}\n\nfunction addDragSortTick(itemId, read) {\n  ticker.add(LANE_READ_TAIL, DRAG_SORT_READ + itemId, read);\n}\n\nfunction cancelDragSortTick(itemId) {\n  ticker.remove(LANE_READ_TAIL, DRAG_SORT_READ + itemId);\n}\n\nfunction addPlaceholderLayoutTick(itemId, read, write) {\n  ticker.add(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId, read);\n  ticker.add(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId, write);\n}\n\nfunction cancelPlaceholderLayoutTick(itemId) {\n  ticker.remove(LANE_READ, PLACEHOLDER_LAYOUT_READ + itemId);\n  ticker.remove(LANE_WRITE, PLACEHOLDER_LAYOUT_WRITE + itemId);\n}\n\nfunction addPlaceholderResizeTick(itemId, write) {\n  ticker.add(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId, write);\n}\n\nfunction cancelPlaceholderResizeTick(itemId) {\n  ticker.remove(LANE_WRITE, PLACEHOLDER_RESIZE_WRITE + itemId);\n}\n\nfunction addAutoScrollTick(read, write) {\n  ticker.add(LANE_READ, AUTO_SCROLL_READ, read);\n  ticker.add(LANE_WRITE, AUTO_SCROLL_WRITE, write);\n}\n\nfunction cancelAutoScrollTick() {\n  ticker.remove(LANE_READ, AUTO_SCROLL_READ);\n  ticker.remove(LANE_WRITE, AUTO_SCROLL_WRITE);\n}\n\nfunction addDebounceTick(debounceId, read) {\n  ticker.add(LANE_READ, DEBOUNCE_READ + debounceId, read);\n}\n\nfunction cancelDebounceTick(debounceId) {\n  ticker.remove(LANE_READ, DEBOUNCE_READ + debounceId);\n}\n\nvar AXIS_X = 1;\nvar AXIS_Y = 2;\nvar FORWARD = 4;\nvar BACKWARD = 8;\nvar LEFT = AXIS_X | BACKWARD;\nvar RIGHT = AXIS_X | FORWARD;\nvar UP = AXIS_Y | BACKWARD;\nvar DOWN = AXIS_Y | FORWARD;\n\nvar functionType = 'function';\n\n/**\n * Check if a value is a function.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isFunction(val) {\n  return typeof val === functionType;\n}\n\nvar cache$1 = typeof WeakMap === 'function' ? new WeakMap() : null;\n\n/**\n * Returns the computed value of an element's style property as a string.\n *\n * @param {HTMLElement} element\n * @param {String} style\n * @returns {String}\n */\nfunction getStyle(element, style) {\n  var styles = cache$1 && cache$1.get(element);\n\n  if (!styles) {\n    styles = window.getComputedStyle(element, null);\n    if (cache$1) cache$1.set(element, styles);\n  }\n\n  return styles.getPropertyValue(style);\n}\n\n/**\n * Returns the computed value of an element's style property transformed into\n * a float value.\n *\n * @param {HTMLElement} el\n * @param {String} style\n * @returns {Number}\n */\nfunction getStyleAsFloat(el, style) {\n  return parseFloat(getStyle(el, style)) || 0;\n}\n\nvar DOC_ELEM = document.documentElement;\nvar BODY = document.body;\nvar THRESHOLD_DATA = { value: 0, offset: 0 };\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {HTMLElement|Window}\n */\nfunction getScrollElement(element) {\n  if (element === window || element === DOC_ELEM || element === BODY) {\n    return window;\n  } else {\n    return element;\n  }\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollLeft(element) {\n  return element === window ? element.pageXOffset : element.scrollLeft;\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollTop(element) {\n  return element === window ? element.pageYOffset : element.scrollTop;\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollLeftMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollWidth - DOC_ELEM.clientWidth;\n  } else {\n    return element.scrollWidth - element.clientWidth;\n  }\n}\n\n/**\n * @param {HTMLElement|Window} element\n * @returns {Number}\n */\nfunction getScrollTopMax(element) {\n  if (element === window) {\n    return DOC_ELEM.scrollHeight - DOC_ELEM.clientHeight;\n  } else {\n    return element.scrollHeight - element.clientHeight;\n  }\n}\n\n/**\n * Get window's or element's client rectangle data relative to the element's\n * content dimensions (includes inner size + padding, excludes scrollbars,\n * borders and margins).\n *\n * @param {HTMLElement|Window} element\n * @returns {Rectangle}\n */\nfunction getContentRect(element, result) {\n  result = result || {};\n\n  if (element === window) {\n    result.width = DOC_ELEM.clientWidth;\n    result.height = DOC_ELEM.clientHeight;\n    result.left = 0;\n    result.right = result.width;\n    result.top = 0;\n    result.bottom = result.height;\n  } else {\n    var bcr = element.getBoundingClientRect();\n    var borderLeft = element.clientLeft || getStyleAsFloat(element, 'border-left-width');\n    var borderTop = element.clientTop || getStyleAsFloat(element, 'border-top-width');\n    result.width = element.clientWidth;\n    result.height = element.clientHeight;\n    result.left = bcr.left + borderLeft;\n    result.right = result.left + result.width;\n    result.top = bcr.top + borderTop;\n    result.bottom = result.top + result.height;\n  }\n\n  return result;\n}\n\n/**\n * @param {Item} item\n * @returns {Object}\n */\nfunction getItemAutoScrollSettings(item) {\n  return item._drag._getGrid()._settings.dragAutoScroll;\n}\n\n/**\n * @param {Item} item\n */\nfunction prepareItemScrollSync(item) {\n  if (!item._drag) return;\n  item._drag._prepareScroll();\n}\n\n/**\n * @param {Item} item\n */\nfunction applyItemScrollSync(item) {\n  if (!item._drag || !item._isActive) return;\n  var drag = item._drag;\n  drag._scrollDiffX = drag._scrollDiffY = 0;\n  item._setTranslate(drag._left, drag._top);\n}\n\n/**\n * Compute threshold value and edge offset.\n *\n * @param {Number} threshold\n * @param {Number} safeZone\n * @param {Number} itemSize\n * @param {Number} targetSize\n * @returns {Object}\n */\nfunction computeThreshold(threshold, safeZone, itemSize, targetSize) {\n  THRESHOLD_DATA.value = Math.min(targetSize / 2, threshold);\n  THRESHOLD_DATA.offset =\n    Math.max(0, itemSize + THRESHOLD_DATA.value * 2 + targetSize * safeZone - targetSize) / 2;\n  return THRESHOLD_DATA;\n}\n\nfunction ScrollRequest() {\n  this.reset();\n}\n\nScrollRequest.prototype.reset = function () {\n  if (this.isActive) this.onStop();\n  this.item = null;\n  this.element = null;\n  this.isActive = false;\n  this.isEnding = false;\n  this.direction = null;\n  this.value = null;\n  this.maxValue = 0;\n  this.threshold = 0;\n  this.distance = 0;\n  this.speed = 0;\n  this.duration = 0;\n  this.action = null;\n};\n\nScrollRequest.prototype.hasReachedEnd = function () {\n  return FORWARD & this.direction ? this.value >= this.maxValue : this.value <= 0;\n};\n\nScrollRequest.prototype.computeCurrentScrollValue = function () {\n  if (this.value === null) {\n    return AXIS_X & this.direction ? getScrollLeft(this.element) : getScrollTop(this.element);\n  }\n  return Math.max(0, Math.min(this.value, this.maxValue));\n};\n\nScrollRequest.prototype.computeNextScrollValue = function (deltaTime) {\n  var delta = this.speed * (deltaTime / 1000);\n  var nextValue = FORWARD & this.direction ? this.value + delta : this.value - delta;\n  return Math.max(0, Math.min(nextValue, this.maxValue));\n};\n\nScrollRequest.prototype.computeSpeed = (function () {\n  var data = {\n    direction: null,\n    threshold: 0,\n    distance: 0,\n    value: 0,\n    maxValue: 0,\n    deltaTime: 0,\n    duration: 0,\n    isEnding: false,\n  };\n\n  return function (deltaTime) {\n    var item = this.item;\n    var speed = getItemAutoScrollSettings(item).speed;\n\n    if (isFunction(speed)) {\n      data.direction = this.direction;\n      data.threshold = this.threshold;\n      data.distance = this.distance;\n      data.value = this.value;\n      data.maxValue = this.maxValue;\n      data.duration = this.duration;\n      data.speed = this.speed;\n      data.deltaTime = deltaTime;\n      data.isEnding = this.isEnding;\n      return speed(item, this.element, data);\n    } else {\n      return speed;\n    }\n  };\n})();\n\nScrollRequest.prototype.tick = function (deltaTime) {\n  if (!this.isActive) {\n    this.isActive = true;\n    this.onStart();\n  }\n  this.value = this.computeCurrentScrollValue();\n  this.speed = this.computeSpeed(deltaTime);\n  this.value = this.computeNextScrollValue(deltaTime);\n  this.duration += deltaTime;\n  return this.value;\n};\n\nScrollRequest.prototype.onStart = function () {\n  var item = this.item;\n  var onStart = getItemAutoScrollSettings(item).onStart;\n  if (isFunction(onStart)) onStart(item, this.element, this.direction);\n};\n\nScrollRequest.prototype.onStop = function () {\n  var item = this.item;\n  var onStop = getItemAutoScrollSettings(item).onStop;\n  if (isFunction(onStop)) onStop(item, this.element, this.direction);\n  // Manually nudge sort to happen. There's a good chance that the item is still\n  // after the scroll stops which means that the next sort will be triggered\n  // only after the item is moved or it's parent scrolled.\n  if (item._drag) item._drag.sort();\n};\n\nfunction ScrollAction() {\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n}\n\nScrollAction.prototype.reset = function () {\n  if (this.requestX) this.requestX.action = null;\n  if (this.requestY) this.requestY.action = null;\n  this.element = null;\n  this.requestX = null;\n  this.requestY = null;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n};\n\nScrollAction.prototype.addRequest = function (request) {\n  if (AXIS_X & request.direction) {\n    this.removeRequest(this.requestX);\n    this.requestX = request;\n  } else {\n    this.removeRequest(this.requestY);\n    this.requestY = request;\n  }\n  request.action = this;\n};\n\nScrollAction.prototype.removeRequest = function (request) {\n  if (!request) return;\n  if (this.requestX === request) {\n    this.requestX = null;\n    request.action = null;\n  } else if (this.requestY === request) {\n    this.requestY = null;\n    request.action = null;\n  }\n};\n\nScrollAction.prototype.computeScrollValues = function () {\n  this.scrollLeft = this.requestX ? this.requestX.value : getScrollLeft(this.element);\n  this.scrollTop = this.requestY ? this.requestY.value : getScrollTop(this.element);\n};\n\nScrollAction.prototype.scroll = function () {\n  var element = this.element;\n  if (!element) return;\n\n  if (element.scrollTo) {\n    element.scrollTo(this.scrollLeft, this.scrollTop);\n  } else {\n    element.scrollLeft = this.scrollLeft;\n    element.scrollTop = this.scrollTop;\n  }\n};\n\nfunction Pool(createItem, releaseItem) {\n  this.pool = [];\n  this.createItem = createItem;\n  this.releaseItem = releaseItem;\n}\n\nPool.prototype.pick = function () {\n  return this.pool.pop() || this.createItem();\n};\n\nPool.prototype.release = function (item) {\n  this.releaseItem(item);\n  if (this.pool.indexOf(item) !== -1) return;\n  this.pool.push(item);\n};\n\nPool.prototype.reset = function () {\n  this.pool.length = 0;\n};\n\n/**\n * Check if two rectangles are overlapping.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction isOverlapping(a, b) {\n  return !(\n    a.left + a.width <= b.left ||\n    b.left + b.width <= a.left ||\n    a.top + a.height <= b.top ||\n    b.top + b.height <= a.top\n  );\n}\n\n/**\n * Calculate intersection area between two rectangle.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction getIntersectionArea(a, b) {\n  if (!isOverlapping(a, b)) return 0;\n  var width = Math.min(a.left + a.width, b.left + b.width) - Math.max(a.left, b.left);\n  var height = Math.min(a.top + a.height, b.top + b.height) - Math.max(a.top, b.top);\n  return width * height;\n}\n\n/**\n * Calculate how many percent the intersection area of two rectangles is from\n * the maximum potential intersection area between the rectangles.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {Number}\n */\nfunction getIntersectionScore(a, b) {\n  var area = getIntersectionArea(a, b);\n  if (!area) return 0;\n  var maxArea = Math.min(a.width, b.width) * Math.min(a.height, b.height);\n  return (area / maxArea) * 100;\n}\n\nvar RECT_1 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\n\nvar RECT_2 = {\n  width: 0,\n  height: 0,\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\n\nfunction AutoScroller() {\n  this._isDestroyed = false;\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  this._items = [];\n  this._actions = [];\n  this._requests = {};\n  this._requests[AXIS_X] = {};\n  this._requests[AXIS_Y] = {};\n  this._requestOverlapCheck = {};\n  this._dragPositions = {};\n  this._dragDirections = {};\n  this._overlapCheckInterval = 150;\n\n  this._requestPool = new Pool(\n    function () {\n      return new ScrollRequest();\n    },\n    function (request) {\n      request.reset();\n    }\n  );\n\n  this._actionPool = new Pool(\n    function () {\n      return new ScrollAction();\n    },\n    function (action) {\n      action.reset();\n    }\n  );\n\n  this._readTick = this._readTick.bind(this);\n  this._writeTick = this._writeTick.bind(this);\n}\n\nAutoScroller.AXIS_X = AXIS_X;\nAutoScroller.AXIS_Y = AXIS_Y;\nAutoScroller.FORWARD = FORWARD;\nAutoScroller.BACKWARD = BACKWARD;\nAutoScroller.LEFT = LEFT;\nAutoScroller.RIGHT = RIGHT;\nAutoScroller.UP = UP;\nAutoScroller.DOWN = DOWN;\n\nAutoScroller.smoothSpeed = function (maxSpeed, acceleration, deceleration) {\n  return function (item, element, data) {\n    var targetSpeed = 0;\n    if (!data.isEnding) {\n      if (data.threshold > 0) {\n        var factor = data.threshold - Math.max(0, data.distance);\n        targetSpeed = (maxSpeed / data.threshold) * factor;\n      } else {\n        targetSpeed = maxSpeed;\n      }\n    }\n\n    var currentSpeed = data.speed;\n    var nextSpeed = targetSpeed;\n\n    if (currentSpeed === targetSpeed) {\n      return nextSpeed;\n    }\n\n    if (currentSpeed < targetSpeed) {\n      nextSpeed = currentSpeed + acceleration * (data.deltaTime / 1000);\n      return Math.min(targetSpeed, nextSpeed);\n    } else {\n      nextSpeed = currentSpeed - deceleration * (data.deltaTime / 1000);\n      return Math.max(targetSpeed, nextSpeed);\n    }\n  };\n};\n\nAutoScroller.pointerHandle = function (pointerSize) {\n  var rect = { left: 0, top: 0, width: 0, height: 0 };\n  var size = pointerSize || 1;\n  return function (item, x, y, w, h, pX, pY) {\n    rect.left = pX - size * 0.5;\n    rect.top = pY - size * 0.5;\n    rect.width = size;\n    rect.height = size;\n    return rect;\n  };\n};\n\nAutoScroller.prototype._readTick = function (time) {\n  if (this._isDestroyed) return;\n  if (time && this._tickTime) {\n    this._tickDeltaTime = time - this._tickTime;\n    this._tickTime = time;\n    this._updateRequests();\n    this._updateActions();\n  } else {\n    this._tickTime = time;\n    this._tickDeltaTime = 0;\n  }\n};\n\nAutoScroller.prototype._writeTick = function () {\n  if (this._isDestroyed) return;\n  this._applyActions();\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\n\nAutoScroller.prototype._startTicking = function () {\n  this._isTicking = true;\n  addAutoScrollTick(this._readTick, this._writeTick);\n};\n\nAutoScroller.prototype._stopTicking = function () {\n  this._isTicking = false;\n  this._tickTime = 0;\n  this._tickDeltaTime = 0;\n  cancelAutoScrollTick();\n};\n\nAutoScroller.prototype._getItemHandleRect = function (item, handle, rect) {\n  var itemDrag = item._drag;\n\n  if (handle) {\n    var ev = itemDrag._dragMoveEvent || itemDrag._dragStartEvent;\n    var data = handle(\n      item,\n      itemDrag._clientX,\n      itemDrag._clientY,\n      item._width,\n      item._height,\n      ev.clientX,\n      ev.clientY\n    );\n    rect.left = data.left;\n    rect.top = data.top;\n    rect.width = data.width;\n    rect.height = data.height;\n  } else {\n    rect.left = itemDrag._clientX;\n    rect.top = itemDrag._clientY;\n    rect.width = item._width;\n    rect.height = item._height;\n  }\n\n  rect.right = rect.left + rect.width;\n  rect.bottom = rect.top + rect.height;\n\n  return rect;\n};\n\nAutoScroller.prototype._requestItemScroll = function (\n  item,\n  axis,\n  element,\n  direction,\n  threshold,\n  distance,\n  maxValue\n) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n\n  if (request) {\n    if (request.element !== element || request.direction !== direction) {\n      request.reset();\n    }\n  } else {\n    request = this._requestPool.pick();\n  }\n\n  request.item = item;\n  request.element = element;\n  request.direction = direction;\n  request.threshold = threshold;\n  request.distance = distance;\n  request.maxValue = maxValue;\n  reqMap[item._id] = request;\n};\n\nAutoScroller.prototype._cancelItemScroll = function (item, axis) {\n  var reqMap = this._requests[axis];\n  var request = reqMap[item._id];\n  if (!request) return;\n  if (request.action) request.action.removeRequest(request);\n  this._requestPool.release(request);\n  delete reqMap[item._id];\n};\n\nAutoScroller.prototype._checkItemOverlap = function (item, checkX, checkY) {\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n\n  if (!targets || !targets.length) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n\n  var dragDirections = this._dragDirections[item._id];\n  var dragDirectionX = dragDirections[0];\n  var dragDirectionY = dragDirections[1];\n\n  if (!dragDirectionX && !dragDirectionY) {\n    checkX && this._cancelItemScroll(item, AXIS_X);\n    checkY && this._cancelItemScroll(item, AXIS_Y);\n    return;\n  }\n\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n  var testRect = RECT_2;\n\n  var target = null;\n  var testElement = null;\n  var testAxisX = true;\n  var testAxisY = true;\n  var testScore = 0;\n  var testPriority = 0;\n  var testThreshold = null;\n  var testDirection = null;\n  var testDistance = 0;\n  var testMaxScrollX = 0;\n  var testMaxScrollY = 0;\n\n  var xElement = null;\n  var xPriority = -Infinity;\n  var xThreshold = 0;\n  var xScore = 0;\n  var xDirection = null;\n  var xDistance = 0;\n  var xMaxScroll = 0;\n\n  var yElement = null;\n  var yPriority = -Infinity;\n  var yThreshold = 0;\n  var yScore = 0;\n  var yDirection = null;\n  var yDistance = 0;\n  var yMaxScroll = 0;\n\n  for (var i = 0; i < targets.length; i++) {\n    target = targets[i];\n    testAxisX = checkX && dragDirectionX && target.axis !== AXIS_Y;\n    testAxisY = checkY && dragDirectionY && target.axis !== AXIS_X;\n    testPriority = target.priority || 0;\n\n    // Ignore this item if it's x-axis and y-axis priority is lower than\n    // the currently matching item's.\n    if ((!testAxisX || testPriority < xPriority) && (!testAxisY || testPriority < yPriority)) {\n      continue;\n    }\n\n    testElement = getScrollElement(target.element || target);\n    testMaxScrollX = testAxisX ? getScrollLeftMax(testElement) : -1;\n    testMaxScrollY = testAxisY ? getScrollTopMax(testElement) : -1;\n\n    // Ignore this item if there is no possibility to scroll.\n    if (!testMaxScrollX && !testMaxScrollY) continue;\n\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect);\n\n    // Ignore this item if it's not overlapping at all with the dragged item.\n    if (testScore <= 0) continue;\n\n    // Test x-axis.\n    if (\n      testAxisX &&\n      testPriority >= xPriority &&\n      testMaxScrollX > 0 &&\n      (testPriority > xPriority || testScore > xScore)\n    ) {\n      testDirection = null;\n      testThreshold = computeThreshold(\n        typeof target.threshold === 'number' ? target.threshold : threshold,\n        safeZone,\n        itemRect.width,\n        testRect.width\n      );\n      if (dragDirectionX === RIGHT) {\n        testDistance = testRect.right + testThreshold.offset - itemRect.right;\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) < testMaxScrollX) {\n          testDirection = RIGHT;\n        }\n      } else if (dragDirectionX === LEFT) {\n        testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n        if (testDistance <= testThreshold.value && getScrollLeft(testElement) > 0) {\n          testDirection = LEFT;\n        }\n      }\n\n      if (testDirection !== null) {\n        xElement = testElement;\n        xPriority = testPriority;\n        xThreshold = testThreshold.value;\n        xScore = testScore;\n        xDirection = testDirection;\n        xDistance = testDistance;\n        xMaxScroll = testMaxScrollX;\n      }\n    }\n\n    // Test y-axis.\n    if (\n      testAxisY &&\n      testPriority >= yPriority &&\n      testMaxScrollY > 0 &&\n      (testPriority > yPriority || testScore > yScore)\n    ) {\n      testDirection = null;\n      testThreshold = computeThreshold(\n        typeof target.threshold === 'number' ? target.threshold : threshold,\n        safeZone,\n        itemRect.height,\n        testRect.height\n      );\n      if (dragDirectionY === DOWN) {\n        testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) < testMaxScrollY) {\n          testDirection = DOWN;\n        }\n      } else if (dragDirectionY === UP) {\n        testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n        if (testDistance <= testThreshold.value && getScrollTop(testElement) > 0) {\n          testDirection = UP;\n        }\n      }\n\n      if (testDirection !== null) {\n        yElement = testElement;\n        yPriority = testPriority;\n        yThreshold = testThreshold.value;\n        yScore = testScore;\n        yDirection = testDirection;\n        yDistance = testDistance;\n        yMaxScroll = testMaxScrollY;\n      }\n    }\n  }\n\n  // Request or cancel x-axis scroll.\n  if (checkX) {\n    if (xElement) {\n      this._requestItemScroll(\n        item,\n        AXIS_X,\n        xElement,\n        xDirection,\n        xThreshold,\n        xDistance,\n        xMaxScroll\n      );\n    } else {\n      this._cancelItemScroll(item, AXIS_X);\n    }\n  }\n\n  // Request or cancel y-axis scroll.\n  if (checkY) {\n    if (yElement) {\n      this._requestItemScroll(\n        item,\n        AXIS_Y,\n        yElement,\n        yDirection,\n        yThreshold,\n        yDistance,\n        yMaxScroll\n      );\n    } else {\n      this._cancelItemScroll(item, AXIS_Y);\n    }\n  }\n};\n\nAutoScroller.prototype._updateScrollRequest = function (scrollRequest) {\n  var item = scrollRequest.item;\n  var settings = getItemAutoScrollSettings(item);\n  var targets = isFunction(settings.targets) ? settings.targets(item) : settings.targets;\n  var targetCount = (targets && targets.length) || 0;\n  var threshold = settings.threshold;\n  var safeZone = settings.safeZone;\n  var itemRect = this._getItemHandleRect(item, settings.handle, RECT_1);\n  var testRect = RECT_2;\n  var target = null;\n  var testElement = null;\n  var testIsAxisX = false;\n  var testScore = null;\n  var testThreshold = null;\n  var testDistance = null;\n  var testScroll = null;\n  var testMaxScroll = null;\n  var hasReachedEnd = null;\n\n  for (var i = 0; i < targetCount; i++) {\n    target = targets[i];\n\n    // Make sure we have a matching element.\n    testElement = getScrollElement(target.element || target);\n    if (testElement !== scrollRequest.element) continue;\n\n    // Make sure we have a matching axis.\n    testIsAxisX = !!(AXIS_X & scrollRequest.direction);\n    if (testIsAxisX) {\n      if (target.axis === AXIS_Y) continue;\n    } else {\n      if (target.axis === AXIS_X) continue;\n    }\n\n    // Stop scrolling if there is no room to scroll anymore.\n    testMaxScroll = testIsAxisX ? getScrollLeftMax(testElement) : getScrollTopMax(testElement);\n    if (testMaxScroll <= 0) {\n      break;\n    }\n\n    testRect = getContentRect(testElement, testRect);\n    testScore = getIntersectionScore(itemRect, testRect);\n\n    // Stop scrolling if dragged item is not overlapping with the scroll\n    // element anymore.\n    if (testScore <= 0) {\n      break;\n    }\n\n    // Compute threshold and edge offset.\n    testThreshold = computeThreshold(\n      typeof target.threshold === 'number' ? target.threshold : threshold,\n      safeZone,\n      testIsAxisX ? itemRect.width : itemRect.height,\n      testIsAxisX ? testRect.width : testRect.height\n    );\n\n    // Compute distance (based on current direction).\n    if (scrollRequest.direction === LEFT) {\n      testDistance = itemRect.left - (testRect.left - testThreshold.offset);\n    } else if (scrollRequest.direction === RIGHT) {\n      testDistance = testRect.right + testThreshold.offset - itemRect.right;\n    } else if (scrollRequest.direction === UP) {\n      testDistance = itemRect.top - (testRect.top - testThreshold.offset);\n    } else {\n      testDistance = testRect.bottom + testThreshold.offset - itemRect.bottom;\n    }\n\n    // Stop scrolling if threshold is not exceeded.\n    if (testDistance > testThreshold.value) {\n      break;\n    }\n\n    // Stop scrolling if we have reached the end of the scroll value.\n    testScroll = testIsAxisX ? getScrollLeft(testElement) : getScrollTop(testElement);\n    hasReachedEnd =\n      FORWARD & scrollRequest.direction ? testScroll >= testMaxScroll : testScroll <= 0;\n    if (hasReachedEnd) {\n      break;\n    }\n\n    // Scrolling can continue, let's update the values.\n    scrollRequest.maxValue = testMaxScroll;\n    scrollRequest.threshold = testThreshold.value;\n    scrollRequest.distance = testDistance;\n    scrollRequest.isEnding = false;\n    return true;\n  }\n\n  // Before we end the request, let's see if we need to stop the scrolling\n  // smoothly or immediately.\n  if (settings.smoothStop === true && scrollRequest.speed > 0) {\n    if (hasReachedEnd === null) hasReachedEnd = scrollRequest.hasReachedEnd();\n    scrollRequest.isEnding = hasReachedEnd ? false : true;\n  } else {\n    scrollRequest.isEnding = false;\n  }\n\n  return scrollRequest.isEnding;\n};\n\nAutoScroller.prototype._updateRequests = function () {\n  var items = this._items;\n  var requestsX = this._requests[AXIS_X];\n  var requestsY = this._requests[AXIS_Y];\n  var item, reqX, reqY, checkTime, needsCheck, checkX, checkY;\n\n  for (var i = 0; i < items.length; i++) {\n    item = items[i];\n    checkTime = this._requestOverlapCheck[item._id];\n    needsCheck = checkTime > 0 && this._tickTime - checkTime > this._overlapCheckInterval;\n\n    checkX = true;\n    reqX = requestsX[item._id];\n    if (reqX && reqX.isActive) {\n      checkX = !this._updateScrollRequest(reqX);\n      if (checkX) {\n        needsCheck = true;\n        this._cancelItemScroll(item, AXIS_X);\n      }\n    }\n\n    checkY = true;\n    reqY = requestsY[item._id];\n    if (reqY && reqY.isActive) {\n      checkY = !this._updateScrollRequest(reqY);\n      if (checkY) {\n        needsCheck = true;\n        this._cancelItemScroll(item, AXIS_Y);\n      }\n    }\n\n    if (needsCheck) {\n      this._requestOverlapCheck[item._id] = 0;\n      this._checkItemOverlap(item, checkX, checkY);\n    }\n  }\n};\n\nAutoScroller.prototype._requestAction = function (request, axis) {\n  var actions = this._actions;\n  var isAxisX = axis === AXIS_X;\n  var action = null;\n\n  for (var i = 0; i < actions.length; i++) {\n    action = actions[i];\n\n    // If the action's request does not match the request's -> skip.\n    if (request.element !== action.element) {\n      action = null;\n      continue;\n    }\n\n    // If the request and action share the same element, but the request slot\n    // for the requested axis is already reserved let's ignore and cancel this\n    // request.\n    if (isAxisX ? action.requestX : action.requestY) {\n      this._cancelItemScroll(request.item, axis);\n      return;\n    }\n\n    // Seems like we have found our action, let's break the loop.\n    break;\n  }\n\n  if (!action) action = this._actionPool.pick();\n  action.element = request.element;\n  action.addRequest(request);\n\n  request.tick(this._tickDeltaTime);\n  actions.push(action);\n};\n\nAutoScroller.prototype._updateActions = function () {\n  var items = this._items;\n  var requests = this._requests;\n  var actions = this._actions;\n  var itemId;\n  var reqX;\n  var reqY;\n  var i;\n\n  // Generate actions.\n  for (i = 0; i < items.length; i++) {\n    itemId = items[i]._id;\n    reqX = requests[AXIS_X][itemId];\n    reqY = requests[AXIS_Y][itemId];\n    if (reqX) this._requestAction(reqX, AXIS_X);\n    if (reqY) this._requestAction(reqY, AXIS_Y);\n  }\n\n  // Compute actions' scroll values.\n  for (i = 0; i < actions.length; i++) {\n    actions[i].computeScrollValues();\n  }\n};\n\nAutoScroller.prototype._applyActions = function () {\n  var actions = this._actions;\n  var items = this._items;\n  var i;\n\n  // No actions -> no scrolling.\n  if (!actions.length) return;\n\n  // Scroll all the required elements.\n  for (i = 0; i < actions.length; i++) {\n    actions[i].scroll();\n    this._actionPool.release(actions[i]);\n  }\n\n  // Reset actions.\n  actions.length = 0;\n\n  // Sync the item position immediately after all the auto-scrolling business is\n  // finished. Without this procedure the items will jitter during auto-scroll\n  // (in some cases at least) since the drag scroll handler is async (bound to\n  // raf tick). Note that this procedure should not emit any dragScroll events,\n  // because otherwise they would be emitted twice for the same event.\n  for (i = 0; i < items.length; i++) prepareItemScrollSync(items[i]);\n  for (i = 0; i < items.length; i++) applyItemScrollSync(items[i]);\n};\n\nAutoScroller.prototype._updateDragDirection = function (item) {\n  var dragPositions = this._dragPositions[item._id];\n  var dragDirections = this._dragDirections[item._id];\n  var x1 = item._drag._left;\n  var y1 = item._drag._top;\n  if (dragPositions.length) {\n    var x2 = dragPositions[0];\n    var y2 = dragPositions[1];\n    dragDirections[0] = x1 > x2 ? RIGHT : x1 < x2 ? LEFT : dragDirections[0] || 0;\n    dragDirections[1] = y1 > y2 ? DOWN : y1 < y2 ? UP : dragDirections[1] || 0;\n  }\n  dragPositions[0] = x1;\n  dragPositions[1] = y1;\n};\n\nAutoScroller.prototype.addItem = function (item) {\n  if (this._isDestroyed) return;\n  var index = this._items.indexOf(item);\n  if (index === -1) {\n    this._items.push(item);\n    this._requestOverlapCheck[item._id] = this._tickTime;\n    this._dragDirections[item._id] = [0, 0];\n    this._dragPositions[item._id] = [];\n    if (!this._isTicking) this._startTicking();\n  }\n};\n\nAutoScroller.prototype.updateItem = function (item) {\n  if (this._isDestroyed) return;\n\n  // Make sure the item still exists in the auto-scroller.\n  if (!this._dragDirections[item._id]) return;\n\n  this._updateDragDirection(item);\n  if (!this._requestOverlapCheck[item._id]) {\n    this._requestOverlapCheck[item._id] = this._tickTime;\n  }\n};\n\nAutoScroller.prototype.removeItem = function (item) {\n  if (this._isDestroyed) return;\n\n  var index = this._items.indexOf(item);\n  if (index === -1) return;\n\n  var itemId = item._id;\n\n  var reqX = this._requests[AXIS_X][itemId];\n  if (reqX) {\n    this._cancelItemScroll(item, AXIS_X);\n    delete this._requests[AXIS_X][itemId];\n  }\n\n  var reqY = this._requests[AXIS_Y][itemId];\n  if (reqY) {\n    this._cancelItemScroll(item, AXIS_Y);\n    delete this._requests[AXIS_Y][itemId];\n  }\n\n  delete this._requestOverlapCheck[itemId];\n  delete this._dragPositions[itemId];\n  delete this._dragDirections[itemId];\n  this._items.splice(index, 1);\n\n  if (this._isTicking && !this._items.length) {\n    this._stopTicking();\n  }\n};\n\nAutoScroller.prototype.isItemScrollingX = function (item) {\n  var reqX = this._requests[AXIS_X][item._id];\n  return !!(reqX && reqX.isActive);\n};\n\nAutoScroller.prototype.isItemScrollingY = function (item) {\n  var reqY = this._requests[AXIS_Y][item._id];\n  return !!(reqY && reqY.isActive);\n};\n\nAutoScroller.prototype.isItemScrolling = function (item) {\n  return this.isItemScrollingX(item) || this.isItemScrollingY(item);\n};\n\nAutoScroller.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var items = this._items.slice(0);\n  for (var i = 0; i < items.length; i++) {\n    this.removeItem(items[i]);\n  }\n\n  this._actions.length = 0;\n  this._requestPool.reset();\n  this._actionPool.reset();\n\n  this._isDestroyed = true;\n};\n\nvar ElProto = window.Element.prototype;\nvar matchesFn =\n  ElProto.matches ||\n  ElProto.matchesSelector ||\n  ElProto.webkitMatchesSelector ||\n  ElProto.mozMatchesSelector ||\n  ElProto.msMatchesSelector ||\n  ElProto.oMatchesSelector ||\n  function () {\n    return false;\n  };\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {Element} el\n * @param {String} selector\n * @returns {Boolean}\n */\nfunction elementMatches(el, selector) {\n  return matchesFn.call(el, selector);\n}\n\n/**\n * Add class to an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\nfunction addClass(element, className) {\n  if (!className) return;\n\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    if (!elementMatches(element, '.' + className)) {\n      element.className += ' ' + className;\n    }\n  }\n}\n\nvar tempArray = [];\nvar numberType = 'number';\n\n/**\n * Insert an item or an array of items to array to a specified index. Mutates\n * the array. The index can be negative in which case the items will be added\n * to the end of the array.\n *\n * @param {Array} array\n * @param {*} items\n * @param {Number} [index=-1]\n */\nfunction arrayInsert(array, items, index) {\n  var startIndex = typeof index === numberType ? index : -1;\n  if (startIndex < 0) startIndex = array.length - startIndex + 1;\n\n  array.splice.apply(array, tempArray.concat(startIndex, 0, items));\n  tempArray.length = 0;\n}\n\n/**\n * Normalize array index. Basically this function makes sure that the provided\n * array index is within the bounds of the provided array and also transforms\n * negative index to the matching positive index. The third (optional) argument\n * allows you to define offset for array's length in case you are adding items\n * to the array or removing items from the array.\n *\n * @param {Array} array\n * @param {Number} index\n * @param {Number} [sizeOffset]\n */\nfunction normalizeArrayIndex(array, index, sizeOffset) {\n  var maxIndex = Math.max(0, array.length - 1 + (sizeOffset || 0));\n  return index > maxIndex ? maxIndex : index < 0 ? Math.max(maxIndex + index + 1, 0) : index;\n}\n\n/**\n * Move array item to another index.\n *\n * @param {Array} array\n * @param {Number} fromIndex\n *   - Index (positive or negative) of the item that will be moved.\n * @param {Number} toIndex\n *   - Index (positive or negative) where the item should be moved to.\n */\nfunction arrayMove(array, fromIndex, toIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return;\n\n  // Normalize the indices.\n  var from = normalizeArrayIndex(array, fromIndex);\n  var to = normalizeArrayIndex(array, toIndex);\n\n  // Add target item to the new position.\n  if (from !== to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n  }\n}\n\n/**\n * Swap array items.\n *\n * @param {Array} array\n * @param {Number} index\n *   - Index (positive or negative) of the item that will be swapped.\n * @param {Number} withIndex\n *   - Index (positive or negative) of the other item that will be swapped.\n */\nfunction arraySwap(array, index, withIndex) {\n  // Make sure the array has two or more items.\n  if (array.length < 2) return;\n\n  // Normalize the indices.\n  var indexA = normalizeArrayIndex(array, index);\n  var indexB = normalizeArrayIndex(array, withIndex);\n  var temp;\n\n  // Swap the items.\n  if (indexA !== indexB) {\n    temp = array[indexA];\n    array[indexA] = array[indexB];\n    array[indexB] = temp;\n  }\n}\n\nvar transformProp = getPrefixedPropName(document.documentElement.style, 'transform') || 'transform';\n\nvar styleNameRegEx = /([A-Z])/g;\nvar prefixRegex = /^(webkit-|moz-|ms-|o-)/;\nvar msPrefixRegex = /^(-m-s-)/;\n\n/**\n * Transforms a camel case style property to kebab case style property. Handles\n * vendor prefixed properties elegantly as well, e.g. \"WebkitTransform\" and\n * \"webkitTransform\" are both transformed into \"-webkit-transform\".\n *\n * @param {String} property\n * @returns {String}\n */\nfunction getStyleName(property) {\n  // Initial slicing, turns \"fooBarProp\" into \"foo-bar-prop\".\n  var styleName = property.replace(styleNameRegEx, '-$1').toLowerCase();\n\n  // Handle properties that start with \"webkit\", \"moz\", \"ms\" or \"o\" prefix (we\n  // need to add an extra '-' to the beginnig).\n  styleName = styleName.replace(prefixRegex, '-$1');\n\n  // Handle properties that start with \"MS\" prefix (we need to transform the\n  // \"-m-s-\" into \"-ms-\").\n  styleName = styleName.replace(msPrefixRegex, '-ms-');\n\n  return styleName;\n}\n\nvar transformStyle = getStyleName(transformProp);\n\nvar transformNone$1 = 'none';\nvar displayInline = 'inline';\nvar displayNone = 'none';\nvar displayStyle = 'display';\n\n/**\n * Returns true if element is transformed, false if not. In practice the\n * element's display value must be anything else than \"none\" or \"inline\" as\n * well as have a valid transform value applied in order to be counted as a\n * transformed element.\n *\n * Borrowed from Mezr (v0.6.1):\n * https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L661\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\nfunction isTransformed(element) {\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone$1) return false;\n\n  var display = getStyle(element, displayStyle);\n  if (display === displayInline || display === displayNone) return false;\n\n  return true;\n}\n\n/**\n * Returns an absolute positioned element's containing block, which is\n * considered to be the closest ancestor element that the target element's\n * positioning is relative to. Disclaimer: this only works as intended for\n * absolute positioned elements.\n *\n * @param {HTMLElement} element\n * @returns {(Document|Element)}\n */\nfunction getContainingBlock(element) {\n  // As long as the containing block is an element, static and not\n  // transformed, try to get the element's parent element and fallback to\n  // document. https://github.com/niklasramo/mezr/blob/0.6.1/mezr.js#L339\n  var doc = document;\n  var res = element || doc;\n  while (res && res !== doc && getStyle(res, 'position') === 'static' && !isTransformed(res)) {\n    res = res.parentElement || doc;\n  }\n  return res;\n}\n\nvar offsetA = {};\nvar offsetB = {};\nvar offsetDiff = {};\n\n/**\n * Returns the element's document offset, which in practice means the vertical\n * and horizontal distance between the element's northwest corner and the\n * document's northwest corner. Note that this function always returns the same\n * object so be sure to read the data from it instead using it as a reference.\n *\n * @param {(Document|Element|Window)} element\n * @param {Object} [offsetData]\n *   - Optional data object where the offset data will be inserted to. If not\n *     provided a new object will be created for the return data.\n * @returns {Object}\n */\nfunction getOffset(element, offsetData) {\n  var offset = offsetData || {};\n  var rect;\n\n  // Set up return data.\n  offset.left = 0;\n  offset.top = 0;\n\n  // Document's offsets are always 0.\n  if (element === document) return offset;\n\n  // Add viewport scroll left/top to the respective offsets.\n  offset.left = window.pageXOffset || 0;\n  offset.top = window.pageYOffset || 0;\n\n  // Window's offsets are the viewport scroll left/top values.\n  if (element.self === window.self) return offset;\n\n  // Add element's client rects to the offsets.\n  rect = element.getBoundingClientRect();\n  offset.left += rect.left;\n  offset.top += rect.top;\n\n  // Exclude element's borders from the offset.\n  offset.left += getStyleAsFloat(element, 'border-left-width');\n  offset.top += getStyleAsFloat(element, 'border-top-width');\n\n  return offset;\n}\n\n/**\n * Calculate the offset difference two elements.\n *\n * @param {HTMLElement} elemA\n * @param {HTMLElement} elemB\n * @param {Boolean} [compareContainingBlocks=false]\n *   - When this is set to true the containing blocks of the provided elements\n *     will be used for calculating the difference. Otherwise the provided\n *     elements will be compared directly.\n * @returns {Object}\n */\nfunction getOffsetDiff(elemA, elemB, compareContainingBlocks) {\n  offsetDiff.left = 0;\n  offsetDiff.top = 0;\n\n  // If elements are same let's return early.\n  if (elemA === elemB) return offsetDiff;\n\n  // Compare containing blocks if necessary.\n  if (compareContainingBlocks) {\n    elemA = getContainingBlock(elemA);\n    elemB = getContainingBlock(elemB);\n\n    // If containing blocks are identical, let's return early.\n    if (elemA === elemB) return offsetDiff;\n  }\n\n  // Finally, let's calculate the offset diff.\n  getOffset(elemA, offsetA);\n  getOffset(elemB, offsetB);\n  offsetDiff.left = offsetB.left - offsetA.left;\n  offsetDiff.top = offsetB.top - offsetA.top;\n\n  return offsetDiff;\n}\n\n/**\n * Check if overflow style value is scrollable.\n *\n * @param {String} value\n * @returns {Boolean}\n */\nfunction isScrollableOverflow(value) {\n  return value === 'auto' || value === 'scroll' || value === 'overlay';\n}\n\n/**\n * Check if an element is scrollable.\n *\n * @param {HTMLElement} element\n * @returns {Boolean}\n */\nfunction isScrollable(element) {\n  return (\n    isScrollableOverflow(getStyle(element, 'overflow')) ||\n    isScrollableOverflow(getStyle(element, 'overflow-x')) ||\n    isScrollableOverflow(getStyle(element, 'overflow-y'))\n  );\n}\n\n/**\n * Collect element's ancestors that are potentially scrollable elements. The\n * provided element is also also included in the check, meaning that if it is\n * scrollable it is added to the result array.\n *\n * @param {HTMLElement} element\n * @param {Array} [result]\n * @returns {Array}\n */\nfunction getScrollableAncestors(element, result) {\n  result = result || [];\n\n  // Find scroll parents.\n  while (element && element !== document) {\n    // If element is inside ShadowDOM let's get it's host node from the real\n    // DOM and continue looping.\n    if (element.getRootNode && element instanceof DocumentFragment) {\n      element = element.getRootNode().host;\n      continue;\n    }\n\n    // If element is scrollable let's add it to the scrollable list.\n    if (isScrollable(element)) {\n      result.push(element);\n    }\n\n    element = element.parentNode;\n  }\n\n  // Always add window to the results.\n  result.push(window);\n\n  return result;\n}\n\nvar translateValue = {};\nvar transformNone = 'none';\nvar rxMat3d = /^matrix3d/;\nvar rxMatTx = /([^,]*,){4}/;\nvar rxMat3dTx = /([^,]*,){12}/;\nvar rxNextItem = /[^,]*,/;\n\n/**\n * Returns the element's computed translateX and translateY values as a floats.\n * The returned object is always the same object and updated every time this\n * function is called.\n *\n * @param {HTMLElement} element\n * @returns {Object}\n */\nfunction getTranslate(element) {\n  translateValue.x = 0;\n  translateValue.y = 0;\n\n  var transform = getStyle(element, transformStyle);\n  if (!transform || transform === transformNone) {\n    return translateValue;\n  }\n\n  // Transform style can be in either matrix3d(...) or matrix(...).\n  var isMat3d = rxMat3d.test(transform);\n  var tX = transform.replace(isMat3d ? rxMat3dTx : rxMatTx, '');\n  var tY = tX.replace(rxNextItem, '');\n\n  translateValue.x = parseFloat(tX) || 0;\n  translateValue.y = parseFloat(tY) || 0;\n\n  return translateValue;\n}\n\n/**\n * Remove class from an element.\n *\n * @param {HTMLElement} element\n * @param {String} className\n */\nfunction removeClass(element, className) {\n  if (!className) return;\n\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    if (elementMatches(element, '.' + className)) {\n      element.className = (' ' + element.className + ' ')\n        .replace(' ' + className + ' ', ' ')\n        .trim();\n    }\n  }\n}\n\nvar IS_IOS =\n  /^(iPad|iPhone|iPod)/.test(window.navigator.platform) ||\n  (/^Mac/.test(window.navigator.platform) && window.navigator.maxTouchPoints > 1);\nvar START_PREDICATE_INACTIVE = 0;\nvar START_PREDICATE_PENDING = 1;\nvar START_PREDICATE_RESOLVED = 2;\nvar SCROLL_LISTENER_OPTIONS = hasPassiveEvents() ? { passive: true } : false;\n\n/**\n * Bind touch interaction to an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDrag(item) {\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  this._item = item;\n  this._gridId = grid._id;\n  this._isDestroyed = false;\n  this._isMigrating = false;\n\n  // Start predicate data.\n  this._startPredicate = isFunction(settings.dragStartPredicate)\n    ? settings.dragStartPredicate\n    : ItemDrag.defaultStartPredicate;\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n  this._startPredicateResult = undefined;\n\n  // Data for drag sort predicate heuristics.\n  this._isSortNeeded = false;\n  this._sortTimer = undefined;\n  this._blockedSortIndex = null;\n  this._sortX1 = 0;\n  this._sortX2 = 0;\n  this._sortY1 = 0;\n  this._sortY2 = 0;\n\n  // Setup item's initial drag data.\n  this._reset();\n\n  // Bind the methods that needs binding.\n  this._preStartCheck = this._preStartCheck.bind(this);\n  this._preEndCheck = this._preEndCheck.bind(this);\n  this._onScroll = this._onScroll.bind(this);\n  this._prepareStart = this._prepareStart.bind(this);\n  this._applyStart = this._applyStart.bind(this);\n  this._prepareMove = this._prepareMove.bind(this);\n  this._applyMove = this._applyMove.bind(this);\n  this._prepareScroll = this._prepareScroll.bind(this);\n  this._applyScroll = this._applyScroll.bind(this);\n  this._handleSort = this._handleSort.bind(this);\n  this._handleSortDelayed = this._handleSortDelayed.bind(this);\n\n  // Get drag handle element.\n  this._handle = (settings.dragHandle && element.querySelector(settings.dragHandle)) || element;\n\n  // Init dragger.\n  this._dragger = new Dragger(this._handle, settings.dragCssProps);\n  this._dragger.on('start', this._preStartCheck);\n  this._dragger.on('move', this._preStartCheck);\n  this._dragger.on('cancel', this._preEndCheck);\n  this._dragger.on('end', this._preEndCheck);\n}\n\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @type {AutoScroller}\n */\nItemDrag.autoScroller = new AutoScroller();\n\n/**\n * Public static methods\n * *********************\n */\n\n/**\n * Default drag start predicate handler that handles anchor elements\n * gracefully. The return value of this function defines if the drag is\n * started, rejected or pending. When true is returned the dragging is started\n * and when false is returned the dragging is rejected. If nothing is returned\n * the predicate will be called again on the next drag movement.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} event\n * @param {Object} [options]\n *   - An optional options object which can be used to pass the predicate\n *     it's options manually. By default the predicate retrieves the options\n *     from the grid's settings.\n * @returns {(Boolean|undefined)}\n */\nItemDrag.defaultStartPredicate = function (item, event, options) {\n  var drag = item._drag;\n\n  // Make sure left button is pressed on mouse.\n  if (event.isFirst && event.srcEvent.button) {\n    return false;\n  }\n\n  // If the start event is trusted, non-cancelable and it's default action has\n  // not been prevented it is in most cases a sign that the gesture would be\n  // cancelled anyways right after it has started (e.g. starting drag while\n  // the page is scrolling).\n  if (\n    !IS_IOS &&\n    event.isFirst &&\n    event.srcEvent.isTrusted === true &&\n    event.srcEvent.defaultPrevented === false &&\n    event.srcEvent.cancelable === false\n  ) {\n    return false;\n  }\n\n  // Final event logic. At this stage return value does not matter anymore,\n  // the predicate is either resolved or it's not and there's nothing to do\n  // about it. Here we just reset data and if the item element is a link\n  // we follow it (if there has only been slight movement).\n  if (event.isFinal) {\n    drag._finishStartPredicate(event);\n    return;\n  }\n\n  // Setup predicate data from options if not already set.\n  var predicate = drag._startPredicateData;\n  if (!predicate) {\n    var config = options || drag._getGrid()._settings.dragStartPredicate || {};\n    drag._startPredicateData = predicate = {\n      distance: Math.max(config.distance, 0) || 0,\n      delay: Math.max(config.delay, 0) || 0,\n    };\n  }\n\n  // If delay is defined let's keep track of the latest event and initiate\n  // delay if it has not been done yet.\n  if (predicate.delay) {\n    predicate.event = event;\n    if (!predicate.delayTimer) {\n      predicate.delayTimer = window.setTimeout(function () {\n        predicate.delay = 0;\n        if (drag._resolveStartPredicate(predicate.event)) {\n          drag._forceResolveStartPredicate(predicate.event);\n          drag._resetStartPredicate();\n        }\n      }, predicate.delay);\n    }\n  }\n\n  return drag._resolveStartPredicate(event);\n};\n\n/**\n * Default drag sort predicate.\n *\n * @public\n * @static\n * @param {Item} item\n * @param {Object} [options]\n * @param {Number} [options.threshold=50]\n * @param {String} [options.action='move']\n * @returns {?Object}\n *   - Returns `null` if no valid index was found. Otherwise returns drag sort\n *     command.\n */\nItemDrag.defaultSortPredicate = (function () {\n  var itemRect = {};\n  var targetRect = {};\n  var returnData = {};\n  var gridsArray = [];\n  var minThreshold = 1;\n  var maxThreshold = 100;\n\n  function getTargetGrid(item, rootGrid, threshold) {\n    var target = null;\n    var dragSort = rootGrid._settings.dragSort;\n    var bestScore = -1;\n    var gridScore;\n    var grids;\n    var grid;\n    var container;\n    var containerRect;\n    var left;\n    var top;\n    var right;\n    var bottom;\n    var i;\n\n    // Get potential target grids.\n    if (dragSort === true) {\n      gridsArray[0] = rootGrid;\n      grids = gridsArray;\n    } else if (isFunction(dragSort)) {\n      grids = dragSort.call(rootGrid, item);\n    }\n\n    // Return immediately if there are no grids.\n    if (!grids || !Array.isArray(grids) || !grids.length) {\n      return target;\n    }\n\n    // Loop through the grids and get the best match.\n    for (i = 0; i < grids.length; i++) {\n      grid = grids[i];\n\n      // Filter out all destroyed grids.\n      if (grid._isDestroyed) continue;\n\n      // Compute the grid's client rect an clamp the initial boundaries to\n      // viewport dimensions.\n      grid._updateBoundingRect();\n      left = Math.max(0, grid._left);\n      top = Math.max(0, grid._top);\n      right = Math.min(window.innerWidth, grid._right);\n      bottom = Math.min(window.innerHeight, grid._bottom);\n\n      // The grid might be inside one or more elements that clip it's visibility\n      // (e.g overflow scroll/hidden) so we want to find out the visible portion\n      // of the grid in the viewport and use that in our calculations.\n      container = grid._element.parentNode;\n      while (\n        container &&\n        container !== document &&\n        container !== document.documentElement &&\n        container !== document.body\n      ) {\n        if (container.getRootNode && container instanceof DocumentFragment) {\n          container = container.getRootNode().host;\n          continue;\n        }\n\n        if (getStyle(container, 'overflow') !== 'visible') {\n          containerRect = container.getBoundingClientRect();\n          left = Math.max(left, containerRect.left);\n          top = Math.max(top, containerRect.top);\n          right = Math.min(right, containerRect.right);\n          bottom = Math.min(bottom, containerRect.bottom);\n        }\n\n        if (getStyle(container, 'position') === 'fixed') {\n          break;\n        }\n\n        container = container.parentNode;\n      }\n\n      // No need to go further if target rect does not have visible area.\n      if (left >= right || top >= bottom) continue;\n\n      // Check how much dragged element overlaps the container element.\n      targetRect.left = left;\n      targetRect.top = top;\n      targetRect.width = right - left;\n      targetRect.height = bottom - top;\n      gridScore = getIntersectionScore(itemRect, targetRect);\n\n      // Check if this grid is the best match so far.\n      if (gridScore > threshold && gridScore > bestScore) {\n        bestScore = gridScore;\n        target = grid;\n      }\n    }\n\n    // Always reset grids array.\n    gridsArray.length = 0;\n\n    return target;\n  }\n\n  return function (item, options) {\n    var drag = item._drag;\n    var rootGrid = drag._getGrid();\n\n    // Get drag sort predicate settings.\n    var sortThreshold = options && typeof options.threshold === 'number' ? options.threshold : 50;\n    var sortAction = options && options.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n    var migrateAction =\n      options && options.migrateAction === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n\n    // Sort threshold must be a positive number capped to a max value of 100. If\n    // that's not the case this function will not work correctly. So let's clamp\n    // the threshold just in case.\n    sortThreshold = Math.min(Math.max(sortThreshold, minThreshold), maxThreshold);\n\n    // Populate item rect data.\n    itemRect.width = item._width;\n    itemRect.height = item._height;\n    itemRect.left = drag._clientX;\n    itemRect.top = drag._clientY;\n\n    // Calculate the target grid.\n    var grid = getTargetGrid(item, rootGrid, sortThreshold);\n\n    // Return early if we found no grid container element that overlaps the\n    // dragged item enough.\n    if (!grid) return null;\n\n    var isMigration = item.getGrid() !== grid;\n    var gridOffsetLeft = 0;\n    var gridOffsetTop = 0;\n    var matchScore = 0;\n    var matchIndex = -1;\n    var hasValidTargets = false;\n    var target;\n    var score;\n    var i;\n\n    // If item is moved within it's originating grid adjust item's left and\n    // top props. Otherwise if item is moved to/within another grid get the\n    // container element's offset (from the element's content edge).\n    if (grid === rootGrid) {\n      itemRect.left = drag._gridX + item._marginLeft;\n      itemRect.top = drag._gridY + item._marginTop;\n    } else {\n      grid._updateBorders(1, 0, 1, 0);\n      gridOffsetLeft = grid._left + grid._borderLeft;\n      gridOffsetTop = grid._top + grid._borderTop;\n    }\n\n    // Loop through the target grid items and try to find the best match.\n    for (i = 0; i < grid._items.length; i++) {\n      target = grid._items[i];\n\n      // If the target item is not active or the target item is the dragged\n      // item let's skip to the next item.\n      if (!target._isActive || target === item) {\n        continue;\n      }\n\n      // Mark the grid as having valid target items.\n      hasValidTargets = true;\n\n      // Calculate the target's overlap score with the dragged item.\n      targetRect.width = target._width;\n      targetRect.height = target._height;\n      targetRect.left = target._left + target._marginLeft + gridOffsetLeft;\n      targetRect.top = target._top + target._marginTop + gridOffsetTop;\n      score = getIntersectionScore(itemRect, targetRect);\n\n      // Update best match index and score if the target's overlap score with\n      // the dragged item is higher than the current best match score.\n      if (score > matchScore) {\n        matchIndex = i;\n        matchScore = score;\n      }\n    }\n\n    // If there is no valid match and the dragged item is being moved into\n    // another grid we need to do some guess work here. If there simply are no\n    // valid targets (which means that the dragged item will be the only active\n    // item in the new grid) we can just add it as the first item. If we have\n    // valid items in the new grid and the dragged item is overlapping one or\n    // more of the items in the new grid let's make an exception with the\n    // threshold and just pick the item which the dragged item is overlapping\n    // most. However, if the dragged item is not overlapping any of the valid\n    // items in the new grid let's position it as the last item in the grid.\n    if (isMigration && matchScore < sortThreshold) {\n      matchIndex = hasValidTargets ? matchIndex : 0;\n      matchScore = sortThreshold;\n    }\n\n    // Check if the best match overlaps enough to justify a placement switch.\n    if (matchScore >= sortThreshold) {\n      returnData.grid = grid;\n      returnData.index = matchIndex;\n      returnData.action = isMigration ? migrateAction : sortAction;\n      return returnData;\n    }\n\n    return null;\n  };\n})();\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Abort dragging and reset drag data.\n *\n * @public\n */\nItemDrag.prototype.stop = function () {\n  if (!this._isActive) return;\n\n  // If the item is being dropped into another grid, finish it up and return\n  // immediately.\n  if (this._isMigrating) {\n    this._finishMigration();\n    return;\n  }\n\n  var item = this._item;\n  var itemId = item._id;\n\n  // Stop auto-scroll.\n  ItemDrag.autoScroller.removeItem(item);\n\n  // Cancel queued ticks.\n  cancelDragStartTick(itemId);\n  cancelDragMoveTick(itemId);\n  cancelDragScrollTick(itemId);\n\n  // Cancel sort procedure.\n  this._cancelSort();\n\n  if (this._isStarted) {\n    // Remove scroll listeners.\n    this._unbindScrollListeners();\n\n    var element = item._element;\n    var grid = this._getGrid();\n    var draggingClass = grid._settings.itemDraggingClass;\n\n    // Append item element to the container if it's not it's child. Also make\n    // sure the translate values are adjusted to account for the DOM shift.\n    if (element.parentNode !== grid._element) {\n      grid._element.appendChild(element);\n      item._setTranslate(this._gridX, this._gridY);\n\n      // We need to do forced reflow to make sure the dragging class is removed\n      // gracefully.\n      // eslint-disable-next-line\n      if (draggingClass) element.clientWidth;\n    }\n\n    // Remove dragging class.\n    removeClass(element, draggingClass);\n  }\n\n  // Reset drag data.\n  this._reset();\n};\n\n/**\n * Manually trigger drag sort. This is only needed for special edge cases where\n * e.g. you have disabled sort and want to trigger a sort right after enabling\n * it (and don't want to wait for the next move/scroll event).\n *\n * @private\n * @param {Boolean} [force=false]\n */\nItemDrag.prototype.sort = function (force) {\n  var item = this._item;\n  if (this._isActive && item._isActive && this._dragMoveEvent) {\n    if (force === true) {\n      this._handleSort();\n    } else {\n      addDragSortTick(item._id, this._handleSort);\n    }\n  }\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemDrag.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._dragger.destroy();\n  ItemDrag.autoScroller.removeItem(this._item);\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Get Grid instance.\n *\n * @private\n * @returns {?Grid}\n */\nItemDrag.prototype._getGrid = function () {\n  return GRID_INSTANCES[this._gridId] || null;\n};\n\n/**\n * Setup/reset drag data.\n *\n * @private\n */\nItemDrag.prototype._reset = function () {\n  this._isActive = false;\n  this._isStarted = false;\n\n  // The dragged item's container element.\n  this._container = null;\n\n  // The dragged item's containing block.\n  this._containingBlock = null;\n\n  // Drag/scroll event data.\n  this._dragStartEvent = null;\n  this._dragMoveEvent = null;\n  this._dragPrevMoveEvent = null;\n  this._scrollEvent = null;\n\n  // All the elements which need to be listened for scroll events during\n  // dragging.\n  this._scrollers = [];\n\n  // The current translateX/translateY position.\n  this._left = 0;\n  this._top = 0;\n\n  // Dragged element's current position within the grid.\n  this._gridX = 0;\n  this._gridY = 0;\n\n  // Dragged element's current offset from window's northwest corner. Does\n  // not account for element's margins.\n  this._clientX = 0;\n  this._clientY = 0;\n\n  // Keep track of the clientX/Y diff for scrolling.\n  this._scrollDiffX = 0;\n  this._scrollDiffY = 0;\n\n  // Keep track of the clientX/Y diff for moving.\n  this._moveDiffX = 0;\n  this._moveDiffY = 0;\n\n  // Offset difference between the dragged element's temporary drag\n  // container and it's original container.\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n\n/**\n * Bind drag scroll handlers to all scrollable ancestor elements of the\n * dragged element and the drag container element.\n *\n * @private\n */\nItemDrag.prototype._bindScrollListeners = function () {\n  var gridContainer = this._getGrid()._element;\n  var dragContainer = this._container;\n  var scrollers = this._scrollers;\n  var gridScrollers;\n  var i;\n\n  // Get dragged element's scrolling parents.\n  scrollers.length = 0;\n  getScrollableAncestors(this._item._element.parentNode, scrollers);\n\n  // If drag container is defined and it's not the same element as grid\n  // container then we need to add the grid container and it's scroll parents\n  // to the elements which are going to be listener for scroll events.\n  if (dragContainer !== gridContainer) {\n    gridScrollers = [];\n    getScrollableAncestors(gridContainer, gridScrollers);\n    for (i = 0; i < gridScrollers.length; i++) {\n      if (scrollers.indexOf(gridScrollers[i]) < 0) {\n        scrollers.push(gridScrollers[i]);\n      }\n    }\n  }\n\n  // Bind scroll listeners.\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].addEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n};\n\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n */\nItemDrag.prototype._unbindScrollListeners = function () {\n  var scrollers = this._scrollers;\n  var i;\n\n  for (i = 0; i < scrollers.length; i++) {\n    scrollers[i].removeEventListener('scroll', this._onScroll, SCROLL_LISTENER_OPTIONS);\n  }\n\n  scrollers.length = 0;\n};\n\n/**\n * Unbind currently bound drag scroll handlers from all scrollable ancestor\n * elements of the dragged element and the drag container element.\n *\n * @private\n * @param {Object} event\n * @returns {Boolean}\n */\nItemDrag.prototype._resolveStartPredicate = function (event) {\n  var predicate = this._startPredicateData;\n  if (event.distance < predicate.distance || predicate.delay) return;\n  this._resetStartPredicate();\n  return true;\n};\n\n/**\n * Forcefully resolve drag start predicate.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._forceResolveStartPredicate = function (event) {\n  if (!this._isDestroyed && this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateState = START_PREDICATE_RESOLVED;\n    this._onStart(event);\n  }\n};\n\n/**\n * Finalize start predicate.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._finishStartPredicate = function (event) {\n  var element = this._item._element;\n\n  // Check if this is a click (very subjective heuristics).\n  var isClick = Math.abs(event.deltaX) < 2 && Math.abs(event.deltaY) < 2 && event.deltaTime < 200;\n\n  // Reset predicate.\n  this._resetStartPredicate();\n\n  // If the gesture can be interpreted as click let's try to open the element's\n  // href url (if it is an anchor element).\n  if (isClick) openAnchorHref(element);\n};\n\n/**\n * Reset drag sort heuristics.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n */\nItemDrag.prototype._resetHeuristics = function (x, y) {\n  this._blockedSortIndex = null;\n  this._sortX1 = this._sortX2 = x;\n  this._sortY1 = this._sortY2 = y;\n};\n\n/**\n * Run heuristics and return true if overlap check can be performed, and false\n * if it can not.\n *\n * @private\n * @param {Number} x\n * @param {Number} y\n * @returns {Boolean}\n */\nItemDrag.prototype._checkHeuristics = function (x, y) {\n  var settings = this._getGrid()._settings.dragSortHeuristics;\n  var minDist = settings.minDragDistance;\n\n  // Skip heuristics if not needed.\n  if (minDist <= 0) {\n    this._blockedSortIndex = null;\n    return true;\n  }\n\n  var diffX = x - this._sortX2;\n  var diffY = y - this._sortY2;\n\n  // If we can't do proper bounce back check make sure that the blocked index\n  // is not set.\n  var canCheckBounceBack = minDist > 3 && settings.minBounceBackAngle > 0;\n  if (!canCheckBounceBack) {\n    this._blockedSortIndex = null;\n  }\n\n  if (Math.abs(diffX) > minDist || Math.abs(diffY) > minDist) {\n    // Reset blocked index if angle changed enough. This check requires a\n    // minimum value of 3 for minDragDistance to function properly.\n    if (canCheckBounceBack) {\n      var angle = Math.atan2(diffX, diffY);\n      var prevAngle = Math.atan2(this._sortX2 - this._sortX1, this._sortY2 - this._sortY1);\n      var deltaAngle = Math.atan2(Math.sin(angle - prevAngle), Math.cos(angle - prevAngle));\n      if (Math.abs(deltaAngle) > settings.minBounceBackAngle) {\n        this._blockedSortIndex = null;\n      }\n    }\n\n    // Update points.\n    this._sortX1 = this._sortX2;\n    this._sortY1 = this._sortY2;\n    this._sortX2 = x;\n    this._sortY2 = y;\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Reset for default drag start predicate function.\n *\n * @private\n */\nItemDrag.prototype._resetStartPredicate = function () {\n  var predicate = this._startPredicateData;\n  if (predicate) {\n    if (predicate.delayTimer) {\n      predicate.delayTimer = window.clearTimeout(predicate.delayTimer);\n    }\n    this._startPredicateData = null;\n  }\n};\n\n/**\n * Handle the sorting procedure. Manage drag sort heuristics/interval and\n * check overlap when necessary.\n *\n * @private\n */\nItemDrag.prototype._handleSort = function () {\n  if (!this._isActive) return;\n\n  var settings = this._getGrid()._settings;\n\n  // No sorting when drag sort is disabled. Also, account for the scenario where\n  // dragSort is temporarily disabled during drag procedure so we need to reset\n  // sort timer heuristics state too.\n  if (\n    !settings.dragSort ||\n    (!settings.dragAutoScroll.sortDuringScroll && ItemDrag.autoScroller.isItemScrolling(this._item))\n  ) {\n    this._sortX1 = this._sortX2 = this._gridX;\n    this._sortY1 = this._sortY2 = this._gridY;\n    // We set this to true intentionally so that overlap check would be\n    // triggered as soon as possible after sort becomes enabled again.\n    this._isSortNeeded = true;\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n    return;\n  }\n\n  // If sorting is enabled we always need to run the heuristics check to keep\n  // the tracked coordinates updated. We also allow an exception when the sort\n  // timer is finished because the heuristics are intended to prevent overlap\n  // checks based on the dragged element's immediate movement and a delayed\n  // overlap check is valid if it comes through, because it was valid when it\n  // was invoked.\n  var shouldSort = this._checkHeuristics(this._gridX, this._gridY);\n  if (!this._isSortNeeded && !shouldSort) return;\n\n  var sortInterval = settings.dragSortHeuristics.sortInterval;\n  if (sortInterval <= 0 || this._isSortNeeded) {\n    this._isSortNeeded = false;\n    if (this._sortTimer !== undefined) {\n      this._sortTimer = window.clearTimeout(this._sortTimer);\n    }\n    this._checkOverlap();\n  } else if (this._sortTimer === undefined) {\n    this._sortTimer = window.setTimeout(this._handleSortDelayed, sortInterval);\n  }\n};\n\n/**\n * Delayed sort handler.\n *\n * @private\n */\nItemDrag.prototype._handleSortDelayed = function () {\n  this._isSortNeeded = true;\n  this._sortTimer = undefined;\n  addDragSortTick(this._item._id, this._handleSort);\n};\n\n/**\n * Cancel and reset sort procedure.\n *\n * @private\n */\nItemDrag.prototype._cancelSort = function () {\n  this._isSortNeeded = false;\n  if (this._sortTimer !== undefined) {\n    this._sortTimer = window.clearTimeout(this._sortTimer);\n  }\n  cancelDragSortTick(this._item._id);\n};\n\n/**\n * Handle the ending of the drag procedure for sorting.\n *\n * @private\n */\nItemDrag.prototype._finishSort = function () {\n  var isSortEnabled = this._getGrid()._settings.dragSort;\n  var needsFinalCheck = isSortEnabled && (this._isSortNeeded || this._sortTimer !== undefined);\n  this._cancelSort();\n  if (needsFinalCheck) this._checkOverlap();\n};\n\n/**\n * Check (during drag) if an item is overlapping other items and based on\n * the configuration layout the items.\n *\n * @private\n */\nItemDrag.prototype._checkOverlap = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  var settings = this._getGrid()._settings;\n  var result;\n  var currentGrid;\n  var currentIndex;\n  var targetGrid;\n  var targetIndex;\n  var targetItem;\n  var sortAction;\n  var isMigration;\n\n  // Get overlap check result.\n  if (isFunction(settings.dragSortPredicate)) {\n    result = settings.dragSortPredicate(item, this._dragMoveEvent);\n  } else {\n    result = ItemDrag.defaultSortPredicate(item, settings.dragSortPredicate);\n  }\n\n  // Let's make sure the result object has a valid index before going further.\n  if (!result || typeof result.index !== 'number') return;\n\n  sortAction = result.action === ACTION_SWAP ? ACTION_SWAP : ACTION_MOVE;\n  currentGrid = item.getGrid();\n  targetGrid = result.grid || currentGrid;\n  isMigration = currentGrid !== targetGrid;\n  currentIndex = currentGrid._items.indexOf(item);\n  targetIndex = normalizeArrayIndex(\n    targetGrid._items,\n    result.index,\n    isMigration && sortAction === ACTION_MOVE ? 1 : 0\n  );\n\n  // Prevent position bounce.\n  if (!isMigration && targetIndex === this._blockedSortIndex) {\n    return;\n  }\n\n  // If the item was moved within it's current grid.\n  if (!isMigration) {\n    // Make sure the target index is not the current index.\n    if (currentIndex !== targetIndex) {\n      this._blockedSortIndex = currentIndex;\n\n      // Do the sort.\n      (sortAction === ACTION_SWAP ? arraySwap : arrayMove)(\n        currentGrid._items,\n        currentIndex,\n        targetIndex\n      );\n\n      // Emit move event.\n      if (currentGrid._hasListeners(EVENT_MOVE)) {\n        currentGrid._emit(EVENT_MOVE, {\n          item: item,\n          fromIndex: currentIndex,\n          toIndex: targetIndex,\n          action: sortAction,\n        });\n      }\n\n      // Layout the grid.\n      currentGrid.layout();\n    }\n  }\n\n  // If the item was moved to another grid.\n  else {\n    this._blockedSortIndex = null;\n\n    // Let's fetch the target item when it's still in it's original index.\n    targetItem = targetGrid._items[targetIndex];\n\n    // Emit beforeSend event.\n    if (currentGrid._hasListeners(EVENT_BEFORE_SEND)) {\n      currentGrid._emit(EVENT_BEFORE_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // Emit beforeReceive event.\n    if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n      targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // Update item's grid id reference.\n    item._gridId = targetGrid._id;\n\n    // Update drag instance's migrating indicator.\n    this._isMigrating = item._gridId !== this._gridId;\n\n    // Move item instance from current grid to target grid.\n    currentGrid._items.splice(currentIndex, 1);\n    arrayInsert(targetGrid._items, item, targetIndex);\n\n    // Reset sort data.\n    item._sortData = null;\n\n    // Emit send event.\n    if (currentGrid._hasListeners(EVENT_SEND)) {\n      currentGrid._emit(EVENT_SEND, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // Emit receive event.\n    if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n      targetGrid._emit(EVENT_RECEIVE, {\n        item: item,\n        fromGrid: currentGrid,\n        fromIndex: currentIndex,\n        toGrid: targetGrid,\n        toIndex: targetIndex,\n      });\n    }\n\n    // If the sort action is \"swap\" let's respect it and send the target item\n    // (if it exists) from the target grid to the originating grid. This process\n    // is done on purpose after the dragged item placed within the target grid\n    // so that we can keep this implementation as simple as possible utilizing\n    // the existing API.\n    if (sortAction === ACTION_SWAP && targetItem && targetItem.isActive()) {\n      // Sanity check to make sure that the target item is still part of the\n      // target grid. It could have been manipulated in the event handlers.\n      if (targetGrid._items.indexOf(targetItem) > -1) {\n        targetGrid.send(targetItem, currentGrid, currentIndex, {\n          appendTo: this._container || document.body,\n          layoutSender: false,\n          layoutReceiver: false,\n        });\n      }\n    }\n\n    // Layout both grids.\n    currentGrid.layout();\n    targetGrid.layout();\n  }\n};\n\n/**\n * If item is dragged into another grid, finish the migration process\n * gracefully.\n *\n * @private\n */\nItemDrag.prototype._finishMigration = function () {\n  var item = this._item;\n  var release = item._dragRelease;\n  var element = item._element;\n  var isActive = item._isActive;\n  var targetGrid = item.getGrid();\n  var targetGridElement = targetGrid._element;\n  var targetSettings = targetGrid._settings;\n  var targetContainer = targetSettings.dragContainer || targetGridElement;\n  var currentSettings = this._getGrid()._settings;\n  var currentContainer = element.parentNode;\n  var currentVisClass = isActive\n    ? currentSettings.itemVisibleClass\n    : currentSettings.itemHiddenClass;\n  var nextVisClass = isActive ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  var translate;\n  var offsetDiff;\n\n  // Destroy current drag. Note that we need to set the migrating flag to\n  // false first, because otherwise we create an infinite loop between this\n  // and the drag.stop() method.\n  this._isMigrating = false;\n  this.destroy();\n\n  // Update item class.\n  if (currentSettings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, currentSettings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  }\n\n  // Update visibility class.\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  }\n\n  // Move the item inside the target container if it's different than the\n  // current container.\n  if (targetContainer !== currentContainer) {\n    targetContainer.appendChild(element);\n    offsetDiff = getOffsetDiff(currentContainer, targetContainer, true);\n    translate = getTranslate(element);\n    translate.x -= offsetDiff.left;\n    translate.y -= offsetDiff.top;\n  }\n\n  // Update item's cached dimensions.\n  item._refreshDimensions();\n\n  // Calculate the offset difference between target's drag container (if any)\n  // and actual grid container element. We save it later for the release\n  // process.\n  offsetDiff = getOffsetDiff(targetContainer, targetGridElement, true);\n  release._containerDiffX = offsetDiff.left;\n  release._containerDiffY = offsetDiff.top;\n\n  // Recreate item's drag handler.\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n  // Adjust the position of the item element if it was moved from a container\n  // to another.\n  if (targetContainer !== currentContainer) {\n    item._setTranslate(translate.x, translate.y);\n  }\n\n  // Update child element's styles to reflect the current visibility state.\n  item._visibility.setStyles(isActive ? targetSettings.visibleStyles : targetSettings.hiddenStyles);\n\n  // Start the release.\n  release.start();\n};\n\n/**\n * Drag pre-start handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._preStartCheck = function (event) {\n  // Let's activate drag start predicate state.\n  if (this._startPredicateState === START_PREDICATE_INACTIVE) {\n    this._startPredicateState = START_PREDICATE_PENDING;\n  }\n\n  // If predicate is pending try to resolve it.\n  if (this._startPredicateState === START_PREDICATE_PENDING) {\n    this._startPredicateResult = this._startPredicate(this._item, event);\n    if (this._startPredicateResult === true) {\n      this._startPredicateState = START_PREDICATE_RESOLVED;\n      this._onStart(event);\n    } else if (this._startPredicateResult === false) {\n      this._resetStartPredicate(event);\n      this._dragger._reset();\n      this._startPredicateState = START_PREDICATE_INACTIVE;\n    }\n  }\n\n  // Otherwise if predicate is resolved and drag is active, move the item.\n  else if (this._startPredicateState === START_PREDICATE_RESOLVED && this._isActive) {\n    this._onMove(event);\n  }\n};\n\n/**\n * Drag pre-end handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._preEndCheck = function (event) {\n  var isResolved = this._startPredicateState === START_PREDICATE_RESOLVED;\n\n  // Do final predicate check to allow user to unbind stuff for the current\n  // drag procedure within the predicate callback. The return value of this\n  // check will have no effect to the state of the predicate.\n  this._startPredicate(this._item, event);\n\n  this._startPredicateState = START_PREDICATE_INACTIVE;\n\n  if (!isResolved || !this._isActive) return;\n\n  if (this._isStarted) {\n    this._onEnd(event);\n  } else {\n    this.stop();\n  }\n};\n\n/**\n * Drag start handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onStart = function (event) {\n  var item = this._item;\n  if (!item._isActive) return;\n\n  this._isActive = true;\n  this._dragStartEvent = event;\n  ItemDrag.autoScroller.addItem(item);\n\n  addDragStartTick(item._id, this._prepareStart, this._applyStart);\n};\n\n/**\n * Prepare item to be dragged.\n *\n * @private\n *  ItemDrag.prototype\n */\nItemDrag.prototype._prepareStart = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var element = item._element;\n  var grid = this._getGrid();\n  var settings = grid._settings;\n  var gridContainer = grid._element;\n  var dragContainer = settings.dragContainer || gridContainer;\n  var containingBlock = getContainingBlock(dragContainer);\n  var translate = getTranslate(element);\n  var elementRect = element.getBoundingClientRect();\n  var hasDragContainer = dragContainer !== gridContainer;\n\n  this._container = dragContainer;\n  this._containingBlock = containingBlock;\n  this._clientX = elementRect.left;\n  this._clientY = elementRect.top;\n  this._left = this._gridX = translate.x;\n  this._top = this._gridY = translate.y;\n  this._scrollDiffX = this._scrollDiffY = 0;\n  this._moveDiffX = this._moveDiffY = 0;\n\n  this._resetHeuristics(this._gridX, this._gridY);\n\n  // If a specific drag container is set and it is different from the\n  // grid's container element we store the offset between containers.\n  if (hasDragContainer) {\n    var offsetDiff = getOffsetDiff(containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n};\n\n/**\n * Start drag for the item.\n *\n * @private\n */\nItemDrag.prototype._applyStart = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var grid = this._getGrid();\n  var element = item._element;\n  var release = item._dragRelease;\n  var migrate = item._migrate;\n  var hasDragContainer = this._container !== grid._element;\n\n  if (item.isPositioning()) {\n    item._layout.stop(true, this._left, this._top);\n  }\n\n  if (migrate._isActive) {\n    this._left -= migrate._containerDiffX;\n    this._top -= migrate._containerDiffY;\n    this._gridX -= migrate._containerDiffX;\n    this._gridY -= migrate._containerDiffY;\n    migrate.stop(true, this._left, this._top);\n  }\n\n  if (item.isReleasing()) {\n    release._reset();\n  }\n\n  if (grid._settings.dragPlaceholder.enabled) {\n    item._dragPlaceholder.create();\n  }\n\n  this._isStarted = true;\n\n  grid._emit(EVENT_DRAG_INIT, item, this._dragStartEvent);\n\n  if (hasDragContainer) {\n    // If the dragged element is a child of the drag container all we need to\n    // do is setup the relative drag position data.\n    if (element.parentNode === this._container) {\n      this._gridX -= this._containerDiffX;\n      this._gridY -= this._containerDiffY;\n    }\n    // Otherwise we need to append the element inside the correct container,\n    // setup the actual drag position data and adjust the element's translate\n    // values to account for the DOM position shift.\n    else {\n      this._left += this._containerDiffX;\n      this._top += this._containerDiffY;\n      this._container.appendChild(element);\n      item._setTranslate(this._left, this._top);\n    }\n  }\n\n  addClass(element, grid._settings.itemDraggingClass);\n  this._bindScrollListeners();\n  grid._emit(EVENT_DRAG_START, item, this._dragStartEvent);\n};\n\n/**\n * Drag move handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onMove = function (event) {\n  var item = this._item;\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  this._dragMoveEvent = event;\n  addDragMoveTick(item._id, this._prepareMove, this._applyMove);\n  addDragSortTick(item._id, this._handleSort);\n};\n\n/**\n * Prepare dragged item for moving.\n *\n * @private\n */\nItemDrag.prototype._prepareMove = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var settings = this._getGrid()._settings;\n  var axis = settings.dragAxis;\n  var nextEvent = this._dragMoveEvent;\n  var prevEvent = this._dragPrevMoveEvent || this._dragStartEvent || nextEvent;\n\n  // Update horizontal position data.\n  if (axis !== 'y') {\n    var moveDiffX = nextEvent.clientX - prevEvent.clientX;\n    this._left = this._left - this._moveDiffX + moveDiffX;\n    this._gridX = this._gridX - this._moveDiffX + moveDiffX;\n    this._clientX = this._clientX - this._moveDiffX + moveDiffX;\n    this._moveDiffX = moveDiffX;\n  }\n\n  // Update vertical position data.\n  if (axis !== 'x') {\n    var moveDiffY = nextEvent.clientY - prevEvent.clientY;\n    this._top = this._top - this._moveDiffY + moveDiffY;\n    this._gridY = this._gridY - this._moveDiffY + moveDiffY;\n    this._clientY = this._clientY - this._moveDiffY + moveDiffY;\n    this._moveDiffY = moveDiffY;\n  }\n\n  this._dragPrevMoveEvent = nextEvent;\n};\n\n/**\n * Apply movement to dragged item.\n *\n * @private\n */\nItemDrag.prototype._applyMove = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  this._moveDiffX = this._moveDiffY = 0;\n  item._setTranslate(this._left, this._top);\n  this._getGrid()._emit(EVENT_DRAG_MOVE, item, this._dragMoveEvent);\n  ItemDrag.autoScroller.updateItem(item);\n};\n\n/**\n * Drag scroll handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onScroll = function (event) {\n  var item = this._item;\n\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  this._scrollEvent = event;\n  addDragScrollTick(item._id, this._prepareScroll, this._applyScroll);\n  addDragSortTick(item._id, this._handleSort);\n};\n\n/**\n * Prepare dragged item for scrolling.\n *\n * @private\n */\nItemDrag.prototype._prepareScroll = function () {\n  if (!this._isActive) return;\n\n  // If item is not active do nothing.\n  var item = this._item;\n  if (!item._isActive) return;\n\n  var element = item._element;\n  var grid = this._getGrid();\n  var gridContainer = grid._element;\n  var rect = element.getBoundingClientRect();\n\n  // Update container diff.\n  if (this._container !== gridContainer) {\n    var offsetDiff = getOffsetDiff(this._containingBlock, gridContainer);\n    this._containerDiffX = offsetDiff.left;\n    this._containerDiffY = offsetDiff.top;\n  }\n\n  // Update horizontal position data.\n  var scrollDiffX = this._clientX - this._moveDiffX - rect.left;\n  this._left = this._left - this._scrollDiffX + scrollDiffX;\n  this._scrollDiffX = scrollDiffX;\n\n  // Update vertical position data.\n  var scrollDiffY = this._clientY - this._moveDiffY - rect.top;\n  this._top = this._top - this._scrollDiffY + scrollDiffY;\n  this._scrollDiffY = scrollDiffY;\n\n  // Update grid position.\n  this._gridX = this._left - this._containerDiffX;\n  this._gridY = this._top - this._containerDiffY;\n};\n\n/**\n * Apply scroll to dragged item.\n *\n * @private\n */\nItemDrag.prototype._applyScroll = function () {\n  if (!this._isActive) return;\n\n  var item = this._item;\n  if (!item._isActive) return;\n\n  this._scrollDiffX = this._scrollDiffY = 0;\n  item._setTranslate(this._left, this._top);\n  this._getGrid()._emit(EVENT_DRAG_SCROLL, item, this._scrollEvent);\n};\n\n/**\n * Drag end handler.\n *\n * @private\n * @param {Object} event\n */\nItemDrag.prototype._onEnd = function (event) {\n  var item = this._item;\n  var element = item._element;\n  var grid = this._getGrid();\n  var settings = grid._settings;\n  var release = item._dragRelease;\n\n  // If item is not active, reset drag.\n  if (!item._isActive) {\n    this.stop();\n    return;\n  }\n\n  // Cancel queued ticks.\n  cancelDragStartTick(item._id);\n  cancelDragMoveTick(item._id);\n  cancelDragScrollTick(item._id);\n\n  // Finish sort procedure (does final overlap check if needed).\n  this._finishSort();\n\n  // Remove scroll listeners.\n  this._unbindScrollListeners();\n\n  // Setup release data.\n  release._containerDiffX = this._containerDiffX;\n  release._containerDiffY = this._containerDiffY;\n\n  // Reset drag data.\n  this._reset();\n\n  // Remove drag class name from element.\n  removeClass(element, settings.itemDraggingClass);\n\n  // Stop auto-scroll.\n  ItemDrag.autoScroller.removeItem(item);\n\n  // Emit dragEnd event.\n  grid._emit(EVENT_DRAG_END, item, event);\n\n  // Finish up the migration process or start the release process.\n  this._isMigrating ? this._finishMigration() : release.start();\n};\n\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Check if an element is an anchor element and open the href url if possible.\n *\n * @param {HTMLElement} element\n */\nfunction openAnchorHref(element) {\n  // Make sure the element is anchor element.\n  if (element.tagName.toLowerCase() !== 'a') return;\n\n  // Get href and make sure it exists.\n  var href = element.getAttribute('href');\n  if (!href) return;\n\n  // Finally let's navigate to the link href.\n  var target = element.getAttribute('target');\n  if (target && target !== '_self') {\n    window.open(href, target);\n  } else {\n    window.location.href = href;\n  }\n}\n\n/**\n * Get current values of the provided styles definition object or array.\n *\n * @param {HTMLElement} element\n * @param {(Object|Array} styles\n * @return {Object}\n */\nfunction getCurrentStyles(element, styles) {\n  var result = {};\n  var prop, i;\n\n  if (Array.isArray(styles)) {\n    for (i = 0; i < styles.length; i++) {\n      prop = styles[i];\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  } else {\n    for (prop in styles) {\n      result[prop] = getStyle(element, getStyleName(prop));\n    }\n  }\n\n  return result;\n}\n\nvar unprefixRegEx = /^(webkit|moz|ms|o|Webkit|Moz|MS|O)(?=[A-Z])/;\nvar cache = {};\n\n/**\n * Remove any potential vendor prefixes from a property name.\n *\n * @param {String} prop\n * @returns {String}\n */\nfunction getUnprefixedPropName(prop) {\n  var result = cache[prop];\n  if (result) return result;\n\n  result = prop.replace(unprefixRegEx, '');\n\n  if (result !== prop) {\n    result = result[0].toLowerCase() + result.slice(1);\n  }\n\n  cache[prop] = result;\n\n  return result;\n}\n\nvar nativeCode = '[native code]';\n\n/**\n * Check if a value (e.g. a method or constructor) is native code. Good for\n * detecting when a polyfill is used and when not.\n *\n * @param {*} feat\n * @returns {Boolean}\n */\nfunction isNative(feat) {\n  var S = window.Symbol;\n  return !!(\n    feat &&\n    isFunction(S) &&\n    isFunction(S.toString) &&\n    S(feat).toString().indexOf(nativeCode) > -1\n  );\n}\n\n/**\n * Set inline styles to an element.\n *\n * @param {HTMLElement} element\n * @param {Object} styles\n */\nfunction setStyles(element, styles) {\n  for (var prop in styles) {\n    element.style[prop] = styles[prop];\n  }\n}\n\nvar HAS_WEB_ANIMATIONS = !!(Element && isFunction(Element.prototype.animate));\nvar HAS_NATIVE_WEB_ANIMATIONS = !!(Element && isNative(Element.prototype.animate));\n\n/**\n * Item animation handler powered by Web Animations API.\n *\n * @class\n * @param {HTMLElement} element\n */\nfunction Animator(element) {\n  this._element = element;\n  this._animation = null;\n  this._duration = 0;\n  this._easing = '';\n  this._callback = null;\n  this._props = [];\n  this._values = [];\n  this._isDestroyed = false;\n  this._onFinish = this._onFinish.bind(this);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start instance's animation. Automatically stops current animation if it is\n * running.\n *\n * @public\n * @param {Object} propsFrom\n * @param {Object} propsTo\n * @param {Object} [options]\n * @param {Number} [options.duration=300]\n * @param {String} [options.easing='ease']\n * @param {Function} [options.onFinish]\n */\nAnimator.prototype.start = function (propsFrom, propsTo, options) {\n  if (this._isDestroyed) return;\n\n  var element = this._element;\n  var opts = options || {};\n\n  // If we don't have web animations available let's not animate.\n  if (!HAS_WEB_ANIMATIONS) {\n    setStyles(element, propsTo);\n    this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n    this._onFinish();\n    return;\n  }\n\n  var animation = this._animation;\n  var currentProps = this._props;\n  var currentValues = this._values;\n  var duration = opts.duration || 300;\n  var easing = opts.easing || 'ease';\n  var cancelAnimation = false;\n  var propName, propCount, propIndex;\n\n  // If we have an existing animation running, let's check if it needs to be\n  // cancelled or if it can continue running.\n  if (animation) {\n    propCount = 0;\n\n    // Cancel animation if duration or easing has changed.\n    if (duration !== this._duration || easing !== this._easing) {\n      cancelAnimation = true;\n    }\n\n    // Check if the requested animation target props and values match with the\n    // current props and values.\n    if (!cancelAnimation) {\n      for (propName in propsTo) {\n        ++propCount;\n        propIndex = currentProps.indexOf(propName);\n        if (propIndex === -1 || propsTo[propName] !== currentValues[propIndex]) {\n          cancelAnimation = true;\n          break;\n        }\n      }\n\n      // Check if the target props count matches current props count. This is\n      // needed for the edge case scenario where target props contain the same\n      // styles as current props, but the current props have some additional\n      // props.\n      if (propCount !== currentProps.length) {\n        cancelAnimation = true;\n      }\n    }\n  }\n\n  // Cancel animation (if required).\n  if (cancelAnimation) animation.cancel();\n\n  // Store animation callback.\n  this._callback = isFunction(opts.onFinish) ? opts.onFinish : null;\n\n  // If we have a running animation that does not need to be cancelled, let's\n  // call it a day here and let it run.\n  if (animation && !cancelAnimation) return;\n\n  // Store target props and values to instance.\n  currentProps.length = currentValues.length = 0;\n  for (propName in propsTo) {\n    currentProps.push(propName);\n    currentValues.push(propsTo[propName]);\n  }\n\n  // Start the animation. We need to provide unprefixed property names to the\n  // Web Animations polyfill if it is being used. If we have native Web\n  // Animations available we need to provide prefixed properties instead.\n  this._duration = duration;\n  this._easing = easing;\n  this._animation = element.animate(\n    [\n      createFrame(propsFrom, HAS_NATIVE_WEB_ANIMATIONS),\n      createFrame(propsTo, HAS_NATIVE_WEB_ANIMATIONS),\n    ],\n    {\n      duration: duration,\n      easing: easing,\n    }\n  );\n  this._animation.onfinish = this._onFinish;\n\n  // Set the end styles. This makes sure that the element stays at the end\n  // values after animation is finished.\n  setStyles(element, propsTo);\n};\n\n/**\n * Stop instance's current animation if running.\n *\n * @public\n */\nAnimator.prototype.stop = function () {\n  if (this._isDestroyed || !this._animation) return;\n  this._animation.cancel();\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n};\n\n/**\n * Read the current values of the element's animated styles from the DOM.\n *\n * @public\n * @return {Object}\n */\nAnimator.prototype.getCurrentStyles = function () {\n  return getCurrentStyles(element, currentProps);\n};\n\n/**\n * Check if the item is being animated currently.\n *\n * @public\n * @return {Boolean}\n */\nAnimator.prototype.isAnimating = function () {\n  return !!this._animation;\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nAnimator.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop();\n  this._element = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Animation end handler.\n *\n * @private\n */\nAnimator.prototype._onFinish = function () {\n  var callback = this._callback;\n  this._animation = this._callback = null;\n  this._props.length = this._values.length = 0;\n  callback && callback();\n};\n\n/**\n * Private helpers\n * ***************\n */\n\nfunction createFrame(props, prefix) {\n  var frame = {};\n  for (var prop in props) {\n    frame[prefix ? prop : getUnprefixedPropName(prop)] = props[prop];\n  }\n  return frame;\n}\n\n/**\n * Transform translateX and translateY value into CSS transform style\n * property's value.\n *\n * @param {Number} x\n * @param {Number} y\n * @returns {String}\n */\nfunction getTranslateString(x, y) {\n  return 'translateX(' + x + 'px) translateY(' + y + 'px)';\n}\n\n/**\n * Drag placeholder.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDragPlaceholder(item) {\n  this._item = item;\n  this._animation = new Animator();\n  this._element = null;\n  this._className = '';\n  this._didMigrate = false;\n  this._resetAfterLayout = false;\n  this._left = 0;\n  this._top = 0;\n  this._transX = 0;\n  this._transY = 0;\n  this._nextTransX = 0;\n  this._nextTransY = 0;\n\n  // Bind animation handlers.\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n  this._updateDimensions = this._updateDimensions.bind(this);\n\n  // Bind event handlers.\n  this._onLayoutStart = this._onLayoutStart.bind(this);\n  this._onLayoutEnd = this._onLayoutEnd.bind(this);\n  this._onReleaseEnd = this._onReleaseEnd.bind(this);\n  this._onMigrate = this._onMigrate.bind(this);\n  this._onHide = this._onHide.bind(this);\n}\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Update placeholder's dimensions to match the item's dimensions.\n *\n * @private\n */\nItemDragPlaceholder.prototype._updateDimensions = function () {\n  if (!this.isActive()) return;\n  setStyles(this._element, {\n    width: this._item._width + 'px',\n    height: this._item._height + 'px',\n  });\n};\n\n/**\n * Move placeholder to a new position.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} isInstant\n */\nItemDragPlaceholder.prototype._onLayoutStart = function (items, isInstant) {\n  var item = this._item;\n\n  // If the item is not part of the layout anymore reset placeholder.\n  if (items.indexOf(item) === -1) {\n    this.reset();\n    return;\n  }\n\n  var nextLeft = item._left;\n  var nextTop = item._top;\n  var currentLeft = this._left;\n  var currentTop = this._top;\n\n  // Keep track of item layout position.\n  this._left = nextLeft;\n  this._top = nextTop;\n\n  // If item's position did not change, and the item did not migrate and the\n  // layout is not instant and we can safely skip layout.\n  if (!isInstant && !this._didMigrate && currentLeft === nextLeft && currentTop === nextTop) {\n    return;\n  }\n\n  // Slots data is calculated with item margins added to them so we need to add\n  // item's left and top margin to the slot data to get the placeholder's\n  // next position.\n  var nextX = nextLeft + item._marginLeft;\n  var nextY = nextTop + item._marginTop;\n\n  // Just snap to new position without any animations if no animation is\n  // required or if placeholder moves between grids.\n  var grid = item.getGrid();\n  var animEnabled = !isInstant && grid._settings.layoutDuration > 0;\n  if (!animEnabled || this._didMigrate) {\n    // Cancel potential (queued) layout tick.\n    cancelPlaceholderLayoutTick(item._id);\n\n    // Snap placeholder to correct position.\n    this._element.style[transformProp] = getTranslateString(nextX, nextY);\n    this._animation.stop();\n\n    // Move placeholder inside correct container after migration.\n    if (this._didMigrate) {\n      grid.getElement().appendChild(this._element);\n      this._didMigrate = false;\n    }\n\n    return;\n  }\n\n  // Start the placeholder's layout animation in the next tick. We do this to\n  // avoid layout thrashing.\n  this._nextTransX = nextX;\n  this._nextTransY = nextY;\n  addPlaceholderLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n\n/**\n * Prepare placeholder for layout animation.\n *\n * @private\n */\nItemDragPlaceholder.prototype._setupAnimation = function () {\n  if (!this.isActive()) return;\n\n  var translate = getTranslate(this._element);\n  this._transX = translate.x;\n  this._transY = translate.y;\n};\n\n/**\n * Start layout animation.\n *\n * @private\n */\nItemDragPlaceholder.prototype._startAnimation = function () {\n  if (!this.isActive()) return;\n\n  var animation = this._animation;\n  var currentX = this._transX;\n  var currentY = this._transY;\n  var nextX = this._nextTransX;\n  var nextY = this._nextTransY;\n\n  // If placeholder is already in correct position let's just stop animation\n  // and be done with it.\n  if (currentX === nextX && currentY === nextY) {\n    if (animation.isAnimating()) {\n      this._element.style[transformProp] = getTranslateString(nextX, nextY);\n      animation.stop();\n    }\n    return;\n  }\n\n  // Otherwise let's start the animation.\n  var settings = this._item.getGrid()._settings;\n  var currentStyles = {};\n  var targetStyles = {};\n  currentStyles[transformProp] = getTranslateString(currentX, currentY);\n  targetStyles[transformProp] = getTranslateString(nextX, nextY);\n  animation.start(currentStyles, targetStyles, {\n    duration: settings.layoutDuration,\n    easing: settings.layoutEasing,\n    onFinish: this._onLayoutEnd,\n  });\n};\n\n/**\n * Layout end handler.\n *\n * @private\n */\nItemDragPlaceholder.prototype._onLayoutEnd = function () {\n  if (this._resetAfterLayout) {\n    this.reset();\n  }\n};\n\n/**\n * Drag end handler. This handler is called when dragReleaseEnd event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Item} item\n */\nItemDragPlaceholder.prototype._onReleaseEnd = function (item) {\n  if (item._id === this._item._id) {\n    // If the placeholder is not animating anymore we can safely reset it.\n    if (!this._animation.isAnimating()) {\n      this.reset();\n      return;\n    }\n\n    // If the placeholder item is still animating here, let's wait for it to\n    // finish it's animation.\n    this._resetAfterLayout = true;\n  }\n};\n\n/**\n * Migration start handler. This handler is called when beforeSend event is\n * emitted and receives the event data as it's argument.\n *\n * @private\n * @param {Object} data\n * @param {Item} data.item\n * @param {Grid} data.fromGrid\n * @param {Number} data.fromIndex\n * @param {Grid} data.toGrid\n * @param {Number} data.toIndex\n */\nItemDragPlaceholder.prototype._onMigrate = function (data) {\n  // Make sure we have a matching item.\n  if (data.item !== this._item) return;\n\n  var grid = this._item.getGrid();\n  var nextGrid = data.toGrid;\n\n  // Unbind listeners from current grid.\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide);\n\n  // Bind listeners to the next grid.\n  nextGrid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  nextGrid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  nextGrid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  nextGrid.on(EVENT_HIDE_START, this._onHide);\n\n  // Mark the item as migrated.\n  this._didMigrate = true;\n};\n\n/**\n * Reset placeholder if the associated item is hidden.\n *\n * @private\n * @param {Item[]} items\n */\nItemDragPlaceholder.prototype._onHide = function (items) {\n  if (items.indexOf(this._item) > -1) this.reset();\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Create placeholder. Note that this method only writes to DOM and does not\n * read anything from DOM so it should not cause any additional layout\n * thrashing when it's called at the end of the drag start procedure.\n *\n * @public\n */\nItemDragPlaceholder.prototype.create = function () {\n  // If we already have placeholder set up we can skip the initiation logic.\n  if (this.isActive()) {\n    this._resetAfterLayout = false;\n    return;\n  }\n\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation;\n\n  // Keep track of layout position.\n  this._left = item._left;\n  this._top = item._top;\n\n  // Create placeholder element.\n  var element;\n  if (isFunction(settings.dragPlaceholder.createElement)) {\n    element = settings.dragPlaceholder.createElement(item);\n  } else {\n    element = document.createElement('div');\n  }\n  this._element = element;\n\n  // Update element to animation instance.\n  animation._element = element;\n\n  // Add placeholder class to the placeholder element.\n  this._className = settings.itemPlaceholderClass || '';\n  if (this._className) {\n    addClass(element, this._className);\n  }\n\n  // Set initial styles.\n  setStyles(element, {\n    position: 'absolute',\n    left: '0px',\n    top: '0px',\n    width: item._width + 'px',\n    height: item._height + 'px',\n  });\n\n  // Set initial position.\n  element.style[transformProp] = getTranslateString(\n    item._left + item._marginLeft,\n    item._top + item._marginTop\n  );\n\n  // Bind event listeners.\n  grid.on(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.on(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.on(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.on(EVENT_HIDE_START, this._onHide);\n\n  // onCreate hook.\n  if (isFunction(settings.dragPlaceholder.onCreate)) {\n    settings.dragPlaceholder.onCreate(item, element);\n  }\n\n  // Insert the placeholder element to the grid.\n  grid.getElement().appendChild(element);\n};\n\n/**\n * Reset placeholder data.\n *\n * @public\n */\nItemDragPlaceholder.prototype.reset = function () {\n  if (!this.isActive()) return;\n\n  var element = this._element;\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var animation = this._animation;\n\n  // Reset flag.\n  this._resetAfterLayout = false;\n\n  // Cancel potential (queued) layout tick.\n  cancelPlaceholderLayoutTick(item._id);\n  cancelPlaceholderResizeTick(item._id);\n\n  // Reset animation instance.\n  animation.stop();\n  animation._element = null;\n\n  // Unbind event listeners.\n  grid.off(EVENT_DRAG_RELEASE_END, this._onReleaseEnd);\n  grid.off(EVENT_LAYOUT_START, this._onLayoutStart);\n  grid.off(EVENT_BEFORE_SEND, this._onMigrate);\n  grid.off(EVENT_HIDE_START, this._onHide);\n\n  // Remove placeholder class from the placeholder element.\n  if (this._className) {\n    removeClass(element, this._className);\n    this._className = '';\n  }\n\n  // Remove element.\n  element.parentNode.removeChild(element);\n  this._element = null;\n\n  // onRemove hook. Note that here we use the current grid's onRemove callback\n  // so if the item has migrated during drag the onRemove method will not be\n  // the originating grid's method.\n  if (isFunction(settings.dragPlaceholder.onRemove)) {\n    settings.dragPlaceholder.onRemove(item, element);\n  }\n};\n\n/**\n * Check if placeholder is currently active (visible).\n *\n * @public\n * @returns {Boolean}\n */\nItemDragPlaceholder.prototype.isActive = function () {\n  return !!this._element;\n};\n\n/**\n * Get placeholder element.\n *\n * @public\n * @returns {?HTMLElement}\n */\nItemDragPlaceholder.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Update placeholder's dimensions to match the item's dimensions. Note that\n * the updating is done asynchronously in the next tick to avoid layout\n * thrashing.\n *\n * @public\n */\nItemDragPlaceholder.prototype.updateDimensions = function () {\n  if (!this.isActive()) return;\n  addPlaceholderResizeTick(this._item._id, this._updateDimensions);\n};\n\n/**\n * Destroy placeholder instance.\n *\n * @public\n */\nItemDragPlaceholder.prototype.destroy = function () {\n  this.reset();\n  this._animation.destroy();\n  this._item = this._animation = null;\n};\n\n/**\n * The release process handler constructor. Although this might seem as proper\n * fit for the drag process this needs to be separated into it's own logic\n * because there might be a scenario where drag is disabled, but the release\n * process still needs to be implemented (dragging from a grid to another).\n *\n * @class\n * @param {Item} item\n */\nfunction ItemDragRelease(item) {\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the release process of an item.\n *\n * @public\n */\nItemDragRelease.prototype.start = function () {\n  if (this._isDestroyed || this._isActive) return;\n\n  var item = this._item;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  this._isActive = true;\n  addClass(item._element, settings.itemReleasingClass);\n  if (!settings.dragRelease.useDragContainer) {\n    this._placeToGrid();\n  }\n  grid._emit(EVENT_DRAG_RELEASE_START, item);\n\n  // Let's start layout manually _only_ if there is no unfinished layout in\n  // about to finish.\n  if (!grid._nextLayoutData) item._layout.start(false);\n};\n\n/**\n * End the release process of an item. This method can be used to abort an\n * ongoing release process (animation) or finish the release process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the release be aborted? When true, the release end event won't be\n *    emitted. Set to true only when you need to abort the release process\n *    while the item is animating to it's position.\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\nItemDragRelease.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n\n  var item = this._item;\n  var grid = item.getGrid();\n\n  if (!abort && (left === undefined || top === undefined)) {\n    left = item._left;\n    top = item._top;\n  }\n\n  var didReparent = this._placeToGrid(left, top);\n  this._reset(didReparent);\n\n  if (!abort) grid._emit(EVENT_DRAG_RELEASE_END, item);\n};\n\nItemDragRelease.prototype.isJustReleased = function () {\n  return this._isActive && this._isPositioningStarted === false;\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemDragRelease.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Move the element back to the grid container element if it does not exist\n * there already.\n *\n * @private\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n * @returns {Boolean}\n *   - Returns `true` if the element was reparented.\n */\nItemDragRelease.prototype._placeToGrid = function (left, top) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var container = item.getGrid()._element;\n  var didReparent = false;\n\n  if (element.parentNode !== container) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(element);\n      left = translate.x - this._containerDiffX;\n      top = translate.y - this._containerDiffY;\n    }\n\n    container.appendChild(element);\n    item._setTranslate(left, top);\n    didReparent = true;\n  }\n\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n\n  return didReparent;\n};\n\n/**\n * Reset data and remove releasing class.\n *\n * @private\n * @param {Boolean} [needsReflow]\n */\nItemDragRelease.prototype._reset = function (needsReflow) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var releasingClass = item.getGrid()._settings.itemReleasingClass;\n\n  this._isActive = false;\n  this._isPositioningStarted = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n\n  // If the element was just reparented we need to do a forced reflow to remove\n  // the class gracefully.\n  if (releasingClass) {\n    // eslint-disable-next-line\n    if (needsReflow) item._element.clientWidth;\n    removeClass(item._element, releasingClass);\n  }\n};\n\nvar MIN_ANIMATION_DISTANCE = 2;\n\n/**\n * Layout manager for Item instance, handles the positioning of an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemLayout(item) {\n  var element = item._element;\n  var elementStyle = element.style;\n\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._isInterrupted = false;\n  this._currentStyles = {};\n  this._targetStyles = {};\n  this._nextLeft = 0;\n  this._nextTop = 0;\n  this._offsetLeft = 0;\n  this._offsetTop = 0;\n  this._skipNextAnimation = false;\n  this._animOptions = {\n    onFinish: this._finish.bind(this),\n    duration: 0,\n    easing: 0,\n  };\n\n  // Set element's initial position styles.\n  elementStyle.left = '0px';\n  elementStyle.top = '0px';\n  item._setTranslate(0, 0);\n\n  this._animation = new Animator(element);\n  this._queue = 'layout-' + item._id;\n\n  // Bind animation handlers and finish method.\n  this._setupAnimation = this._setupAnimation.bind(this);\n  this._startAnimation = this._startAnimation.bind(this);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start item layout based on it's current data.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemLayout.prototype.start = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var release = item._dragRelease;\n  var gridSettings = item.getGrid()._settings;\n  var isPositioning = this._isActive;\n  var isJustReleased = release.isJustReleased();\n  var animDuration = isJustReleased\n    ? gridSettings.dragRelease.duration\n    : gridSettings.layoutDuration;\n  var animEasing = isJustReleased ? gridSettings.dragRelease.easing : gridSettings.layoutEasing;\n  var animEnabled = !instant && !this._skipNextAnimation && animDuration > 0;\n\n  // If the item is currently positioning cancel potential queued layout tick\n  // and process current layout callback queue with interrupted flag on.\n  if (isPositioning) {\n    cancelLayoutTick(item._id);\n    item._emitter.burst(this._queue, true, item);\n  }\n\n  // Mark release positioning as started.\n  if (isJustReleased) release._isPositioningStarted = true;\n\n  // Push the callback to the callback queue.\n  if (isFunction(onFinish)) {\n    item._emitter.on(this._queue, onFinish);\n  }\n\n  // Reset animation skipping flag.\n  this._skipNextAnimation = false;\n\n  // If no animations are needed, easy peasy!\n  if (!animEnabled) {\n    this._updateOffsets();\n    item._setTranslate(this._nextLeft, this._nextTop);\n    this._animation.stop();\n    this._finish();\n    return;\n  }\n\n  // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n  if (this._animation.isAnimating()) {\n    this._animation._animation.onfinish = null;\n  }\n\n  // Kick off animation to be started in the next tick.\n  this._isActive = true;\n  this._animOptions.easing = animEasing;\n  this._animOptions.duration = animDuration;\n  this._isInterrupted = isPositioning;\n  addLayoutTick(item._id, this._setupAnimation, this._startAnimation);\n};\n\n/**\n * Stop item's position animation if it is currently animating.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n * @param {Number} [left]\n * @param {Number} [top]\n */\nItemLayout.prototype.stop = function (processCallbackQueue, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n\n  var item = this._item;\n\n  // Cancel animation init.\n  cancelLayoutTick(item._id);\n\n  // Stop animation.\n  if (this._animation.isAnimating()) {\n    if (left === undefined || top === undefined) {\n      var translate = getTranslate(item._element);\n      left = translate.x;\n      top = translate.y;\n    }\n    item._setTranslate(left, top);\n    this._animation.stop();\n  }\n\n  // Remove positioning class.\n  removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n\n  // Reset active state.\n  this._isActive = false;\n\n  // Process callback queue if needed.\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nItemLayout.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var elementStyle = this._item._element.style;\n\n  this.stop(true, 0, 0);\n  this._item._emitter.clear(this._queue);\n  this._animation.destroy();\n\n  elementStyle[transformProp] = '';\n  elementStyle.left = '';\n  elementStyle.top = '';\n\n  this._item = null;\n  this._currentStyles = null;\n  this._targetStyles = null;\n  this._animOptions = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Calculate and update item's current layout offset data.\n *\n * @private\n */\nItemLayout.prototype._updateOffsets = function () {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n\n  this._offsetLeft = release._isActive\n    ? release._containerDiffX\n    : migrate._isActive\n    ? migrate._containerDiffX\n    : 0;\n\n  this._offsetTop = release._isActive\n    ? release._containerDiffY\n    : migrate._isActive\n    ? migrate._containerDiffY\n    : 0;\n\n  this._nextLeft = this._item._left + this._offsetLeft;\n  this._nextTop = this._item._top + this._offsetTop;\n};\n\n/**\n * Finish item layout procedure.\n *\n * @private\n */\nItemLayout.prototype._finish = function () {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var migrate = item._migrate;\n  var release = item._dragRelease;\n\n  // Update internal translate values.\n  item._tX = this._nextLeft;\n  item._tY = this._nextTop;\n\n  // Mark the item as inactive and remove positioning classes.\n  if (this._isActive) {\n    this._isActive = false;\n    removeClass(item._element, item.getGrid()._settings.itemPositioningClass);\n  }\n\n  // Finish up release and migration.\n  if (release._isActive) release.stop();\n  if (migrate._isActive) migrate.stop();\n\n  // Process the callback queue.\n  item._emitter.burst(this._queue, false, item);\n};\n\n/**\n * Prepare item for layout animation.\n *\n * @private\n */\nItemLayout.prototype._setupAnimation = function () {\n  var item = this._item;\n  if (item._tX === undefined || item._tY === undefined) {\n    var translate = getTranslate(item._element);\n    item._tX = translate.x;\n    item._tY = translate.y;\n  }\n};\n\n/**\n * Start layout animation.\n *\n * @private\n */\nItemLayout.prototype._startAnimation = function () {\n  var item = this._item;\n  var settings = item.getGrid()._settings;\n  var isInstant = this._animOptions.duration <= 0;\n\n  // Let's update the offset data and target styles.\n  this._updateOffsets();\n\n  var xDiff = Math.abs(item._left - (item._tX - this._offsetLeft));\n  var yDiff = Math.abs(item._top - (item._tY - this._offsetTop));\n\n  // If there is no need for animation or if the item is already in correct\n  // position (or near it) let's finish the process early.\n  if (isInstant || (xDiff < MIN_ANIMATION_DISTANCE && yDiff < MIN_ANIMATION_DISTANCE)) {\n    if (xDiff || yDiff || this._isInterrupted) {\n      item._setTranslate(this._nextLeft, this._nextTop);\n    }\n    this._animation.stop();\n    this._finish();\n    return;\n  }\n\n  // Set item's positioning class if needed.\n  if (!this._isInterrupted) {\n    addClass(item._element, settings.itemPositioningClass);\n  }\n\n  // Get current/next styles for animation.\n  this._currentStyles[transformProp] = getTranslateString(item._tX, item._tY);\n  this._targetStyles[transformProp] = getTranslateString(this._nextLeft, this._nextTop);\n\n  // Set internal translation values to undefined for the duration of the\n  // animation since they will be changing on each animation frame for the\n  // duration of the animation and tracking them would mean reading the DOM on\n  // each frame, which is pretty darn expensive.\n  item._tX = item._tY = undefined;\n\n  // Start animation.\n  this._animation.start(this._currentStyles, this._targetStyles, this._animOptions);\n};\n\n/**\n * The migrate process handler constructor.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemMigrate(item) {\n  // Private props.\n  this._item = item;\n  this._isActive = false;\n  this._isDestroyed = false;\n  this._container = false;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Start the migrate process of an item.\n *\n * @public\n * @param {Grid} targetGrid\n * @param {(HTMLElement|Number|Item)} position\n * @param {HTMLElement} [container]\n */\nItemMigrate.prototype.start = function (targetGrid, position, container) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var isActive = item.isActive();\n  var isVisible = item.isVisible();\n  var grid = item.getGrid();\n  var settings = grid._settings;\n  var targetSettings = targetGrid._settings;\n  var targetElement = targetGrid._element;\n  var targetItems = targetGrid._items;\n  var currentIndex = grid._items.indexOf(item);\n  var targetContainer = container || document.body;\n  var targetIndex;\n  var targetItem;\n  var currentContainer;\n  var offsetDiff;\n  var containerDiff;\n  var translate;\n  var translateX;\n  var translateY;\n  var currentVisClass;\n  var nextVisClass;\n\n  // Get target index.\n  if (typeof position === 'number') {\n    targetIndex = normalizeArrayIndex(targetItems, position, 1);\n  } else {\n    targetItem = targetGrid.getItem(position);\n    if (!targetItem) return;\n    targetIndex = targetItems.indexOf(targetItem);\n  }\n\n  // Get current translateX and translateY values if needed.\n  if (item.isPositioning() || this._isActive || item.isReleasing()) {\n    translate = getTranslate(element);\n    translateX = translate.x;\n    translateY = translate.y;\n  }\n\n  // Abort current positioning.\n  if (item.isPositioning()) {\n    item._layout.stop(true, translateX, translateY);\n  }\n\n  // Abort current migration.\n  if (this._isActive) {\n    translateX -= this._containerDiffX;\n    translateY -= this._containerDiffY;\n    this.stop(true, translateX, translateY);\n  }\n\n  // Abort current release.\n  if (item.isReleasing()) {\n    translateX -= item._dragRelease._containerDiffX;\n    translateY -= item._dragRelease._containerDiffY;\n    item._dragRelease.stop(true, translateX, translateY);\n  }\n\n  // Stop current visibility animation.\n  item._visibility.stop(true);\n\n  // Destroy current drag.\n  if (item._drag) item._drag.destroy();\n\n  // Emit beforeSend event.\n  if (grid._hasListeners(EVENT_BEFORE_SEND)) {\n    grid._emit(EVENT_BEFORE_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n\n  // Emit beforeReceive event.\n  if (targetGrid._hasListeners(EVENT_BEFORE_RECEIVE)) {\n    targetGrid._emit(EVENT_BEFORE_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n\n  // Update item class.\n  if (settings.itemClass !== targetSettings.itemClass) {\n    removeClass(element, settings.itemClass);\n    addClass(element, targetSettings.itemClass);\n  }\n\n  // Update visibility class.\n  currentVisClass = isVisible ? settings.itemVisibleClass : settings.itemHiddenClass;\n  nextVisClass = isVisible ? targetSettings.itemVisibleClass : targetSettings.itemHiddenClass;\n  if (currentVisClass !== nextVisClass) {\n    removeClass(element, currentVisClass);\n    addClass(element, nextVisClass);\n  }\n\n  // Move item instance from current grid to target grid.\n  grid._items.splice(currentIndex, 1);\n  arrayInsert(targetItems, item, targetIndex);\n\n  // Update item's grid id reference.\n  item._gridId = targetGrid._id;\n\n  // If item is active we need to move the item inside the target container for\n  // the duration of the (potential) animation if it's different than the\n  // current container.\n  if (isActive) {\n    currentContainer = element.parentNode;\n    if (targetContainer !== currentContainer) {\n      targetContainer.appendChild(element);\n      offsetDiff = getOffsetDiff(targetContainer, currentContainer, true);\n      if (!translate) {\n        translate = getTranslate(element);\n        translateX = translate.x;\n        translateY = translate.y;\n      }\n      item._setTranslate(translateX + offsetDiff.left, translateY + offsetDiff.top);\n    }\n  }\n  // If item is not active let's just append it to the target grid's element.\n  else {\n    targetElement.appendChild(element);\n  }\n\n  // Update child element's styles to reflect the current visibility state.\n  item._visibility.setStyles(\n    isVisible ? targetSettings.visibleStyles : targetSettings.hiddenStyles\n  );\n\n  // Get offset diff for the migration data, if the item is active.\n  if (isActive) {\n    containerDiff = getOffsetDiff(targetContainer, targetElement, true);\n  }\n\n  // Update item's cached dimensions.\n  item._refreshDimensions();\n\n  // Reset item's sort data.\n  item._sortData = null;\n\n  // Create new drag handler.\n  item._drag = targetSettings.dragEnabled ? new ItemDrag(item) : null;\n\n  // Setup migration data.\n  if (isActive) {\n    this._isActive = true;\n    this._container = targetContainer;\n    this._containerDiffX = containerDiff.left;\n    this._containerDiffY = containerDiff.top;\n  } else {\n    this._isActive = false;\n    this._container = null;\n    this._containerDiffX = 0;\n    this._containerDiffY = 0;\n  }\n\n  // Emit send event.\n  if (grid._hasListeners(EVENT_SEND)) {\n    grid._emit(EVENT_SEND, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n\n  // Emit receive event.\n  if (targetGrid._hasListeners(EVENT_RECEIVE)) {\n    targetGrid._emit(EVENT_RECEIVE, {\n      item: item,\n      fromGrid: grid,\n      fromIndex: currentIndex,\n      toGrid: targetGrid,\n      toIndex: targetIndex,\n    });\n  }\n};\n\n/**\n * End the migrate process of an item. This method can be used to abort an\n * ongoing migrate process (animation) or finish the migrate process.\n *\n * @public\n * @param {Boolean} [abort=false]\n *  - Should the migration be aborted?\n * @param {Number} [left]\n *  - The element's current translateX value (optional).\n * @param {Number} [top]\n *  - The element's current translateY value (optional).\n */\nItemMigrate.prototype.stop = function (abort, left, top) {\n  if (this._isDestroyed || !this._isActive) return;\n\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var gridElement = grid._element;\n  var translate;\n\n  if (this._container !== gridElement) {\n    if (left === undefined || top === undefined) {\n      if (abort) {\n        translate = getTranslate(element);\n        left = translate.x - this._containerDiffX;\n        top = translate.y - this._containerDiffY;\n      } else {\n        left = item._left;\n        top = item._top;\n      }\n    }\n\n    gridElement.appendChild(element);\n    item._setTranslate(left, top);\n  }\n\n  this._isActive = false;\n  this._container = null;\n  this._containerDiffX = 0;\n  this._containerDiffY = 0;\n};\n\n/**\n * Destroy instance.\n *\n * @public\n */\nItemMigrate.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n  this.stop(true);\n  this._item = null;\n  this._isDestroyed = true;\n};\n\n/**\n * Visibility manager for Item instance, handles visibility of an item.\n *\n * @class\n * @param {Item} item\n */\nfunction ItemVisibility(item) {\n  var isActive = item._isActive;\n  var element = item._element;\n  var childElement = element.children[0];\n  var settings = item.getGrid()._settings;\n\n  if (!childElement) {\n    throw new Error('No valid child element found within item element.');\n  }\n\n  this._item = item;\n  this._isDestroyed = false;\n  this._isHidden = !isActive;\n  this._isHiding = false;\n  this._isShowing = false;\n  this._childElement = childElement;\n  this._currentStyleProps = [];\n  this._animation = new Animator(childElement);\n  this._queue = 'visibility-' + item._id;\n  this._finishShow = this._finishShow.bind(this);\n  this._finishHide = this._finishHide.bind(this);\n\n  element.style.display = isActive ? '' : 'none';\n  addClass(element, isActive ? settings.itemVisibleClass : settings.itemHiddenClass);\n  this.setStyles(isActive ? settings.visibleStyles : settings.hiddenStyles);\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Show item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype.show = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  // If item is visible call the callback and be done with it.\n  if (!this._isShowing && !this._isHidden) {\n    callback && callback(false, item);\n    return;\n  }\n\n  // If item is showing and does not need to be shown instantly, let's just\n  // push callback to the callback queue and be done with it.\n  if (this._isShowing && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  }\n\n  // If the item is hiding or hidden process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n  if (!this._isShowing) {\n    item._emitter.burst(this._queue, true, item);\n    removeClass(element, settings.itemHiddenClass);\n    addClass(element, settings.itemVisibleClass);\n    if (!this._isHiding) element.style.display = '';\n  }\n\n  // Push callback to the callback queue.\n  callback && item._emitter.on(this._queue, callback);\n\n  // Update visibility states.\n  this._isShowing = true;\n  this._isHiding = this._isHidden = false;\n\n  // Finally let's start show animation.\n  this._startAnimation(true, instant, this._finishShow);\n};\n\n/**\n * Hide item.\n *\n * @public\n * @param {Boolean} instant\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype.hide = function (instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var callback = isFunction(onFinish) ? onFinish : null;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  // If item is already hidden call the callback and be done with it.\n  if (!this._isHiding && this._isHidden) {\n    callback && callback(false, item);\n    return;\n  }\n\n  // If item is hiding and does not need to be hidden instantly, let's just\n  // push callback to the callback queue and be done with it.\n  if (this._isHiding && !instant) {\n    callback && item._emitter.on(this._queue, callback);\n    return;\n  }\n\n  // If the item is showing or visible process the current visibility callback\n  // queue with the interrupted flag active, update classes and set display\n  // to block if necessary.\n  if (!this._isHiding) {\n    item._emitter.burst(this._queue, true, item);\n    addClass(element, settings.itemHiddenClass);\n    removeClass(element, settings.itemVisibleClass);\n  }\n\n  // Push callback to the callback queue.\n  callback && item._emitter.on(this._queue, callback);\n\n  // Update visibility states.\n  this._isHidden = this._isHiding = true;\n  this._isShowing = false;\n\n  // Finally let's start hide animation.\n  this._startAnimation(false, instant, this._finishHide);\n};\n\n/**\n * Stop current hiding/showing process.\n *\n * @public\n * @param {Boolean} processCallbackQueue\n */\nItemVisibility.prototype.stop = function (processCallbackQueue) {\n  if (this._isDestroyed) return;\n  if (!this._isHiding && !this._isShowing) return;\n\n  var item = this._item;\n\n  cancelVisibilityTick(item._id);\n  this._animation.stop();\n  if (processCallbackQueue) {\n    item._emitter.burst(this._queue, true, item);\n  }\n};\n\n/**\n * Reset all existing visibility styles and apply new visibility styles to the\n * visibility element. This method should be used to set styles when there is a\n * chance that the current style properties differ from the new ones (basically\n * on init and on migrations).\n *\n * @public\n * @param {Object} styles\n */\nItemVisibility.prototype.setStyles = function (styles) {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n  this._removeCurrentStyles();\n  for (var prop in styles) {\n    currentStyleProps.push(prop);\n    childElement.style[prop] = styles[prop];\n  }\n};\n\n/**\n * Destroy the instance and stop current animation if it is running.\n *\n * @public\n */\nItemVisibility.prototype.destroy = function () {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var element = item._element;\n  var grid = item.getGrid();\n  var settings = grid._settings;\n\n  this.stop(true);\n  item._emitter.clear(this._queue);\n  this._animation.destroy();\n  this._removeCurrentStyles();\n  removeClass(element, settings.itemVisibleClass);\n  removeClass(element, settings.itemHiddenClass);\n  element.style.display = '';\n\n  // Reset state.\n  this._isHiding = this._isShowing = false;\n  this._isDestroyed = this._isHidden = true;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Start visibility animation.\n *\n * @private\n * @param {Boolean} toVisible\n * @param {Boolean} [instant]\n * @param {Function} [onFinish]\n */\nItemVisibility.prototype._startAnimation = function (toVisible, instant, onFinish) {\n  if (this._isDestroyed) return;\n\n  var item = this._item;\n  var animation = this._animation;\n  var childElement = this._childElement;\n  var settings = item.getGrid()._settings;\n  var targetStyles = toVisible ? settings.visibleStyles : settings.hiddenStyles;\n  var duration = toVisible ? settings.showDuration : settings.hideDuration;\n  var easing = toVisible ? settings.showEasing : settings.hideEasing;\n  var isInstant = instant || duration <= 0;\n  var currentStyles;\n\n  // No target styles? Let's quit early.\n  if (!targetStyles) {\n    onFinish && onFinish();\n    return;\n  }\n\n  // Cancel queued visibility tick.\n  cancelVisibilityTick(item._id);\n\n  // If we need to apply the styles instantly without animation.\n  if (isInstant) {\n    setStyles(childElement, targetStyles);\n    animation.stop();\n    onFinish && onFinish();\n    return;\n  }\n\n  // Let's make sure an ongoing animation's callback is cancelled before going\n  // further. Without this there's a chance that the animation will finish\n  // before the next tick and mess up our logic.\n  if (animation.isAnimating()) {\n    animation._animation.onfinish = null;\n  }\n\n  // Start the animation in the next tick (to avoid layout thrashing).\n  addVisibilityTick(\n    item._id,\n    function () {\n      currentStyles = getCurrentStyles(childElement, targetStyles);\n    },\n    function () {\n      animation.start(currentStyles, targetStyles, {\n        duration: duration,\n        easing: easing,\n        onFinish: onFinish,\n      });\n    }\n  );\n};\n\n/**\n * Finish show procedure.\n *\n * @private\n */\nItemVisibility.prototype._finishShow = function () {\n  if (this._isHidden) return;\n  this._isShowing = false;\n  this._item._emitter.burst(this._queue, false, this._item);\n};\n\n/**\n * Finish hide procedure.\n *\n * @private\n */\nItemVisibility.prototype._finishHide = function () {\n  if (!this._isHidden) return;\n  var item = this._item;\n  this._isHiding = false;\n  item._layout.stop(true, 0, 0);\n  item._element.style.display = 'none';\n  item._emitter.burst(this._queue, false, item);\n};\n\n/**\n * Remove currently applied visibility related inline style properties.\n *\n * @private\n */\nItemVisibility.prototype._removeCurrentStyles = function () {\n  var childElement = this._childElement;\n  var currentStyleProps = this._currentStyleProps;\n\n  for (var i = 0; i < currentStyleProps.length; i++) {\n    childElement.style[currentStyleProps[i]] = '';\n  }\n\n  currentStyleProps.length = 0;\n};\n\nvar id = 0;\n\n/**\n * Returns a unique numeric id (increments a base value on every call).\n * @returns {Number}\n */\nfunction createUid() {\n  return ++id;\n}\n\n/**\n * Creates a new Item instance for a Grid instance.\n *\n * @class\n * @param {Grid} grid\n * @param {HTMLElement} element\n * @param {Boolean} [isActive]\n */\nfunction Item(grid, element, isActive) {\n  var settings = grid._settings;\n\n  // Store item/element pair to a map (for faster item querying by element).\n  if (ITEM_ELEMENT_MAP) {\n    if (ITEM_ELEMENT_MAP.has(element)) {\n      throw new Error('You can only create one Muuri Item per element!');\n    } else {\n      ITEM_ELEMENT_MAP.set(element, this);\n    }\n  }\n\n  this._id = createUid();\n  this._gridId = grid._id;\n  this._element = element;\n  this._isDestroyed = false;\n  this._left = 0;\n  this._top = 0;\n  this._width = 0;\n  this._height = 0;\n  this._marginLeft = 0;\n  this._marginRight = 0;\n  this._marginTop = 0;\n  this._marginBottom = 0;\n  this._tX = undefined;\n  this._tY = undefined;\n  this._sortData = null;\n  this._emitter = new Emitter();\n\n  // If the provided item element is not a direct child of the grid container\n  // element, append it to the grid container. Note, we are indeed reading the\n  // DOM here but it's a property that does not cause reflowing.\n  if (element.parentNode !== grid._element) {\n    grid._element.appendChild(element);\n  }\n\n  // Set item class.\n  addClass(element, settings.itemClass);\n\n  // If isActive is not defined, let's try to auto-detect it. Note, we are\n  // indeed reading the DOM here but it's a property that does not cause\n  // reflowing.\n  if (typeof isActive !== 'boolean') {\n    isActive = getStyle(element, 'display') !== 'none';\n  }\n\n  // Set up active state (defines if the item is considered part of the layout\n  // or not).\n  this._isActive = isActive;\n\n  // Setup visibility handler.\n  this._visibility = new ItemVisibility(this);\n\n  // Set up layout handler.\n  this._layout = new ItemLayout(this);\n\n  // Set up migration handler data.\n  this._migrate = new ItemMigrate(this);\n\n  // Set up drag handler.\n  this._drag = settings.dragEnabled ? new ItemDrag(this) : null;\n\n  // Set up release handler. Note that although this is fully linked to dragging\n  // this still needs to be always instantiated to handle migration scenarios\n  // correctly.\n  this._dragRelease = new ItemDragRelease(this);\n\n  // Set up drag placeholder handler. Note that although this is fully linked to\n  // dragging this still needs to be always instantiated to handle migration\n  // scenarios correctly.\n  this._dragPlaceholder = new ItemDragPlaceholder(this);\n\n  // Note! You must call the following methods before you start using the\n  // instance. They are deliberately not called in the end as it would cause\n  // potentially a massive amount of reflows if multiple items were instantiated\n  // in a loop.\n  // this._refreshDimensions();\n  // this._refreshSortData();\n}\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Get the instance grid reference.\n *\n * @public\n * @returns {Grid}\n */\nItem.prototype.getGrid = function () {\n  return GRID_INSTANCES[this._gridId];\n};\n\n/**\n * Get the instance element.\n *\n * @public\n * @returns {HTMLElement}\n */\nItem.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Get instance element's cached width.\n *\n * @public\n * @returns {Number}\n */\nItem.prototype.getWidth = function () {\n  return this._width;\n};\n\n/**\n * Get instance element's cached height.\n *\n * @public\n * @returns {Number}\n */\nItem.prototype.getHeight = function () {\n  return this._height;\n};\n\n/**\n * Get instance element's cached margins.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left, right, top and bottom properties\n *     which indicate the item element's cached margins.\n */\nItem.prototype.getMargin = function () {\n  return {\n    left: this._marginLeft,\n    right: this._marginRight,\n    top: this._marginTop,\n    bottom: this._marginBottom,\n  };\n};\n\n/**\n * Get instance element's cached position.\n *\n * @public\n * @returns {Object}\n *   - The returned object contains left and top properties which indicate the\n *     item element's cached position in the grid.\n */\nItem.prototype.getPosition = function () {\n  return {\n    left: this._left,\n    top: this._top,\n  };\n};\n\n/**\n * Is the item active?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isActive = function () {\n  return this._isActive;\n};\n\n/**\n * Is the item visible?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isVisible = function () {\n  return !!this._visibility && !this._visibility._isHidden;\n};\n\n/**\n * Is the item being animated to visible?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isShowing = function () {\n  return !!(this._visibility && this._visibility._isShowing);\n};\n\n/**\n * Is the item being animated to hidden?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isHiding = function () {\n  return !!(this._visibility && this._visibility._isHiding);\n};\n\n/**\n * Is the item positioning?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isPositioning = function () {\n  return !!(this._layout && this._layout._isActive);\n};\n\n/**\n * Is the item being dragged (or queued for dragging)?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isDragging = function () {\n  return !!(this._drag && this._drag._isActive);\n};\n\n/**\n * Is the item being released?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isReleasing = function () {\n  return !!(this._dragRelease && this._dragRelease._isActive);\n};\n\n/**\n * Is the item destroyed?\n *\n * @public\n * @returns {Boolean}\n */\nItem.prototype.isDestroyed = function () {\n  return this._isDestroyed;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Recalculate item's dimensions.\n *\n * @private\n * @param {Boolean} [force=false]\n */\nItem.prototype._refreshDimensions = function (force) {\n  if (this._isDestroyed) return;\n  if (force !== true && this._visibility._isHidden) return;\n\n  var element = this._element;\n  var dragPlaceholder = this._dragPlaceholder;\n  var rect = element.getBoundingClientRect();\n\n  // Calculate width and height.\n  this._width = rect.width;\n  this._height = rect.height;\n\n  // Calculate margins (ignore negative margins).\n  this._marginLeft = Math.max(0, getStyleAsFloat(element, 'margin-left'));\n  this._marginRight = Math.max(0, getStyleAsFloat(element, 'margin-right'));\n  this._marginTop = Math.max(0, getStyleAsFloat(element, 'margin-top'));\n  this._marginBottom = Math.max(0, getStyleAsFloat(element, 'margin-bottom'));\n\n  // Keep drag placeholder's dimensions synced with the item's.\n  if (dragPlaceholder) dragPlaceholder.updateDimensions();\n};\n\n/**\n * Fetch and store item's sort data.\n *\n * @private\n */\nItem.prototype._refreshSortData = function () {\n  if (this._isDestroyed) return;\n\n  var data = (this._sortData = {});\n  var getters = this.getGrid()._settings.sortData;\n  var prop;\n\n  for (prop in getters) {\n    data[prop] = getters[prop](this, this._element);\n  }\n};\n\n/**\n * Add item to layout.\n *\n * @private\n */\nItem.prototype._addToLayout = function (left, top) {\n  if (this._isActive === true) return;\n  this._isActive = true;\n  this._left = left || 0;\n  this._top = top || 0;\n};\n\n/**\n * Remove item from layout.\n *\n * @private\n */\nItem.prototype._removeFromLayout = function () {\n  if (this._isActive === false) return;\n  this._isActive = false;\n  this._left = 0;\n  this._top = 0;\n};\n\n/**\n * Check if the layout procedure can be skipped for the item.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\nItem.prototype._canSkipLayout = function (left, top) {\n  return (\n    this._left === left &&\n    this._top === top &&\n    !this._migrate._isActive &&\n    !this._layout._skipNextAnimation &&\n    !this._dragRelease.isJustReleased()\n  );\n};\n\n/**\n * Set the provided left and top arguments as the item element's translate\n * values in the DOM. This method keeps track of the currently applied\n * translate values and skips the update operation if the provided values are\n * identical to the currently applied values. Returns `false` if there was no\n * need for update and `true` if the translate value was updated.\n *\n * @private\n * @param {Number} left\n * @param {Number} top\n * @returns {Boolean}\n */\nItem.prototype._setTranslate = function (left, top) {\n  if (this._tX === left && this._tY === top) return false;\n  this._tX = left;\n  this._tY = top;\n  this._element.style[transformProp] = getTranslateString(left, top);\n  return true;\n};\n\n/**\n * Destroy item instance.\n *\n * @private\n * @param {Boolean} [removeElement=false]\n */\nItem.prototype._destroy = function (removeElement) {\n  if (this._isDestroyed) return;\n\n  var element = this._element;\n  var grid = this.getGrid();\n  var settings = grid._settings;\n\n  // Destroy handlers.\n  this._dragPlaceholder.destroy();\n  this._dragRelease.destroy();\n  this._migrate.destroy();\n  this._layout.destroy();\n  this._visibility.destroy();\n  if (this._drag) this._drag.destroy();\n\n  // Destroy emitter.\n  this._emitter.destroy();\n\n  // Remove item class.\n  removeClass(element, settings.itemClass);\n\n  // Remove element from DOM.\n  if (removeElement) element.parentNode.removeChild(element);\n\n  // Remove item/element pair from map.\n  if (ITEM_ELEMENT_MAP) ITEM_ELEMENT_MAP.delete(element);\n\n  // Reset state.\n  this._isActive = false;\n  this._isDestroyed = true;\n};\n\nfunction createPackerProcessor(isWorker) {\n  var FILL_GAPS = 1;\n  var HORIZONTAL = 2;\n  var ALIGN_RIGHT = 4;\n  var ALIGN_BOTTOM = 8;\n  var ROUNDING = 16;\n\n  var EPS = 0.001;\n  var MIN_SLOT_SIZE = 0.5;\n\n  // Rounds number first to three decimal precision and then floors the result\n  // to two decimal precision.\n  // Math.floor(Math.round(number * 1000) / 10) / 100\n  function roundNumber(number) {\n    return ((((number * 1000 + 0.5) << 0) / 10) << 0) / 100;\n  }\n\n  /**\n   * @class\n   */\n  function PackerProcessor() {\n    this.currentRects = [];\n    this.nextRects = [];\n    this.rectTarget = {};\n    this.rectStore = [];\n    this.slotSizes = [];\n    this.rectId = 0;\n    this.slotIndex = -1;\n    this.slotData = { left: 0, top: 0, width: 0, height: 0 };\n    this.sortRectsLeftTop = this.sortRectsLeftTop.bind(this);\n    this.sortRectsTopLeft = this.sortRectsTopLeft.bind(this);\n  }\n\n  /**\n   * Takes a layout object as an argument and computes positions (slots) for the\n   * layout items. Also computes the final width and height of the layout. The\n   * provided layout object's slots array is mutated as well as the width and\n   * height properties.\n   *\n   * @param {Object} layout\n   * @param {Number} layout.width\n   *   - The start (current) width of the layout in pixels.\n   * @param {Number} layout.height\n   *   - The start (current) height of the layout in pixels.\n   * @param {(Item[]|Number[])} layout.items\n   *   - List of Muuri.Item instances or a list of item dimensions\n   *     (e.g [ item1Width, item1Height, item2Width, item2Height, ... ]).\n   * @param {(Array|Float32Array)} layout.slots\n   *   - An Array/Float32Array instance which's length should equal to\n   *     the amount of items times two. The position (width and height) of each\n   *     item will be written into this array.\n   * @param {Number} settings\n   *   - The layout's settings as bitmasks.\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.computeLayout = function (layout, settings) {\n    var items = layout.items;\n    var slots = layout.slots;\n    var fillGaps = !!(settings & FILL_GAPS);\n    var horizontal = !!(settings & HORIZONTAL);\n    var alignRight = !!(settings & ALIGN_RIGHT);\n    var alignBottom = !!(settings & ALIGN_BOTTOM);\n    var rounding = !!(settings & ROUNDING);\n    var isPreProcessed = typeof items[0] === 'number';\n    var i, bump, item, slotWidth, slotHeight, slot;\n\n    // No need to go further if items do not exist.\n    if (!items.length) return layout;\n\n    // Compute slots for the items.\n    bump = isPreProcessed ? 2 : 1;\n    for (i = 0; i < items.length; i += bump) {\n      // If items are pre-processed it means that items array contains only\n      // the raw dimensions of the items. Otherwise we assume it is an array\n      // of normal Muuri items.\n      if (isPreProcessed) {\n        slotWidth = items[i];\n        slotHeight = items[i + 1];\n      } else {\n        item = items[i];\n        slotWidth = item._width + item._marginLeft + item._marginRight;\n        slotHeight = item._height + item._marginTop + item._marginBottom;\n      }\n\n      // If rounding is enabled let's round the item's width and height to\n      // make the layout algorithm a bit more stable. This has a performance\n      // cost so don't use this if not necessary.\n      if (rounding) {\n        slotWidth = roundNumber(slotWidth);\n        slotHeight = roundNumber(slotHeight);\n      }\n\n      // Get slot data.\n      slot = this.computeNextSlot(layout, slotWidth, slotHeight, fillGaps, horizontal);\n\n      // Update layout width/height.\n      if (horizontal) {\n        if (slot.left + slot.width > layout.width) {\n          layout.width = slot.left + slot.width;\n        }\n      } else {\n        if (slot.top + slot.height > layout.height) {\n          layout.height = slot.top + slot.height;\n        }\n      }\n\n      // Add item slot data to layout slots.\n      slots[++this.slotIndex] = slot.left;\n      slots[++this.slotIndex] = slot.top;\n\n      // Store the size too (for later usage) if needed.\n      if (alignRight || alignBottom) {\n        this.slotSizes.push(slot.width, slot.height);\n      }\n    }\n\n    // If the alignment is set to right we need to adjust the results.\n    if (alignRight) {\n      for (i = 0; i < slots.length; i += 2) {\n        slots[i] = layout.width - (slots[i] + this.slotSizes[i]);\n      }\n    }\n\n    // If the alignment is set to bottom we need to adjust the results.\n    if (alignBottom) {\n      for (i = 1; i < slots.length; i += 2) {\n        slots[i] = layout.height - (slots[i] + this.slotSizes[i]);\n      }\n    }\n\n    // Reset stuff.\n    this.slotSizes.length = 0;\n    this.currentRects.length = 0;\n    this.nextRects.length = 0;\n    this.rectStore.length = 0;\n    this.rectId = 0;\n    this.slotIndex = -1;\n\n    return layout;\n  };\n\n  /**\n   * Calculate next slot in the layout. Returns a slot object with position and\n   * dimensions data. The returned object is reused between calls.\n   *\n   * @param {Object} layout\n   * @param {Number} slotWidth\n   * @param {Number} slotHeight\n   * @param {Boolean} fillGaps\n   * @param {Boolean} horizontal\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.computeNextSlot = function (\n    layout,\n    slotWidth,\n    slotHeight,\n    fillGaps,\n    horizontal\n  ) {\n    var slot = this.slotData;\n    var currentRects = this.currentRects;\n    var nextRects = this.nextRects;\n    var ignoreCurrentRects = false;\n    var rect;\n    var rectId;\n    var shards;\n    var i;\n    var j;\n\n    // Reset new slots.\n    nextRects.length = 0;\n\n    // Set item slot initial data.\n    slot.left = null;\n    slot.top = null;\n    slot.width = slotWidth;\n    slot.height = slotHeight;\n\n    // Try to find position for the slot from the existing free spaces in the\n    // layout.\n    for (i = 0; i < currentRects.length; i++) {\n      rectId = currentRects[i];\n      if (!rectId) continue;\n      rect = this.getRect(rectId);\n      if (slot.width <= rect.width + EPS && slot.height <= rect.height + EPS) {\n        slot.left = rect.left;\n        slot.top = rect.top;\n        break;\n      }\n    }\n\n    // If no position was found for the slot let's position the slot to\n    // the bottom left (in vertical mode) or top right (in horizontal mode) of\n    // the layout.\n    if (slot.left === null) {\n      if (horizontal) {\n        slot.left = layout.width;\n        slot.top = 0;\n      } else {\n        slot.left = 0;\n        slot.top = layout.height;\n      }\n\n      // If gaps don't need filling let's throw away all the current free spaces\n      // (currentRects).\n      if (!fillGaps) {\n        ignoreCurrentRects = true;\n      }\n    }\n\n    // In vertical mode, if the slot's bottom overlaps the layout's bottom.\n    if (!horizontal && slot.top + slot.height > layout.height + EPS) {\n      // If slot is not aligned to the left edge, create a new free space to the\n      // left of the slot.\n      if (slot.left > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(0, layout.height, slot.left, Infinity));\n      }\n\n      // If slot is not aligned to the right edge, create a new free space to\n      // the right of the slot.\n      if (slot.left + slot.width < layout.width - MIN_SLOT_SIZE) {\n        nextRects.push(\n          this.addRect(\n            slot.left + slot.width,\n            layout.height,\n            layout.width - slot.left - slot.width,\n            Infinity\n          )\n        );\n      }\n\n      // Update layout height.\n      layout.height = slot.top + slot.height;\n    }\n\n    // In horizontal mode, if the slot's right overlaps the layout's right edge.\n    if (horizontal && slot.left + slot.width > layout.width + EPS) {\n      // If slot is not aligned to the top, create a new free space above the\n      // slot.\n      if (slot.top > MIN_SLOT_SIZE) {\n        nextRects.push(this.addRect(layout.width, 0, Infinity, slot.top));\n      }\n\n      // If slot is not aligned to the bottom, create a new free space below\n      // the slot.\n      if (slot.top + slot.height < layout.height - MIN_SLOT_SIZE) {\n        nextRects.push(\n          this.addRect(\n            layout.width,\n            slot.top + slot.height,\n            Infinity,\n            layout.height - slot.top - slot.height\n          )\n        );\n      }\n\n      // Update layout width.\n      layout.width = slot.left + slot.width;\n    }\n\n    // Clean up the current free spaces making sure none of them overlap with\n    // the slot. Split all overlapping free spaces into smaller shards that do\n    // not overlap with the slot.\n    if (!ignoreCurrentRects) {\n      if (fillGaps) i = 0;\n      for (; i < currentRects.length; i++) {\n        rectId = currentRects[i];\n        if (!rectId) continue;\n        rect = this.getRect(rectId);\n        shards = this.splitRect(rect, slot);\n        for (j = 0; j < shards.length; j++) {\n          rectId = shards[j];\n          rect = this.getRect(rectId);\n          // Make sure that the free space is within the boundaries of the\n          // layout. This routine is critical to the algorithm as it makes sure\n          // that there are no leftover spaces with infinite height/width.\n          // It's also essential that we don't compare values absolutely to each\n          // other but leave a little headroom (EPSILON) to get rid of false\n          // positives.\n          if (\n            horizontal ? rect.left + EPS < layout.width - EPS : rect.top + EPS < layout.height - EPS\n          ) {\n            nextRects.push(rectId);\n          }\n        }\n      }\n    }\n\n    // Sanitize and sort all the new free spaces that will be used in the next\n    // iteration. This procedure is critical to make the bin-packing algorithm\n    // work. The free spaces have to be in correct order in the beginning of the\n    // next iteration.\n    if (nextRects.length > 1) {\n      this.purgeRects(nextRects).sort(horizontal ? this.sortRectsLeftTop : this.sortRectsTopLeft);\n    }\n\n    // Finally we need to make sure that `this.currentRects` points to\n    // `nextRects` array as that is used in the next iteration's beginning when\n    // we try to find a space for the next slot.\n    this.currentRects = nextRects;\n    this.nextRects = currentRects;\n\n    return slot;\n  };\n\n  /**\n   * Add a new rectangle to the rectangle store. Returns the id of the new\n   * rectangle.\n   *\n   * @param {Number} left\n   * @param {Number} top\n   * @param {Number} width\n   * @param {Number} height\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.addRect = function (left, top, width, height) {\n    var rectId = ++this.rectId;\n    this.rectStore[rectId] = left || 0;\n    this.rectStore[++this.rectId] = top || 0;\n    this.rectStore[++this.rectId] = width || 0;\n    this.rectStore[++this.rectId] = height || 0;\n    return rectId;\n  };\n\n  /**\n   * Get rectangle data from the rectangle store by id. Optionally you can\n   * provide a target object where the rectangle data will be written in. By\n   * default an internal object is reused as a target object.\n   *\n   * @param {Number} id\n   * @param {Object} [target]\n   * @returns {Object}\n   */\n  PackerProcessor.prototype.getRect = function (id, target) {\n    if (!target) target = this.rectTarget;\n    target.left = this.rectStore[id] || 0;\n    target.top = this.rectStore[++id] || 0;\n    target.width = this.rectStore[++id] || 0;\n    target.height = this.rectStore[++id] || 0;\n    return target;\n  };\n\n  /**\n   * Punch a hole into a rectangle and return the shards (1-4).\n   *\n   * @param {Object} rect\n   * @param {Object} hole\n   * @returns {Number[]}\n   */\n  PackerProcessor.prototype.splitRect = (function () {\n    var shards = [];\n    var width = 0;\n    var height = 0;\n    return function (rect, hole) {\n      // Reset old shards.\n      shards.length = 0;\n\n      // If the slot does not overlap with the hole add slot to the return data\n      // as is. Note that in this case we are eager to keep the slot as is if\n      // possible so we use the EPSILON in favour of that logic.\n      if (\n        rect.left + rect.width <= hole.left + EPS ||\n        hole.left + hole.width <= rect.left + EPS ||\n        rect.top + rect.height <= hole.top + EPS ||\n        hole.top + hole.height <= rect.top + EPS\n      ) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, rect.height));\n        return shards;\n      }\n\n      // Left split.\n      width = hole.left - rect.left;\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, width, rect.height));\n      }\n\n      // Right split.\n      width = rect.left + rect.width - (hole.left + hole.width);\n      if (width >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(hole.left + hole.width, rect.top, width, rect.height));\n      }\n\n      // Top split.\n      height = hole.top - rect.top;\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, rect.top, rect.width, height));\n      }\n\n      // Bottom split.\n      height = rect.top + rect.height - (hole.top + hole.height);\n      if (height >= MIN_SLOT_SIZE) {\n        shards.push(this.addRect(rect.left, hole.top + hole.height, rect.width, height));\n      }\n\n      return shards;\n    };\n  })();\n\n  /**\n   * Check if a rectangle is fully within another rectangle.\n   *\n   * @param {Object} a\n   * @param {Object} b\n   * @returns {Boolean}\n   */\n  PackerProcessor.prototype.isRectAWithinRectB = function (a, b) {\n    return (\n      a.left + EPS >= b.left &&\n      a.top + EPS >= b.top &&\n      a.left + a.width - EPS <= b.left + b.width &&\n      a.top + a.height - EPS <= b.top + b.height\n    );\n  };\n\n  /**\n   * Loops through an array of rectangle ids and resets all that are fully\n   * within another rectangle in the array. Resetting in this case means that\n   * the rectangle id value is replaced with zero.\n   *\n   * @param {Number[]} rectIds\n   * @returns {Number[]}\n   */\n  PackerProcessor.prototype.purgeRects = (function () {\n    var rectA = {};\n    var rectB = {};\n    return function (rectIds) {\n      var i = rectIds.length;\n      var j;\n\n      while (i--) {\n        j = rectIds.length;\n        if (!rectIds[i]) continue;\n        this.getRect(rectIds[i], rectA);\n        while (j--) {\n          if (!rectIds[j] || i === j) continue;\n          this.getRect(rectIds[j], rectB);\n          if (this.isRectAWithinRectB(rectA, rectB)) {\n            rectIds[i] = 0;\n            break;\n          }\n        }\n      }\n\n      return rectIds;\n    };\n  })();\n\n  /**\n   * Sort rectangles with top-left gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.sortRectsTopLeft = (function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n\n      return rectA.top < rectB.top && rectA.top + EPS < rectB.top\n        ? -1\n        : rectA.top > rectB.top && rectA.top - EPS > rectB.top\n        ? 1\n        : rectA.left < rectB.left && rectA.left + EPS < rectB.left\n        ? -1\n        : rectA.left > rectB.left && rectA.left - EPS > rectB.left\n        ? 1\n        : 0;\n    };\n  })();\n\n  /**\n   * Sort rectangles with left-top gravity.\n   *\n   * @param {Number} aId\n   * @param {Number} bId\n   * @returns {Number}\n   */\n  PackerProcessor.prototype.sortRectsLeftTop = (function () {\n    var rectA = {};\n    var rectB = {};\n    return function (aId, bId) {\n      this.getRect(aId, rectA);\n      this.getRect(bId, rectB);\n      return rectA.left < rectB.left && rectA.left + EPS < rectB.left\n        ? -1\n        : rectA.left > rectB.left && rectA.left - EPS < rectB.left\n        ? 1\n        : rectA.top < rectB.top && rectA.top + EPS < rectB.top\n        ? -1\n        : rectA.top > rectB.top && rectA.top - EPS > rectB.top\n        ? 1\n        : 0;\n    };\n  })();\n\n  if (isWorker) {\n    var PACKET_INDEX_WIDTH = 1;\n    var PACKET_INDEX_HEIGHT = 2;\n    var PACKET_INDEX_OPTIONS = 3;\n    var PACKET_HEADER_SLOTS = 4;\n    var processor = new PackerProcessor();\n\n    self.onmessage = function (msg) {\n      var data = new Float32Array(msg.data);\n      var items = data.subarray(PACKET_HEADER_SLOTS, data.length);\n      var slots = new Float32Array(items.length);\n      var settings = data[PACKET_INDEX_OPTIONS];\n      var layout = {\n        items: items,\n        slots: slots,\n        width: data[PACKET_INDEX_WIDTH],\n        height: data[PACKET_INDEX_HEIGHT],\n      };\n\n      // Compute the layout (width / height / slots).\n      processor.computeLayout(layout, settings);\n\n      // Copy layout data to the return data.\n      data[PACKET_INDEX_WIDTH] = layout.width;\n      data[PACKET_INDEX_HEIGHT] = layout.height;\n      data.set(layout.slots, PACKET_HEADER_SLOTS);\n\n      // Send layout back to the main thread.\n      postMessage(data.buffer, [data.buffer]);\n    };\n  }\n\n  return PackerProcessor;\n}\n\nvar PackerProcessor = createPackerProcessor();\n\n//\n// WORKER UTILS\n//\n\nvar blobUrl = null;\nvar activeWorkers = [];\n\nfunction createWorkerProcessors(amount, onmessage) {\n  var workers = [];\n\n  if (amount > 0) {\n    if (!blobUrl) {\n      blobUrl = URL.createObjectURL(\n        new Blob(['(' + createPackerProcessor.toString() + ')(true)'], {\n          type: 'application/javascript',\n        })\n      );\n    }\n\n    for (var i = 0, worker; i < amount; i++) {\n      worker = new Worker(blobUrl);\n      if (onmessage) worker.onmessage = onmessage;\n      workers.push(worker);\n      activeWorkers.push(worker);\n    }\n  }\n\n  return workers;\n}\n\nfunction destroyWorkerProcessors(workers) {\n  var worker;\n  var index;\n\n  for (var i = 0; i < workers.length; i++) {\n    worker = workers[i];\n    worker.onmessage = null;\n    worker.onerror = null;\n    worker.onmessageerror = null;\n    worker.terminate();\n\n    index = activeWorkers.indexOf(worker);\n    if (index > -1) activeWorkers.splice(index, 1);\n  }\n\n  if (blobUrl && !activeWorkers.length) {\n    URL.revokeObjectURL(blobUrl);\n    blobUrl = null;\n  }\n}\n\nfunction isWorkerProcessorsSupported() {\n  return !!(window.Worker && window.URL && window.Blob);\n}\n\nvar FILL_GAPS = 1;\nvar HORIZONTAL = 2;\nvar ALIGN_RIGHT = 4;\nvar ALIGN_BOTTOM = 8;\nvar ROUNDING = 16;\nvar PACKET_INDEX_ID = 0;\nvar PACKET_INDEX_WIDTH = 1;\nvar PACKET_INDEX_HEIGHT = 2;\nvar PACKET_INDEX_OPTIONS = 3;\nvar PACKET_HEADER_SLOTS = 4;\n\n/**\n * @class\n * @param {Number} [numWorkers=0]\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps=false]\n * @param {Boolean} [options.horizontal=false]\n * @param {Boolean} [options.alignRight=false]\n * @param {Boolean} [options.alignBottom=false]\n * @param {Boolean} [options.rounding=false]\n */\nfunction Packer(numWorkers, options) {\n  this._options = 0;\n  this._processor = null;\n  this._layoutQueue = [];\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n  this._workers = [];\n  this._onWorkerMessage = this._onWorkerMessage.bind(this);\n\n  // Set initial options.\n  this.setOptions(options);\n\n  // Init the worker(s) or the processor if workers can't be used.\n  numWorkers = typeof numWorkers === 'number' ? Math.max(0, numWorkers) : 0;\n  if (numWorkers && isWorkerProcessorsSupported()) {\n    try {\n      this._workers = createWorkerProcessors(numWorkers, this._onWorkerMessage);\n    } catch (e) {\n      this._processor = new PackerProcessor();\n    }\n  } else {\n    this._processor = new PackerProcessor();\n  }\n}\n\nPacker.prototype._sendToWorker = function () {\n  if (!this._layoutQueue.length || !this._workers.length) return;\n\n  var layoutId = this._layoutQueue.shift();\n  var worker = this._workers.pop();\n  var data = this._layoutWorkerData[layoutId];\n\n  delete this._layoutWorkerData[layoutId];\n  this._layoutWorkers[layoutId] = worker;\n  worker.postMessage(data.buffer, [data.buffer]);\n};\n\nPacker.prototype._onWorkerMessage = function (msg) {\n  var data = new Float32Array(msg.data);\n  var layoutId = data[PACKET_INDEX_ID];\n  var layout = this._layouts[layoutId];\n  var callback = this._layoutCallbacks[layoutId];\n  var worker = this._layoutWorkers[layoutId];\n\n  if (layout) delete this._layouts[layoutId];\n  if (callback) delete this._layoutCallbacks[layoutId];\n  if (worker) delete this._layoutWorkers[layoutId];\n\n  if (layout && callback) {\n    layout.width = data[PACKET_INDEX_WIDTH];\n    layout.height = data[PACKET_INDEX_HEIGHT];\n    layout.slots = data.subarray(PACKET_HEADER_SLOTS, data.length);\n    this._finalizeLayout(layout);\n    callback(layout);\n  }\n\n  if (worker) {\n    this._workers.push(worker);\n    this._sendToWorker();\n  }\n};\n\nPacker.prototype._finalizeLayout = function (layout) {\n  var grid = layout._grid;\n  var isHorizontal = layout._settings & HORIZONTAL;\n  var isBorderBox = grid._boxSizing === 'border-box';\n\n  delete layout._grid;\n  delete layout._settings;\n\n  layout.styles = {};\n\n  if (isHorizontal) {\n    layout.styles.width =\n      (isBorderBox ? layout.width + grid._borderLeft + grid._borderRight : layout.width) + 'px';\n  } else {\n    layout.styles.height =\n      (isBorderBox ? layout.height + grid._borderTop + grid._borderBottom : layout.height) + 'px';\n  }\n\n  return layout;\n};\n\n/**\n * @public\n * @param {Object} [options]\n * @param {Boolean} [options.fillGaps]\n * @param {Boolean} [options.horizontal]\n * @param {Boolean} [options.alignRight]\n * @param {Boolean} [options.alignBottom]\n * @param {Boolean} [options.rounding]\n */\nPacker.prototype.setOptions = function (options) {\n  if (!options) return;\n\n  var fillGaps;\n  if (typeof options.fillGaps === 'boolean') {\n    fillGaps = options.fillGaps ? FILL_GAPS : 0;\n  } else {\n    fillGaps = this._options & FILL_GAPS;\n  }\n\n  var horizontal;\n  if (typeof options.horizontal === 'boolean') {\n    horizontal = options.horizontal ? HORIZONTAL : 0;\n  } else {\n    horizontal = this._options & HORIZONTAL;\n  }\n\n  var alignRight;\n  if (typeof options.alignRight === 'boolean') {\n    alignRight = options.alignRight ? ALIGN_RIGHT : 0;\n  } else {\n    alignRight = this._options & ALIGN_RIGHT;\n  }\n\n  var alignBottom;\n  if (typeof options.alignBottom === 'boolean') {\n    alignBottom = options.alignBottom ? ALIGN_BOTTOM : 0;\n  } else {\n    alignBottom = this._options & ALIGN_BOTTOM;\n  }\n\n  var rounding;\n  if (typeof options.rounding === 'boolean') {\n    rounding = options.rounding ? ROUNDING : 0;\n  } else {\n    rounding = this._options & ROUNDING;\n  }\n\n  this._options = fillGaps | horizontal | alignRight | alignBottom | rounding;\n};\n\n/**\n * @public\n * @param {Grid} grid\n * @param {Number} layoutId\n * @param {Item[]} items\n * @param {Number} width\n * @param {Number} height\n * @param {Function} callback\n * @returns {?Function}\n */\nPacker.prototype.createLayout = function (grid, layoutId, items, width, height, callback) {\n  if (this._layouts[layoutId]) {\n    throw new Error('A layout with the provided id is currently being processed.');\n  }\n\n  var horizontal = this._options & HORIZONTAL;\n  var layout = {\n    id: layoutId,\n    items: items,\n    slots: null,\n    width: horizontal ? 0 : width,\n    height: !horizontal ? 0 : height,\n    // Temporary data, which will be removed before sending the layout data\n    // outside of Packer's context.\n    _grid: grid,\n    _settings: this._options,\n  };\n\n  // If there are no items let's call the callback immediately.\n  if (!items.length) {\n    layout.slots = [];\n    this._finalizeLayout(layout);\n    callback(layout);\n    return;\n  }\n\n  // Create layout synchronously if needed.\n  if (this._processor) {\n    layout.slots = window.Float32Array\n      ? new Float32Array(items.length * 2)\n      : new Array(items.length * 2);\n    this._processor.computeLayout(layout, layout._settings);\n    this._finalizeLayout(layout);\n    callback(layout);\n    return;\n  }\n\n  // Worker data.\n  var data = new Float32Array(PACKET_HEADER_SLOTS + items.length * 2);\n\n  // Worker data header.\n  data[PACKET_INDEX_ID] = layoutId;\n  data[PACKET_INDEX_WIDTH] = layout.width;\n  data[PACKET_INDEX_HEIGHT] = layout.height;\n  data[PACKET_INDEX_OPTIONS] = layout._settings;\n\n  // Worker data items.\n  var i, j, item;\n  for (i = 0, j = PACKET_HEADER_SLOTS - 1, item; i < items.length; i++) {\n    item = items[i];\n    data[++j] = item._width + item._marginLeft + item._marginRight;\n    data[++j] = item._height + item._marginTop + item._marginBottom;\n  }\n\n  this._layoutQueue.push(layoutId);\n  this._layouts[layoutId] = layout;\n  this._layoutCallbacks[layoutId] = callback;\n  this._layoutWorkerData[layoutId] = data;\n\n  this._sendToWorker();\n\n  return this.cancelLayout.bind(this, layoutId);\n};\n\n/**\n * @public\n * @param {Number} layoutId\n */\nPacker.prototype.cancelLayout = function (layoutId) {\n  var layout = this._layouts[layoutId];\n  if (!layout) return;\n\n  delete this._layouts[layoutId];\n  delete this._layoutCallbacks[layoutId];\n\n  if (this._layoutWorkerData[layoutId]) {\n    delete this._layoutWorkerData[layoutId];\n    var queueIndex = this._layoutQueue.indexOf(layoutId);\n    if (queueIndex > -1) this._layoutQueue.splice(queueIndex, 1);\n  }\n};\n\n/**\n * @public\n */\nPacker.prototype.destroy = function () {\n  // Move all currently used workers back in the workers array.\n  for (var key in this._layoutWorkers) {\n    this._workers.push(this._layoutWorkers[key]);\n  }\n\n  // Destroy all instance's workers.\n  destroyWorkerProcessors(this._workers);\n\n  // Reset data.\n  this._workers.length = 0;\n  this._layoutQueue.length = 0;\n  this._layouts = {};\n  this._layoutCallbacks = {};\n  this._layoutWorkers = {};\n  this._layoutWorkerData = {};\n};\n\nvar debounceId = 0;\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. The returned function accepts one argument which, when\n * being `true`, cancels the debounce function immediately. When the debounce\n * function is canceled it cannot be invoked again.\n *\n * @param {Function} fn\n * @param {Number} durationMs\n * @returns {Function}\n */\nfunction debounce(fn, durationMs) {\n  var id = ++debounceId;\n  var timer = 0;\n  var lastTime = 0;\n  var isCanceled = false;\n  var tick = function (time) {\n    if (isCanceled) return;\n\n    if (lastTime) timer -= time - lastTime;\n    lastTime = time;\n\n    if (timer > 0) {\n      addDebounceTick(id, tick);\n    } else {\n      timer = lastTime = 0;\n      fn();\n    }\n  };\n\n  return function (cancel) {\n    if (isCanceled) return;\n\n    if (durationMs <= 0) {\n      if (cancel !== true) fn();\n      return;\n    }\n\n    if (cancel === true) {\n      isCanceled = true;\n      timer = lastTime = 0;\n      tick = undefined;\n      cancelDebounceTick(id);\n      return;\n    }\n\n    if (timer <= 0) {\n      timer = durationMs;\n      tick(0);\n    } else {\n      timer = durationMs;\n    }\n  };\n}\n\nvar htmlCollectionType = '[object HTMLCollection]';\nvar nodeListType = '[object NodeList]';\n\n/**\n * Check if a value is a node list or a html collection.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isNodeList(val) {\n  var type = Object.prototype.toString.call(val);\n  return type === htmlCollectionType || type === nodeListType;\n}\n\nvar objectType = 'object';\nvar objectToStringType = '[object Object]';\nvar toString = Object.prototype.toString;\n\n/**\n * Check if a value is a plain object.\n *\n * @param {*} val\n * @returns {Boolean}\n */\nfunction isPlainObject(val) {\n  return typeof val === objectType && toString.call(val) === objectToStringType;\n}\n\nfunction noop() {}\n\n/**\n * Converts a value to an array or clones an array.\n *\n * @param {*} val\n * @returns {Array}\n */\nfunction toArray(val) {\n  return isNodeList(val) ? Array.prototype.slice.call(val) : Array.prototype.concat(val);\n}\n\nvar NUMBER_TYPE = 'number';\nvar STRING_TYPE = 'string';\nvar INSTANT_LAYOUT = 'instant';\nvar layoutId = 0;\n\n/**\n * Creates a new Grid instance.\n *\n * @class\n * @param {(HTMLElement|String)} element\n * @param {Object} [options]\n * @param {(String|HTMLElement[]|NodeList|HTMLCollection)} [options.items=\"*\"]\n * @param {Number} [options.showDuration=300]\n * @param {String} [options.showEasing=\"ease\"]\n * @param {Object} [options.visibleStyles={opacity: \"1\", transform: \"scale(1)\"}]\n * @param {Number} [options.hideDuration=300]\n * @param {String} [options.hideEasing=\"ease\"]\n * @param {Object} [options.hiddenStyles={opacity: \"0\", transform: \"scale(0.5)\"}]\n * @param {(Function|Object)} [options.layout]\n * @param {Boolean} [options.layout.fillGaps=false]\n * @param {Boolean} [options.layout.horizontal=false]\n * @param {Boolean} [options.layout.alignRight=false]\n * @param {Boolean} [options.layout.alignBottom=false]\n * @param {Boolean} [options.layout.rounding=false]\n * @param {(Boolean|Number)} [options.layoutOnResize=150]\n * @param {Boolean} [options.layoutOnInit=true]\n * @param {Number} [options.layoutDuration=300]\n * @param {String} [options.layoutEasing=\"ease\"]\n * @param {?Object} [options.sortData=null]\n * @param {Boolean} [options.dragEnabled=false]\n * @param {?String} [options.dragHandle=null]\n * @param {?HtmlElement} [options.dragContainer=null]\n * @param {?Function} [options.dragStartPredicate]\n * @param {Number} [options.dragStartPredicate.distance=0]\n * @param {Number} [options.dragStartPredicate.delay=0]\n * @param {String} [options.dragAxis=\"xy\"]\n * @param {(Boolean|Function)} [options.dragSort=true]\n * @param {Object} [options.dragSortHeuristics]\n * @param {Number} [options.dragSortHeuristics.sortInterval=100]\n * @param {Number} [options.dragSortHeuristics.minDragDistance=10]\n * @param {Number} [options.dragSortHeuristics.minBounceBackAngle=1]\n * @param {(Function|Object)} [options.dragSortPredicate]\n * @param {Number} [options.dragSortPredicate.threshold=50]\n * @param {String} [options.dragSortPredicate.action=\"move\"]\n * @param {String} [options.dragSortPredicate.migrateAction=\"move\"]\n * @param {Object} [options.dragRelease]\n * @param {Number} [options.dragRelease.duration=300]\n * @param {String} [options.dragRelease.easing=\"ease\"]\n * @param {Boolean} [options.dragRelease.useDragContainer=true]\n * @param {Object} [options.dragCssProps]\n * @param {Object} [options.dragPlaceholder]\n * @param {Boolean} [options.dragPlaceholder.enabled=false]\n * @param {?Function} [options.dragPlaceholder.createElement=null]\n * @param {?Function} [options.dragPlaceholder.onCreate=null]\n * @param {?Function} [options.dragPlaceholder.onRemove=null]\n * @param {Object} [options.dragAutoScroll]\n * @param {(Function|Array)} [options.dragAutoScroll.targets=[]]\n * @param {?Function} [options.dragAutoScroll.handle=null]\n * @param {Number} [options.dragAutoScroll.threshold=50]\n * @param {Number} [options.dragAutoScroll.safeZone=0.2]\n * @param {(Function|Number)} [options.dragAutoScroll.speed]\n * @param {Boolean} [options.dragAutoScroll.sortDuringScroll=true]\n * @param {Boolean} [options.dragAutoScroll.smoothStop=false]\n * @param {?Function} [options.dragAutoScroll.onStart=null]\n * @param {?Function} [options.dragAutoScroll.onStop=null]\n * @param {String} [options.containerClass=\"muuri\"]\n * @param {String} [options.itemClass=\"muuri-item\"]\n * @param {String} [options.itemVisibleClass=\"muuri-item-visible\"]\n * @param {String} [options.itemHiddenClass=\"muuri-item-hidden\"]\n * @param {String} [options.itemPositioningClass=\"muuri-item-positioning\"]\n * @param {String} [options.itemDraggingClass=\"muuri-item-dragging\"]\n * @param {String} [options.itemReleasingClass=\"muuri-item-releasing\"]\n * @param {String} [options.itemPlaceholderClass=\"muuri-item-placeholder\"]\n */\nfunction Grid(element, options) {\n  // Allow passing element as selector string\n  if (typeof element === STRING_TYPE) {\n    element = document.querySelector(element);\n  }\n\n  // Throw an error if the container element is not body element or does not\n  // exist within the body element.\n  var isElementInDom = element.getRootNode\n    ? element.getRootNode({ composed: true }) === document\n    : document.body.contains(element);\n  if (!isElementInDom || element === document.documentElement) {\n    throw new Error('Container element must be an existing DOM element.');\n  }\n\n  // Create instance settings by merging the options with default options.\n  var settings = mergeSettings(Grid.defaultOptions, options);\n  settings.visibleStyles = normalizeStyles(settings.visibleStyles);\n  settings.hiddenStyles = normalizeStyles(settings.hiddenStyles);\n  if (!isFunction(settings.dragSort)) {\n    settings.dragSort = !!settings.dragSort;\n  }\n\n  this._id = createUid();\n  this._element = element;\n  this._settings = settings;\n  this._isDestroyed = false;\n  this._items = [];\n  this._layout = {\n    id: 0,\n    items: [],\n    slots: [],\n  };\n  this._isLayoutFinished = true;\n  this._nextLayoutData = null;\n  this._emitter = new Emitter();\n  this._onLayoutDataReceived = this._onLayoutDataReceived.bind(this);\n\n  // Store grid instance to the grid instances collection.\n  GRID_INSTANCES[this._id] = this;\n\n  // Add container element's class name.\n  addClass(element, settings.containerClass);\n\n  // If layoutOnResize option is a valid number sanitize it and bind the resize\n  // handler.\n  bindLayoutOnResize(this, settings.layoutOnResize);\n\n  // Add initial items.\n  this.add(getInitialGridElements(element, settings.items), { layout: false });\n\n  // Layout on init if necessary.\n  if (settings.layoutOnInit) {\n    this.layout(true);\n  }\n}\n\n/**\n * Public properties\n * *****************\n */\n\n/**\n * @public\n * @static\n * @see Item\n */\nGrid.Item = Item;\n\n/**\n * @public\n * @static\n * @see ItemLayout\n */\nGrid.ItemLayout = ItemLayout;\n\n/**\n * @public\n * @static\n * @see ItemVisibility\n */\nGrid.ItemVisibility = ItemVisibility;\n\n/**\n * @public\n * @static\n * @see ItemMigrate\n */\nGrid.ItemMigrate = ItemMigrate;\n\n/**\n * @public\n * @static\n * @see ItemDrag\n */\nGrid.ItemDrag = ItemDrag;\n\n/**\n * @public\n * @static\n * @see ItemDragRelease\n */\nGrid.ItemDragRelease = ItemDragRelease;\n\n/**\n * @public\n * @static\n * @see ItemDragPlaceholder\n */\nGrid.ItemDragPlaceholder = ItemDragPlaceholder;\n\n/**\n * @public\n * @static\n * @see Emitter\n */\nGrid.Emitter = Emitter;\n\n/**\n * @public\n * @static\n * @see Animator\n */\nGrid.Animator = Animator;\n\n/**\n * @public\n * @static\n * @see Dragger\n */\nGrid.Dragger = Dragger;\n\n/**\n * @public\n * @static\n * @see Packer\n */\nGrid.Packer = Packer;\n\n/**\n * @public\n * @static\n * @see AutoScroller\n */\nGrid.AutoScroller = AutoScroller;\n\n/**\n * The default Packer instance used by default for all layouts.\n *\n * @public\n * @static\n * @type {Packer}\n */\nGrid.defaultPacker = new Packer(2);\n\n/**\n * Default options for Grid instance.\n *\n * @public\n * @static\n * @type {Object}\n */\nGrid.defaultOptions = {\n  // Initial item elements\n  items: '*',\n\n  // Default show animation\n  showDuration: 300,\n  showEasing: 'ease',\n\n  // Default hide animation\n  hideDuration: 300,\n  hideEasing: 'ease',\n\n  // Item's visible/hidden state styles\n  visibleStyles: {\n    opacity: '1',\n    transform: 'scale(1)',\n  },\n  hiddenStyles: {\n    opacity: '0',\n    transform: 'scale(0.5)',\n  },\n\n  // Layout\n  layout: {\n    fillGaps: false,\n    horizontal: false,\n    alignRight: false,\n    alignBottom: false,\n    rounding: false,\n  },\n  layoutOnResize: 150,\n  layoutOnInit: true,\n  layoutDuration: 300,\n  layoutEasing: 'ease',\n\n  // Sorting\n  sortData: null,\n\n  // Drag & Drop\n  dragEnabled: false,\n  dragContainer: null,\n  dragHandle: null,\n  dragStartPredicate: {\n    distance: 0,\n    delay: 0,\n  },\n  dragAxis: 'xy',\n  dragSort: true,\n  dragSortHeuristics: {\n    sortInterval: 100,\n    minDragDistance: 10,\n    minBounceBackAngle: 1,\n  },\n  dragSortPredicate: {\n    threshold: 50,\n    action: ACTION_MOVE,\n    migrateAction: ACTION_MOVE,\n  },\n  dragRelease: {\n    duration: 300,\n    easing: 'ease',\n    useDragContainer: true,\n  },\n  dragCssProps: {\n    touchAction: 'none',\n    userSelect: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0, 0, 0, 0)',\n    touchCallout: 'none',\n    contentZooming: 'none',\n  },\n  dragPlaceholder: {\n    enabled: false,\n    createElement: null,\n    onCreate: null,\n    onRemove: null,\n  },\n  dragAutoScroll: {\n    targets: [],\n    handle: null,\n    threshold: 50,\n    safeZone: 0.2,\n    speed: AutoScroller.smoothSpeed(1000, 2000, 2500),\n    sortDuringScroll: true,\n    smoothStop: false,\n    onStart: null,\n    onStop: null,\n  },\n\n  // Classnames\n  containerClass: 'muuri',\n  itemClass: 'muuri-item',\n  itemVisibleClass: 'muuri-item-shown',\n  itemHiddenClass: 'muuri-item-hidden',\n  itemPositioningClass: 'muuri-item-positioning',\n  itemDraggingClass: 'muuri-item-dragging',\n  itemReleasingClass: 'muuri-item-releasing',\n  itemPlaceholderClass: 'muuri-item-placeholder',\n};\n\n/**\n * Public prototype methods\n * ************************\n */\n\n/**\n * Bind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\nGrid.prototype.on = function (event, listener) {\n  this._emitter.on(event, listener);\n  return this;\n};\n\n/**\n * Unbind an event listener.\n *\n * @public\n * @param {String} event\n * @param {Function} listener\n * @returns {Grid}\n */\nGrid.prototype.off = function (event, listener) {\n  this._emitter.off(event, listener);\n  return this;\n};\n\n/**\n * Get the container element.\n *\n * @public\n * @returns {HTMLElement}\n */\nGrid.prototype.getElement = function () {\n  return this._element;\n};\n\n/**\n * Get instance's item by element or by index. Target can also be an Item\n * instance in which case the function returns the item if it exists within\n * related Grid instance. If nothing is found with the provided target, null\n * is returned.\n *\n * @private\n * @param {(HtmlElement|Number|Item)} [target]\n * @returns {?Item}\n */\nGrid.prototype.getItem = function (target) {\n  // If no target is specified or the instance is destroyed, return null.\n  if (this._isDestroyed || (!target && target !== 0)) {\n    return null;\n  }\n\n  // If target is number return the item in that index. If the number is lower\n  // than zero look for the item starting from the end of the items array. For\n  // example -1 for the last item, -2 for the second last item, etc.\n  if (typeof target === NUMBER_TYPE) {\n    return this._items[target > -1 ? target : this._items.length + target] || null;\n  }\n\n  // If the target is an instance of Item return it if it is attached to this\n  // Grid instance, otherwise return null.\n  if (target instanceof Item) {\n    return target._gridId === this._id ? target : null;\n  }\n\n  // In other cases let's assume that the target is an element, so let's try\n  // to find an item that matches the element and return it. If item is not\n  // found return null.\n  if (ITEM_ELEMENT_MAP) {\n    var item = ITEM_ELEMENT_MAP.get(target);\n    return item && item._gridId === this._id ? item : null;\n  } else {\n    for (var i = 0; i < this._items.length; i++) {\n      if (this._items[i]._element === target) {\n        return this._items[i];\n      }\n    }\n  }\n\n  return null;\n};\n\n/**\n * Get all items. Optionally you can provide specific targets (elements,\n * indices and item instances). All items that are not found are omitted from\n * the returned array.\n *\n * @public\n * @param {(HtmlElement|Number|Item|Array)} [targets]\n * @returns {Item[]}\n */\nGrid.prototype.getItems = function (targets) {\n  // Return all items immediately if no targets were provided or if the\n  // instance is destroyed.\n  if (this._isDestroyed || targets === undefined) {\n    return this._items.slice(0);\n  }\n\n  var items = [];\n  var i, item;\n\n  if (Array.isArray(targets) || isNodeList(targets)) {\n    for (i = 0; i < targets.length; i++) {\n      item = this.getItem(targets[i]);\n      if (item) items.push(item);\n    }\n  } else {\n    item = this.getItem(targets);\n    if (item) items.push(item);\n  }\n\n  return items;\n};\n\n/**\n * Update the cached dimensions of the instance's items. By default all the\n * items are refreshed, but you can also provide an array of target items as the\n * first argument if you want to refresh specific items. Note that all hidden\n * items are not refreshed by default since their \"display\" property is \"none\"\n * and their dimensions are therefore not readable from the DOM. However, if you\n * do want to force update hidden item dimensions too you can provide `true`\n * as the second argument, which makes the elements temporarily visible while\n * their dimensions are being read.\n *\n * @public\n * @param {Item[]} [items]\n * @param {Boolean} [force=false]\n * @returns {Grid}\n */\nGrid.prototype.refreshItems = function (items, force) {\n  if (this._isDestroyed) return this;\n\n  var targets = items || this._items;\n  var i, item, style, hiddenItemStyles;\n\n  if (force === true) {\n    hiddenItemStyles = [];\n    for (i = 0; i < targets.length; i++) {\n      item = targets[i];\n      if (!item.isVisible() && !item.isHiding()) {\n        style = item.getElement().style;\n        style.visibility = 'hidden';\n        style.display = '';\n        hiddenItemStyles.push(style);\n      }\n    }\n  }\n\n  for (i = 0; i < targets.length; i++) {\n    targets[i]._refreshDimensions(force);\n  }\n\n  if (force === true) {\n    for (i = 0; i < hiddenItemStyles.length; i++) {\n      style = hiddenItemStyles[i];\n      style.visibility = '';\n      style.display = 'none';\n    }\n    hiddenItemStyles.length = 0;\n  }\n\n  return this;\n};\n\n/**\n * Update the sort data of the instance's items. By default all the items are\n * refreshed, but you can also provide an array of target items if you want to\n * refresh specific items.\n *\n * @public\n * @param {Item[]} [items]\n * @returns {Grid}\n */\nGrid.prototype.refreshSortData = function (items) {\n  if (this._isDestroyed) return this;\n\n  var targets = items || this._items;\n  for (var i = 0; i < targets.length; i++) {\n    targets[i]._refreshSortData();\n  }\n\n  return this;\n};\n\n/**\n * Synchronize the item elements to match the order of the items in the DOM.\n * This comes handy if you need to keep the DOM structure matched with the\n * order of the items. Note that if an item's element is not currently a child\n * of the container element (if it is dragged for example) it is ignored and\n * left untouched.\n *\n * @public\n * @returns {Grid}\n */\nGrid.prototype.synchronize = function () {\n  if (this._isDestroyed) return this;\n\n  var items = this._items;\n  if (!items.length) return this;\n\n  var fragment;\n  var element;\n\n  for (var i = 0; i < items.length; i++) {\n    element = items[i]._element;\n    if (element.parentNode === this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n\n  if (!fragment) return this;\n\n  this._element.appendChild(fragment);\n  this._emit(EVENT_SYNCHRONIZE);\n\n  return this;\n};\n\n/**\n * Calculate and apply item positions.\n *\n * @public\n * @param {Boolean} [instant=false]\n * @param {Function} [onFinish]\n * @returns {Grid}\n */\nGrid.prototype.layout = function (instant, onFinish) {\n  if (this._isDestroyed) return this;\n\n  // Cancel unfinished layout algorithm if possible.\n  var unfinishedLayout = this._nextLayoutData;\n  if (unfinishedLayout && isFunction(unfinishedLayout.cancel)) {\n    unfinishedLayout.cancel();\n  }\n\n  // Compute layout id (let's stay in Float32 range).\n  layoutId = (layoutId % MAX_SAFE_FLOAT32_INTEGER) + 1;\n  var nextLayoutId = layoutId;\n\n  // Store data for next layout.\n  this._nextLayoutData = {\n    id: nextLayoutId,\n    instant: instant,\n    onFinish: onFinish,\n    cancel: null,\n  };\n\n  // Collect layout items (all active grid items).\n  var items = this._items;\n  var layoutItems = [];\n  for (var i = 0; i < items.length; i++) {\n    if (items[i]._isActive) layoutItems.push(items[i]);\n  }\n\n  // Compute new layout.\n  this._refreshDimensions();\n  var gridWidth = this._width - this._borderLeft - this._borderRight;\n  var gridHeight = this._height - this._borderTop - this._borderBottom;\n  var layoutSettings = this._settings.layout;\n  var cancelLayout;\n  if (isFunction(layoutSettings)) {\n    cancelLayout = layoutSettings(\n      this,\n      nextLayoutId,\n      layoutItems,\n      gridWidth,\n      gridHeight,\n      this._onLayoutDataReceived\n    );\n  } else {\n    Grid.defaultPacker.setOptions(layoutSettings);\n    cancelLayout = Grid.defaultPacker.createLayout(\n      this,\n      nextLayoutId,\n      layoutItems,\n      gridWidth,\n      gridHeight,\n      this._onLayoutDataReceived\n    );\n  }\n\n  // Store layout cancel method if available.\n  if (\n    isFunction(cancelLayout) &&\n    this._nextLayoutData &&\n    this._nextLayoutData.id === nextLayoutId\n  ) {\n    this._nextLayoutData.cancel = cancelLayout;\n  }\n\n  return this;\n};\n\n/**\n * Add new items by providing the elements you wish to add to the instance and\n * optionally provide the index where you want the items to be inserted into.\n * All elements that are not already children of the container element will be\n * automatically appended to the container element. If an element has it's CSS\n * display property set to \"none\" it will be marked as inactive during the\n * initiation process. As long as the item is inactive it will not be part of\n * the layout, but it will retain it's index. You can activate items at any\n * point with grid.show() method. This method will automatically call\n * grid.layout() if one or more of the added elements are visible. If only\n * hidden items are added no layout will be called. All the new visible items\n * are positioned without animation during their first layout.\n *\n * @public\n * @param {(HTMLElement|HTMLElement[])} elements\n * @param {Object} [options]\n * @param {Number} [options.index=-1]\n * @param {Boolean} [options.active]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\nGrid.prototype.add = function (elements, options) {\n  if (this._isDestroyed || !elements) return [];\n\n  var newItems = toArray(elements);\n  if (!newItems.length) return newItems;\n\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var items = this._items;\n  var needsLayout = false;\n  var fragment;\n  var element;\n  var item;\n  var i;\n\n  // Collect all the elements that are not child of the grid element into a\n  // document fragment.\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    if (element.parentNode !== this._element) {\n      fragment = fragment || document.createDocumentFragment();\n      fragment.appendChild(element);\n    }\n  }\n\n  // If we have a fragment, let's append it to the grid element. We could just\n  // not do this and the `new Item()` instantiation would handle this for us,\n  // but this way we can add the elements into the DOM a bit faster.\n  if (fragment) {\n    this._element.appendChild(fragment);\n  }\n\n  // Map provided elements into new grid items.\n  for (i = 0; i < newItems.length; i++) {\n    element = newItems[i];\n    item = newItems[i] = new Item(this, element, opts.active);\n\n    // If the item to be added is active, we need to do a layout. Also, we\n    // need to mark the item with the skipNextAnimation flag to make it\n    // position instantly (without animation) during the next layout. Without\n    // the hack the item would animate to it's new position from the northwest\n    // corner of the grid, which feels a bit buggy (imho).\n    if (item._isActive) {\n      needsLayout = true;\n      item._layout._skipNextAnimation = true;\n    }\n  }\n\n  // Set up the items' initial dimensions and sort data. This needs to be done\n  // in a separate loop to avoid layout thrashing.\n  for (i = 0; i < newItems.length; i++) {\n    item = newItems[i];\n    item._refreshDimensions();\n    item._refreshSortData();\n  }\n\n  // Add the new items to the items collection to correct index.\n  arrayInsert(items, newItems, opts.index);\n\n  // Emit add event.\n  if (this._hasListeners(EVENT_ADD)) {\n    this._emit(EVENT_ADD, newItems.slice(0));\n  }\n\n  // If layout is needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n\n  return newItems;\n};\n\n/**\n * Remove items from the instance.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.removeElements=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Item[]}\n */\nGrid.prototype.remove = function (items, options) {\n  if (this._isDestroyed || !items.length) return [];\n\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var needsLayout = false;\n  var allItems = this.getItems();\n  var targetItems = [];\n  var indices = [];\n  var index;\n  var item;\n  var i;\n\n  // Remove the individual items.\n  for (i = 0; i < items.length; i++) {\n    item = items[i];\n    if (item._isDestroyed) continue;\n\n    index = this._items.indexOf(item);\n    if (index === -1) continue;\n\n    if (item._isActive) needsLayout = true;\n\n    targetItems.push(item);\n    indices.push(allItems.indexOf(item));\n    item._destroy(opts.removeElements);\n    this._items.splice(index, 1);\n  }\n\n  // Emit remove event.\n  if (this._hasListeners(EVENT_REMOVE)) {\n    this._emit(EVENT_REMOVE, targetItems.slice(0), indices);\n  }\n\n  // If layout is needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n\n  return targetItems;\n};\n\n/**\n * Show specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.show = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, true, options);\n  }\n  return this;\n};\n\n/**\n * Hide specific instance items.\n *\n * @public\n * @param {Item[]} items\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.hide = function (items, options) {\n  if (!this._isDestroyed && items.length) {\n    this._setItemsVisibility(items, false, options);\n  }\n  return this;\n};\n\n/**\n * Filter items. Expects at least one argument, a predicate, which should be\n * either a function or a string. The predicate callback is executed for every\n * item in the instance. If the return value of the predicate is truthy the\n * item in question will be shown and otherwise hidden. The predicate callback\n * receives the item instance as it's argument. If the predicate is a string\n * it is considered to be a selector and it is checked against every item\n * element in the instance with the native element.matches() method. All the\n * matching items will be shown and others hidden.\n *\n * @public\n * @param {(Function|String)} predicate\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {FilterCallback} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.filter = function (predicate, options) {\n  if (this._isDestroyed || !this._items.length) return this;\n\n  var itemsToShow = [];\n  var itemsToHide = [];\n  var isPredicateString = typeof predicate === STRING_TYPE;\n  var isPredicateFn = isFunction(predicate);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var syncWithLayout = opts.syncWithLayout;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var onFinish = isFunction(opts.onFinish) ? opts.onFinish : null;\n  var tryFinishCounter = -1;\n  var tryFinish = noop;\n  var item;\n  var i;\n\n  // If we have onFinish callback, let's create proper tryFinish callback.\n  if (onFinish) {\n    tryFinish = function () {\n      ++tryFinishCounter && onFinish(itemsToShow.slice(0), itemsToHide.slice(0));\n    };\n  }\n\n  // Check which items need to be shown and which hidden.\n  if (isPredicateFn || isPredicateString) {\n    for (i = 0; i < this._items.length; i++) {\n      item = this._items[i];\n      if (isPredicateFn ? predicate(item) : elementMatches(item._element, predicate)) {\n        itemsToShow.push(item);\n      } else {\n        itemsToHide.push(item);\n      }\n    }\n  }\n\n  // Show items that need to be shown.\n  if (itemsToShow.length) {\n    this.show(itemsToShow, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false,\n    });\n  } else {\n    tryFinish();\n  }\n\n  // Hide items that need to be hidden.\n  if (itemsToHide.length) {\n    this.hide(itemsToHide, {\n      instant: isInstant,\n      syncWithLayout: syncWithLayout,\n      onFinish: tryFinish,\n      layout: false,\n    });\n  } else {\n    tryFinish();\n  }\n\n  // If there are any items to filter.\n  if (itemsToShow.length || itemsToHide.length) {\n    // Emit filter event.\n    if (this._hasListeners(EVENT_FILTER)) {\n      this._emit(EVENT_FILTER, itemsToShow.slice(0), itemsToHide.slice(0));\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sort items. There are three ways to sort the items. The first is simply by\n * providing a function as the comparer which works identically to native\n * array sort. Alternatively you can sort by the sort data you have provided\n * in the instance's options. Just provide the sort data key(s) as a string\n * (separated by space) and the items will be sorted based on the provided\n * sort data keys. Lastly you have the opportunity to provide a presorted\n * array of items which will be used to sync the internal items array in the\n * same order.\n *\n * @public\n * @param {(Function|String|Item[])} comparer\n * @param {Object} [options]\n * @param {Boolean} [options.descending=false]\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.sort = (function () {\n  var sortComparer;\n  var isDescending;\n  var origItems;\n  var indexMap;\n\n  function defaultComparer(a, b) {\n    var result = 0;\n    var criteriaName;\n    var criteriaOrder;\n    var valA;\n    var valB;\n\n    // Loop through the list of sort criteria.\n    for (var i = 0; i < sortComparer.length; i++) {\n      // Get the criteria name, which should match an item's sort data key.\n      criteriaName = sortComparer[i][0];\n      criteriaOrder = sortComparer[i][1];\n\n      // Get items' cached sort values for the criteria. If the item has no sort\n      // data let's update the items sort data (this is a lazy load mechanism).\n      valA = (a._sortData ? a : a._refreshSortData())._sortData[criteriaName];\n      valB = (b._sortData ? b : b._refreshSortData())._sortData[criteriaName];\n\n      // Sort the items in descending order if defined so explicitly. Otherwise\n      // sort items in ascending order.\n      if (criteriaOrder === 'desc' || (!criteriaOrder && isDescending)) {\n        result = valB < valA ? -1 : valB > valA ? 1 : 0;\n      } else {\n        result = valA < valB ? -1 : valA > valB ? 1 : 0;\n      }\n\n      // If we have -1 or 1 as the return value, let's return it immediately.\n      if (result) return result;\n    }\n\n    // If values are equal let's compare the item indices to make sure we\n    // have a stable sort. Note that this is not necessary in evergreen browsers\n    // because Array.sort() is nowadays stable. However, in order to guarantee\n    // same results in older browsers we need this.\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n    return result;\n  }\n\n  function customComparer(a, b) {\n    var result = isDescending ? -sortComparer(a, b) : sortComparer(a, b);\n    if (!result) {\n      if (!indexMap) indexMap = createIndexMap(origItems);\n      result = isDescending ? compareIndexMap(indexMap, b, a) : compareIndexMap(indexMap, a, b);\n    }\n    return result;\n  }\n\n  return function (comparer, options) {\n    if (this._isDestroyed || this._items.length < 2) return this;\n\n    var items = this._items;\n    var opts = options || {};\n    var layout = opts.layout ? opts.layout : opts.layout === undefined;\n\n    // Setup parent scope data.\n    isDescending = !!opts.descending;\n    origItems = items.slice(0);\n    indexMap = null;\n\n    // If function is provided do a native array sort.\n    if (isFunction(comparer)) {\n      sortComparer = comparer;\n      items.sort(customComparer);\n    }\n    // Otherwise if we got a string, let's sort by the sort data as provided in\n    // the instance's options.\n    else if (typeof comparer === STRING_TYPE) {\n      sortComparer = comparer\n        .trim()\n        .split(' ')\n        .filter(function (val) {\n          return val;\n        })\n        .map(function (val) {\n          return val.split(':');\n        });\n      items.sort(defaultComparer);\n    }\n    // Otherwise if we got an array, let's assume it's a presorted array of the\n    // items and order the items based on it. Here we blindly trust that the\n    // presorted array consists of the same item instances as the current\n    // `gird._items` array.\n    else if (Array.isArray(comparer)) {\n      items.length = 0;\n      items.push.apply(items, comparer);\n    }\n    // Otherwise let's throw an error.\n    else {\n      sortComparer = isDescending = origItems = indexMap = null;\n      throw new Error('Invalid comparer argument provided.');\n    }\n\n    // Emit sort event.\n    if (this._hasListeners(EVENT_SORT)) {\n      this._emit(EVENT_SORT, items.slice(0), origItems);\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n\n    // Reset data (to avoid mem leaks).\n    sortComparer = isDescending = origItems = indexMap = null;\n\n    return this;\n  };\n})();\n\n/**\n * Move item to another index or in place of another item.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {String} [options.action=\"move\"]\n *   - Accepts either \"move\" or \"swap\".\n *   - \"move\" moves the item in place of the other item.\n *   - \"swap\" swaps the position of the items.\n * @param {(Boolean|Function|String)} [options.layout=true]\n * @returns {Grid}\n */\nGrid.prototype.move = function (item, position, options) {\n  if (this._isDestroyed || this._items.length < 2) return this;\n\n  var items = this._items;\n  var opts = options || {};\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var isSwap = opts.action === ACTION_SWAP;\n  var action = isSwap ? ACTION_SWAP : ACTION_MOVE;\n  var fromItem = this.getItem(item);\n  var toItem = this.getItem(position);\n  var fromIndex;\n  var toIndex;\n\n  // Make sure the items exist and are not the same.\n  if (fromItem && toItem && fromItem !== toItem) {\n    // Get the indices of the items.\n    fromIndex = items.indexOf(fromItem);\n    toIndex = items.indexOf(toItem);\n\n    // Do the move/swap.\n    if (isSwap) {\n      arraySwap(items, fromIndex, toIndex);\n    } else {\n      arrayMove(items, fromIndex, toIndex);\n    }\n\n    // Emit move event.\n    if (this._hasListeners(EVENT_MOVE)) {\n      this._emit(EVENT_MOVE, {\n        item: fromItem,\n        fromIndex: fromIndex,\n        toIndex: toIndex,\n        action: action,\n      });\n    }\n\n    // If layout is needed.\n    if (layout) {\n      this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Send item to another Grid instance.\n *\n * @public\n * @param {(HtmlElement|Number|Item)} item\n * @param {Grid} targetGrid\n * @param {(HtmlElement|Number|Item)} position\n * @param {Object} [options]\n * @param {HTMLElement} [options.appendTo=document.body]\n * @param {(Boolean|Function|String)} [options.layoutSender=true]\n * @param {(Boolean|Function|String)} [options.layoutReceiver=true]\n * @returns {Grid}\n */\nGrid.prototype.send = function (item, targetGrid, position, options) {\n  if (this._isDestroyed || targetGrid._isDestroyed || this === targetGrid) return this;\n\n  // Make sure we have a valid target item.\n  item = this.getItem(item);\n  if (!item) return this;\n\n  var opts = options || {};\n  var container = opts.appendTo || document.body;\n  var layoutSender = opts.layoutSender ? opts.layoutSender : opts.layoutSender === undefined;\n  var layoutReceiver = opts.layoutReceiver\n    ? opts.layoutReceiver\n    : opts.layoutReceiver === undefined;\n\n  // Start the migration process.\n  item._migrate.start(targetGrid, position, container);\n\n  // If migration was started successfully and the item is active, let's layout\n  // the grids.\n  if (item._migrate._isActive && item._isActive) {\n    if (layoutSender) {\n      this.layout(\n        layoutSender === INSTANT_LAYOUT,\n        isFunction(layoutSender) ? layoutSender : undefined\n      );\n    }\n    if (layoutReceiver) {\n      targetGrid.layout(\n        layoutReceiver === INSTANT_LAYOUT,\n        isFunction(layoutReceiver) ? layoutReceiver : undefined\n      );\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the instance.\n *\n * @public\n * @param {Boolean} [removeElements=false]\n * @returns {Grid}\n */\nGrid.prototype.destroy = function (removeElements) {\n  if (this._isDestroyed) return this;\n\n  var container = this._element;\n  var items = this._items.slice(0);\n  var layoutStyles = (this._layout && this._layout.styles) || {};\n  var i, prop;\n\n  // Unbind window resize event listener.\n  unbindLayoutOnResize(this);\n\n  // Destroy items.\n  for (i = 0; i < items.length; i++) items[i]._destroy(removeElements);\n  this._items.length = 0;\n\n  // Restore container.\n  removeClass(container, this._settings.containerClass);\n  for (prop in layoutStyles) container.style[prop] = '';\n\n  // Emit destroy event and unbind all events.\n  this._emit(EVENT_DESTROY);\n  this._emitter.destroy();\n\n  // Remove reference from the grid instances collection.\n  delete GRID_INSTANCES[this._id];\n\n  // Flag instance as destroyed.\n  this._isDestroyed = true;\n\n  return this;\n};\n\n/**\n * Private prototype methods\n * *************************\n */\n\n/**\n * Emit a grid event.\n *\n * @private\n * @param {String} event\n * @param {...*} [arg]\n */\nGrid.prototype._emit = function () {\n  if (this._isDestroyed) return;\n  this._emitter.emit.apply(this._emitter, arguments);\n};\n\n/**\n * Check if there are any events listeners for an event.\n *\n * @private\n * @param {String} event\n * @returns {Boolean}\n */\nGrid.prototype._hasListeners = function (event) {\n  if (this._isDestroyed) return false;\n  return this._emitter.countListeners(event) > 0;\n};\n\n/**\n * Update container's width, height and offsets.\n *\n * @private\n */\nGrid.prototype._updateBoundingRect = function () {\n  var element = this._element;\n  var rect = element.getBoundingClientRect();\n  this._width = rect.width;\n  this._height = rect.height;\n  this._left = rect.left;\n  this._top = rect.top;\n  this._right = rect.right;\n  this._bottom = rect.bottom;\n};\n\n/**\n * Update container's border sizes.\n *\n * @private\n * @param {Boolean} left\n * @param {Boolean} right\n * @param {Boolean} top\n * @param {Boolean} bottom\n */\nGrid.prototype._updateBorders = function (left, right, top, bottom) {\n  var element = this._element;\n  if (left) this._borderLeft = getStyleAsFloat(element, 'border-left-width');\n  if (right) this._borderRight = getStyleAsFloat(element, 'border-right-width');\n  if (top) this._borderTop = getStyleAsFloat(element, 'border-top-width');\n  if (bottom) this._borderBottom = getStyleAsFloat(element, 'border-bottom-width');\n};\n\n/**\n * Refresh all of container's internal dimensions and offsets.\n *\n * @private\n */\nGrid.prototype._refreshDimensions = function () {\n  this._updateBoundingRect();\n  this._updateBorders(1, 1, 1, 1);\n  this._boxSizing = getStyle(this._element, 'box-sizing');\n};\n\n/**\n * Calculate and apply item positions.\n *\n * @private\n * @param {Object} layout\n */\nGrid.prototype._onLayoutDataReceived = (function () {\n  var itemsToLayout = [];\n  return function (layout) {\n    if (this._isDestroyed || !this._nextLayoutData || this._nextLayoutData.id !== layout.id) return;\n\n    var grid = this;\n    var instant = this._nextLayoutData.instant;\n    var onFinish = this._nextLayoutData.onFinish;\n    var numItems = layout.items.length;\n    var counter = numItems;\n    var item;\n    var left;\n    var top;\n    var i;\n\n    // Reset next layout data.\n    this._nextLayoutData = null;\n\n    if (!this._isLayoutFinished && this._hasListeners(EVENT_LAYOUT_ABORT)) {\n      this._emit(EVENT_LAYOUT_ABORT, this._layout.items.slice(0));\n    }\n\n    // Update the layout reference.\n    this._layout = layout;\n\n    // Update the item positions and collect all items that need to be laid\n    // out. It is critical that we update the item position _before_ the\n    // layoutStart event as the new data might be needed in the callback.\n    itemsToLayout.length = 0;\n    for (i = 0; i < numItems; i++) {\n      item = layout.items[i];\n\n      // Make sure we have a matching item.\n      if (!item) {\n        --counter;\n        continue;\n      }\n\n      // Get the item's new left and top values.\n      left = layout.slots[i * 2];\n      top = layout.slots[i * 2 + 1];\n\n      // Let's skip the layout process if we can. Possibly avoids a lot of DOM\n      // operations which saves us some CPU cycles.\n      if (item._canSkipLayout(left, top)) {\n        --counter;\n        continue;\n      }\n\n      // Update the item's position.\n      item._left = left;\n      item._top = top;\n\n      // Only active non-dragged items need to be moved.\n      if (item.isActive() && !item.isDragging()) {\n        itemsToLayout.push(item);\n      } else {\n        --counter;\n      }\n    }\n\n    // Set layout styles to the grid element.\n    if (layout.styles) {\n      setStyles(this._element, layout.styles);\n    }\n\n    // layoutStart event is intentionally emitted after the container element's\n    // dimensions are set, because otherwise there would be no hook for reacting\n    // to container dimension changes.\n    if (this._hasListeners(EVENT_LAYOUT_START)) {\n      this._emit(EVENT_LAYOUT_START, layout.items.slice(0), instant === true);\n      // Let's make sure that the current layout process has not been overridden\n      // in the layoutStart event, and if so, let's stop processing the aborted\n      // layout.\n      if (this._layout.id !== layout.id) return;\n    }\n\n    var tryFinish = function () {\n      if (--counter > 0) return;\n\n      var hasLayoutChanged = grid._layout.id !== layout.id;\n      var callback = isFunction(instant) ? instant : onFinish;\n\n      if (!hasLayoutChanged) {\n        grid._isLayoutFinished = true;\n      }\n\n      if (isFunction(callback)) {\n        callback(layout.items.slice(0), hasLayoutChanged);\n      }\n\n      if (!hasLayoutChanged && grid._hasListeners(EVENT_LAYOUT_END)) {\n        grid._emit(EVENT_LAYOUT_END, layout.items.slice(0));\n      }\n    };\n\n    if (!itemsToLayout.length) {\n      tryFinish();\n      return this;\n    }\n\n    this._isLayoutFinished = false;\n\n    for (i = 0; i < itemsToLayout.length; i++) {\n      if (this._layout.id !== layout.id) break;\n      itemsToLayout[i]._layout.start(instant === true, tryFinish);\n    }\n\n    if (this._layout.id === layout.id) {\n      itemsToLayout.length = 0;\n    }\n\n    return this;\n  };\n})();\n\n/**\n * Show or hide Grid instance's items.\n *\n * @private\n * @param {Item[]} items\n * @param {Boolean} toVisible\n * @param {Object} [options]\n * @param {Boolean} [options.instant=false]\n * @param {Boolean} [options.syncWithLayout=true]\n * @param {Function} [options.onFinish]\n * @param {(Boolean|Function|String)} [options.layout=true]\n */\nGrid.prototype._setItemsVisibility = function (items, toVisible, options) {\n  var grid = this;\n  var targetItems = items.slice(0);\n  var opts = options || {};\n  var isInstant = opts.instant === true;\n  var callback = opts.onFinish;\n  var layout = opts.layout ? opts.layout : opts.layout === undefined;\n  var counter = targetItems.length;\n  var startEvent = toVisible ? EVENT_SHOW_START : EVENT_HIDE_START;\n  var endEvent = toVisible ? EVENT_SHOW_END : EVENT_HIDE_END;\n  var method = toVisible ? 'show' : 'hide';\n  var needsLayout = false;\n  var completedItems = [];\n  var hiddenItems = [];\n  var item;\n  var i;\n\n  // If there are no items call the callback, but don't emit any events.\n  if (!counter) {\n    if (isFunction(callback)) callback(targetItems);\n    return;\n  }\n\n  // Prepare the items.\n  for (i = 0; i < targetItems.length; i++) {\n    item = targetItems[i];\n\n    // If inactive item is shown or active item is hidden we need to do\n    // layout.\n    if ((toVisible && !item._isActive) || (!toVisible && item._isActive)) {\n      needsLayout = true;\n    }\n\n    // If inactive item is shown we also need to do a little hack to make the\n    // item not animate it's next positioning (layout).\n    item._layout._skipNextAnimation = !!(toVisible && !item._isActive);\n\n    // If a hidden item is being shown we need to refresh the item's\n    // dimensions.\n    if (toVisible && item._visibility._isHidden) {\n      hiddenItems.push(item);\n    }\n\n    // Add item to layout or remove it from layout.\n    if (toVisible) {\n      item._addToLayout();\n    } else {\n      item._removeFromLayout();\n    }\n  }\n\n  // Force refresh the dimensions of all hidden items.\n  if (hiddenItems.length) {\n    this.refreshItems(hiddenItems, true);\n    hiddenItems.length = 0;\n  }\n\n  // Show the items in sync with the next layout.\n  function triggerVisibilityChange() {\n    if (needsLayout && opts.syncWithLayout !== false) {\n      grid.off(EVENT_LAYOUT_START, triggerVisibilityChange);\n    }\n\n    if (grid._hasListeners(startEvent)) {\n      grid._emit(startEvent, targetItems.slice(0));\n    }\n\n    for (i = 0; i < targetItems.length; i++) {\n      // Make sure the item is still in the original grid. There is a chance\n      // that the item starts migrating before tiggerVisibilityChange is called.\n      if (targetItems[i]._gridId !== grid._id) {\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n        continue;\n      }\n\n      targetItems[i]._visibility[method](isInstant, function (interrupted, item) {\n        // If the current item's animation was not interrupted add it to the\n        // completedItems array.\n        if (!interrupted) completedItems.push(item);\n\n        // If all items have finished their animations call the callback\n        // and emit showEnd/hideEnd event.\n        if (--counter < 1) {\n          if (isFunction(callback)) callback(completedItems.slice(0));\n          if (grid._hasListeners(endEvent)) grid._emit(endEvent, completedItems.slice(0));\n        }\n      });\n    }\n  }\n\n  // Trigger the visibility change, either async with layout or instantly.\n  if (needsLayout && opts.syncWithLayout !== false) {\n    this.on(EVENT_LAYOUT_START, triggerVisibilityChange);\n  } else {\n    triggerVisibilityChange();\n  }\n\n  // Trigger layout if needed.\n  if (needsLayout && layout) {\n    this.layout(layout === INSTANT_LAYOUT, isFunction(layout) ? layout : undefined);\n  }\n};\n\n/**\n * Private helpers\n * ***************\n */\n\n/**\n * Merge default settings with user settings. The returned object is a new\n * object with merged values. The merging is a deep merge meaning that all\n * objects and arrays within the provided settings objects will be also merged\n * so that modifying the values of the settings object will have no effect on\n * the returned object.\n *\n * @param {Object} defaultSettings\n * @param {Object} [userSettings]\n * @returns {Object} Returns a new object.\n */\nfunction mergeSettings(defaultSettings, userSettings) {\n  // Create a fresh copy of default settings.\n  var settings = mergeObjects({}, defaultSettings);\n\n  // Merge user settings to default settings.\n  if (userSettings) {\n    settings = mergeObjects(settings, userSettings);\n  }\n\n  // Handle visible/hidden styles manually so that the whole object is\n  // overridden instead of the props.\n\n  if (userSettings && userSettings.visibleStyles) {\n    settings.visibleStyles = userSettings.visibleStyles;\n  } else if (defaultSettings && defaultSettings.visibleStyles) {\n    settings.visibleStyles = defaultSettings.visibleStyles;\n  }\n\n  if (userSettings && userSettings.hiddenStyles) {\n    settings.hiddenStyles = userSettings.hiddenStyles;\n  } else if (defaultSettings && defaultSettings.hiddenStyles) {\n    settings.hiddenStyles = defaultSettings.hiddenStyles;\n  }\n\n  return settings;\n}\n\n/**\n * Merge two objects recursively (deep merge). The source object's properties\n * are merged to the target object.\n *\n * @param {Object} target\n *   - The target object.\n * @param {Object} source\n *   - The source object.\n * @returns {Object} Returns the target object.\n */\nfunction mergeObjects(target, source) {\n  var sourceKeys = Object.keys(source);\n  var length = sourceKeys.length;\n  var isSourceObject;\n  var propName;\n  var i;\n\n  for (i = 0; i < length; i++) {\n    propName = sourceKeys[i];\n    isSourceObject = isPlainObject(source[propName]);\n\n    // If target and source values are both objects, merge the objects and\n    // assign the merged value to the target property.\n    if (isPlainObject(target[propName]) && isSourceObject) {\n      target[propName] = mergeObjects(mergeObjects({}, target[propName]), source[propName]);\n      continue;\n    }\n\n    // If source's value is object and target's is not let's clone the object as\n    // the target's value.\n    if (isSourceObject) {\n      target[propName] = mergeObjects({}, source[propName]);\n      continue;\n    }\n\n    // If source's value is an array let's clone the array as the target's\n    // value.\n    if (Array.isArray(source[propName])) {\n      target[propName] = source[propName].slice(0);\n      continue;\n    }\n\n    // In all other cases let's just directly assign the source's value as the\n    // target's value.\n    target[propName] = source[propName];\n  }\n\n  return target;\n}\n\n/**\n * Collect and return initial items for grid.\n *\n * @param {HTMLElement} gridElement\n * @param {?(HTMLElement[]|NodeList|HtmlCollection|String)} elements\n * @returns {(HTMLElement[]|NodeList|HtmlCollection)}\n */\nfunction getInitialGridElements(gridElement, elements) {\n  // If we have a wildcard selector let's return all the children.\n  if (elements === '*') {\n    return gridElement.children;\n  }\n\n  // If we have some more specific selector, let's filter the elements.\n  if (typeof elements === STRING_TYPE) {\n    var result = [];\n    var children = gridElement.children;\n    for (var i = 0; i < children.length; i++) {\n      if (elementMatches(children[i], elements)) {\n        result.push(children[i]);\n      }\n    }\n    return result;\n  }\n\n  // If we have an array of elements or a node list.\n  if (Array.isArray(elements) || isNodeList(elements)) {\n    return elements;\n  }\n\n  // Otherwise just return an empty array.\n  return [];\n}\n\n/**\n * Bind grid's resize handler to window.\n *\n * @param {Grid} grid\n * @param {(Number|Boolean)} delay\n */\nfunction bindLayoutOnResize(grid, delay) {\n  if (typeof delay !== NUMBER_TYPE) {\n    delay = delay === true ? 0 : -1;\n  }\n\n  if (delay >= 0) {\n    grid._resizeHandler = debounce(function () {\n      grid.refreshItems().layout();\n    }, delay);\n\n    window.addEventListener('resize', grid._resizeHandler);\n  }\n}\n\n/**\n * Unbind grid's resize handler from window.\n *\n * @param {Grid} grid\n */\nfunction unbindLayoutOnResize(grid) {\n  if (grid._resizeHandler) {\n    grid._resizeHandler(true);\n    window.removeEventListener('resize', grid._resizeHandler);\n    grid._resizeHandler = null;\n  }\n}\n\n/**\n * Normalize style declaration object, returns a normalized (new) styles object\n * (prefixed properties and invalid properties removed).\n *\n * @param {Object} styles\n * @returns {Object}\n */\nfunction normalizeStyles(styles) {\n  var normalized = {};\n  var docElemStyle = document.documentElement.style;\n  var prop, prefixedProp;\n\n  // Normalize visible styles (prefix and remove invalid).\n  for (prop in styles) {\n    if (!styles[prop]) continue;\n    prefixedProp = getPrefixedPropName(docElemStyle, prop);\n    if (!prefixedProp) continue;\n    normalized[prefixedProp] = styles[prop];\n  }\n\n  return normalized;\n}\n\n/**\n * Create index map from items.\n *\n * @param {Item[]} items\n * @returns {Object}\n */\nfunction createIndexMap(items) {\n  var result = {};\n  for (var i = 0; i < items.length; i++) {\n    result[items[i]._id] = i;\n  }\n  return result;\n}\n\n/**\n * Sort comparer function for items' index map.\n *\n * @param {Object} indexMap\n * @param {Item} itemA\n * @param {Item} itemB\n * @returns {Number}\n */\nfunction compareIndexMap(indexMap, itemA, itemB) {\n  var indexA = indexMap[itemA._id];\n  var indexB = indexMap[itemB._id];\n  return indexA - indexB;\n}\n\nexport default Grid;\n"]},"metadata":{},"sourceType":"module"}